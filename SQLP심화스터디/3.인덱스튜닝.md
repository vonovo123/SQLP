# 인덱스 튜닝

## 인덱스 기본원리

1. B\*TREE 인덱스

B\*TREE 인덱스의 구조를 요약하면 다음과 같다.

\- 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다.
\- 브랜치 블록의 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다.
\- 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
\- 리프 블록의 각 로우의 키 값은 테이블 로우의 키 값과 일치한다.
\- 리프 블록의 로우와 테이블 로우는 1:1 관계이다.
\- 리프 블록끼리는 이중연결리스트로 구성돼있다.

---

브랜치 블록의 키 값은 하위 블록의 값의 범위를 의미하므로 하위 블록의 첫 로우의 키 값과 일치하지 않을 수 있다.

2. ROWID 구성요소

오라클 8 버전부터 사용하기 시작한 확장 ROWID 는 [오브젝트 번호 + 데이터 파일번호 + 블록 번호 + 블록 내 로우번호] 로 구성된다.

3. B\*TREE 인덱스 탐색

B\*TREE 인덱스를 탐색할 때는 우선 루트에서 리프 블록까지 수직적 탐색을 통해 스캔 시작지점을 찾는다.
수직적 탐색을 통해 조건을 만족하는 첫 번째 레코드를 찾았으면 인덱스리프블록틀 수평적 탐색하면서 만족하는 데이터가 더이상 나타나지 않을 때 까지
수평적 탐색을 진행한다.

4. INDEX 힌트

INDEX 힌트 내부에 인덱스의 선두 컬럼이 아닌 컬럼을 직접 입력하면 옵티마이저에 의해 무시된다.

```sql
-- 고객_pk : 고객번호
-- 고객_x1 : 가입일자 + 성별 + 고객명
select /*+INDEX(C (가입일자, 고객명))*/ 고객번호 ...
from 고객

```

5. SQL SERVER HINT

```SQL
DECLARE @CUST_NO INT

SELECT *
FROM 고객 WITH ( FORCESEEK (고객_PK (고객번호)))
WHERE 고객번호 = @CUST_NO

```

아래와 같이 FORESCAN을 지정하면 고객번호로 검색하지 않고 FULL SCAN으로 고객번호를 필터링한다.

```SQL
DECLARE @CUST_NO INT

SELECT *
FROM 고객 WITH ( FORCESCAN))
WHERE 고객번호 = @CUST_NO
```

1번처럼 WITH 절에 INDEX(1)을 지정하면 고객번호로 클러스터형 인덱스를 검색한다.
만약 WITH 절에 INDEX(0)을 지정하면 클러스터형 인덱스를 SCAN 하면서 고객번호를 필터링 한다.

참고로, 클러스터형 인덱스가 없는 상황에서 WITH 절에 INDEX(0)을 지정하면 테이블 full scan 하면서
조건절을 필터링하며, INDEX(1)을 지정하면 구문 오류가 발생한다.
4번도 구문 오류가 발생한다.option 절을 이용하려면 힌트를 아래와 같이 기술해야 한다.

```SQL
DECLARE @CUST_NO INT
SELECT *
FROM 고객
WHERE 고객번호 = @CUST_NO
OPTION (TABLE HINT(고객, INDEX(고객_PK)))
```

6. SQL SERVER HINT

클러스터형 인덱스가 없는 상황에서 WITH절에 INDEX(0)을 지정하면 테이블을 FULL SCAN 하면서 조건 절을 필터링 한다.

INDEX(1)을 지정하면 구문 오류가 발생한다.

PK 인덱스를 사용하도록 강제하면 PK 인덱스를 스캔하면서 얻은 RID로 테이블을 랜덤 엑세스하는 실행 계획이 생성된다.
인덱스 컬럼을 가공하면 테이블을 FULL SCAN 한다.

7. INDEX RANGE SCAN

INDEX RANGE SCAN 하려면, WHERE 절에 인덱스 선두 컬럼에 대한 조건이 반드시 있어야 하지만 = 조건일 필요는 없다.
부등호, BETWEEN, LIKE 모두 가능하다.

8. INDEX FULL SCAN

INDEX FULL SCAN은 인덱스 리프 블록을 처음부터 끝까지 모두 스캔하는 방식이다.
인덱스 선두 컬럼이 조건절에 없을 때 사용된다.
인덱스 선두 컬럼이 조건절에 없으면 INDEX RANGE SCAN이 불가능 하므로 테이블 FULL SCAN 해야한다.

INDEX FULL SCAN은 인덱스 필터 조건을 만족하는 데이터가 적을 때 유리하다. 하지만 부분범위 처리를 활용할 수 있다면(전체 데이터를 읽을 필요가 없다면) 효과적일 수 있다

오라클은 INDEX_FS 힌트를 제공하지 않는다. INDEX 힌트로 지정한 인덱스 선두 컬럼이 조건절에 없으면 INDEX FULL SCAN이 자동으로 선택되기 때문이다.

9. INDEX RANGE SCAN

PK 인덱스에 있는 컬럼을 모두 조건절의 등차조건으로 검색하면 옵티마이저는 INDEX UNIQUE SCAN을 선택한다.

전체 컬럼이 아닌 일부 컬럼을 선택할 때는 INDEX RANGE SCAN이 선택된다.

10. INDEX FAST FULL SCAN

인덱스 리프블록 전체를 MULTIBLOCK I/O방식으로 빠르게 FULL SCAN 한다.
리프블록의 논리적 연결 순서를 따르지 않고 세그먼트 단위로 스캔하므로 빠르지만 결과집합의 순서가 보장되지 않는다.
병렬 스캔이 가능하고 테이블 I/O가 발생하지 않으므로 인덱스에 포함된 컬럼으로만 조회할 때 사용 가능하다.

11. INDEX SKIP SCAN

인덱스의 선두 컬럼이 조건절로 선택되지 않으면 옵티마이저는 기본적으로 TABLE FULL SCAN을 선택한다.
INDEX FULL SCAN 방식이 더 효율적이라면 INDEX FULL SCAN을 선택할 수도 있다.
인덱스의 선구컬럼의 DISTINCT VALUE 의 수가 적다면 INDEX SKIP SCAN을 선택할 수 있다.

루트 또는 브랜치 블록에서 읽은 칼럼값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 하위 블록만 골라서 엑세스하는 방식이라고 할 수 있다.

조건절에서 빠진 인덱스 선두 칼럼의 DISTINCT VALUE 개수가 적어야 유리하다. DISTINCT가 높으면 DISTINCT 의 수만큼 SKIP이 일어나기 때문이다. 반대로 후행 칼럼의 DISTINCT VALUE 개수가 많을 때 유용하다.
인덱스 후행 컬럼의 조건절이 BETWEEN LIKE, 부등호 일 때도 사용 가능하다.

12. 여러 INDEX SCAN의 사용조건

인덱스 선두 컬럼이 조건절에 없으면 INDEX UNIQUE SCAN, INDEX RANGE SCAN은 불가능하다.

INDEX FULL SCAN, INDEX SKIP SCAN은 가능하지만 SELECT 절에 인덱스 구성컬럼이 아닌 컬럼이 존재하면 INDEX FAST FULL SCAN의 사용은 불가하다.

13. 여러 INDEX SCAN의 사용조건

인덱스에 없는 컬럼을 조건절에 사용하면 INDEX FULL SCAN 또는 INDEX RANGE SCAN 을 선택한다.

선두 컬럼이 조건절에 존재하면 INDEX RANGE SCAN이 가능하다.

INDEX SKIP SCAN도 가능한데 후행 조건절에 쓰인 컬럼의 레코드 중복이 없다면 INDEX SKIP SCAN이 더 유리할 수 있다.

14. INDEX SKIP SCAN

INDEX SKIP SCAN은 distict 가 적은 인덱스 선두 컬럼이 조건절에 없을 때 유용한 스캔 방식이다. 다수의 선두컬럼이 조건절에 없을때도 사용할 수 있다.

선두 컬럼에 대한 조건절은 있고 중간 컬럼에 대한 조건절이 없는 경우에도 SKIP SCAN을 사용할 수 있다.

선두 컬럼이 부등호, between, like 같은 범위검색 조건일 때도 INDEX SKIP SCAN을 사용할 수 있다.

하지만 IN 조건이 인덱스 엑세스 조건일 때는 사용할 수 없다.

15. B\*TREE INDEX FRAGMENTATION

INDEX SKEW 는 인덱스 엔트리가 한 쪽으로 치우치는 현상을 말한다.

INDEX SPARESE는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말한다.

B\*TREE 는 BALANCED TREE의 약자로 인덱스 루트로부터 모든 리프 블록까지의 높이가 항상 동일함을 의미한다. 따라서 인덱스 높이에 따른 불균형 현상은 절대 발생하지 않는다.

16. BITMAP INDEX

비트맵 인덱스는 성별처럼 DISTINCT VALUE의 개수가 적을때 효율이 매우 좋다.

인덱스 자체가 적은 용량을 차지하므로 인덱스가 여러 개 필요한 대용량 테이블에 유용하다.

비트맵 인덱스는 여러 인덱스를 동시에 사용할 수 있다. 여러 개 비트맵 인덱스로 BITWISE 연산을 수행함으로써 테이블 액세스량을 크게 줄일 수 있다면 극단적인 성능 향상이 가능하다.

따라서 다양한 조건절이 사용되는 대용량 DW/OLAP 환경에 적합하다.

다만, 비트맵 인덱스는 LOCK에 의한 DWL 부하가 심한 것이 단점이다.
레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 발생한다.
OLTP 환경에 비트맵 인덱스가 적합하지 않은 이유이다.

17. 함수기반 인덱스

조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 index range scan이 불가능하다.
인덱스에서 가공하지 않은 값을 기준으로 정렬했는데 가공한 값으로 검색하면 수평적 탐색에 필요한 스캔 시작점과 끝점을 찾을 수 없기 때문이다.

이때 인덱스에도 함수를 적용한 상태로 값을 저장하면 정상적인 INDEX RANGE SCAN이 가능한데 이를 함수 기반 인덱스라고 한다.

```sql
CREATE INDEX 고객_x01 on 고객(REPLACE(전화번호, '_', ''))
```

18. 리버스 키 인덱스

일련번호, 입력일시, 변경일시 등 오름차순 한 반향으롬나 값이 증가하는 컬럼에 인덱스를 생성하면, 동시에 INSERT 하려는 다중 트랜잭션에 의해 맨 우측 리프 블록에 경합이 발생할 수 있다.

이때 인덱스 키 값을 역으로 반환해서 저장하면 신규로 INSERT 하는 값들이 여러 리프 블록에 흩어지므로 경합도 자연스럽게 줄어든다.

```sql
CREATE INDEX HOT_TABLE_R1 ON HOT_TABLE(RIGHT_GROWING_COL) REVERSE;
```

리버스 키 인덱스는 RIGHT GROWING INDEX에 발생하는 블록 경합을 해소하는데 도움을 줄 수 있다.

19. 리버스 키 인덱스

IOT는 테이블을 인덱스 구조로 관리한다. 지정한 키 값 순으로 정렬 상태를 유지한다. 키 값 이외도 컬럼도 모두 인덱스 리프 블록에 저장하므로 테이블 랜덤 액세스가 전혀 발생하지 않는다.

클러스터는 값이 같은 레코드를 한 블록에 저장하므로 인덱스르 이용한 데이블 랜덤 엑세스르 줄이는 데 도움을 준다.

테이블 파티션은 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장한다.
따라서 특정 조건을 만족하는 인덱스를 이용한 랜덤 액세스가 아닌 TABLE
FULL SCAN 방식으로 빠르게 찾을 수 있다.

20. IOT

IOT는 Pk 순으로 정렬 상태를 유지하는 테이블이다.

일반 속성이 없고 PK만 있는 테이블을 iOT 로 구성하면 별도의 인덱스를 생성할 필요가 없고 INSERT 성능도 높일 수 있다.

특정 컬럼으로 기준으로 기간데이터를 조회하는 요건이 많은 테이블의 기준 컬럼으로 IOT를 만들면 효율적이다.

넓은 기간으로 조회해야하는 요건이 많은 테이블을 일자를 기준으로 IOT로 구성하면 효율적이다.

컬럼이 많은 테이블을 IOT로 구성하면 인덱스 DEPTH 증가에 따른 블록 I/O 증가로다 테이블 랜덤 액세스 감소 효과가 상쇄된다.

21. SQL SERVER 클러스터형 인덱스

오라클은 PK 컬럼으로 IOT를 정의해야 하지만, SQL SERVER 클러스터형 인덱스는 PK가 아닌 칼럼으로도 생성할 수 있다.

클러스터형 인덱스는 데이터를 정렬하는 기준을 정의하는 기능이므로 테이블에 한 개만 생성할 수 있다.

22. INDEX RANGE SCAN을 하지 못하는 경우

인덱스를 정상적으로 RANGE SCAN 할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다.

일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 한다. 인덱스를 RANGE SCAN 하지 못하는 대표적인 경우는 인덱스 조건 컬럼을 가공하는 경우다. 가공한 값을 기준으로 정렬하지 않았기 때문이다.

lIKE로 중간 값을 검색할 때도 RANGE SCAN 할 수 없다.
부정형 비교조건으로는 인덱스 RANGE 스캔할 수 없다.

23. INDEX RANGE SCAN

오라클은 구성 컬럼이 모두 NULL인 레코드는 인덱스에 저장하지 않는다.
따라서 단일 컬럼에 생성한 인덱스에 대한 IS NULL 조건은 INDEX RANGE SCAN이 불가능하다.

2개 이상 컬럼으로 구성된 결합 인덱스에 대해서는 IS NULL 조건에 대한 INDEX RANGE SCAN이 가능할 수 있다.
구성 컬럼 중 하나라도 NULL이 아닌 레코드는 인덱스에 저장하기 때문이다.

```sql
-- 사원 pk index : 사원번호
-- 사원_x1 : 집전화번호 + 사원명
-- 사원_x2 : 관리자번호 + 부서번호

-- 사원_x1 인덱스의 사원명이 NOT NULL 이므로 모든 테이블 레코드가 인덱스에 저장된다.
-- 사원_x1 로 INDEX RANGE SCAN 할 수 있다.
SELECT * FROM WHERE 집전화번호 IS NULL;
-- 사원_x1 로 INDEX RANGE SCAN 할 수 있다. 부서번호는 테이블에서 필터링한다.
SELECT * FROM WHERE 집전화번호 IS NULL AND 부서번호 = '2123';
-- 인덱스 구성컬럼이 모두 null을 허용할 경우 두 컬럼의 값이 모두 null인 경우에는
-- 인덱스에 저장하지 않는다. 따라서 관리자 is null 조건을 index range scan하면
-- 관리자 번호와 부서번호가 모두 null인경우 결과집합에서 누락된다.
SELECT * FROM WHERE 관리자번호 IS NULL;
-- 부서번호가 null이 아닌 경우는 인덱스에 저장한다. 따라서 index range scan으로
-- 정확한 결과집합을 얻을 수 있다.
SELECT * FROM WHERE 관리자번호 IS NULL AND 부서번호 = '2123';

```

24. INDEX RANGE SCAN

```SQL
-- 계좌번호 not null number
-- 계좌명 not null varchar
-- 지점코드 null varchar
-- 개설일시 null date
-- 고객번호 not null number

-- 계좌_pk : 계좌번호
-- 계좌_x01 : 지점코드 + 개설일시
-- 계좌_X02 : 개설일시 + 고객번호

-- 지점코드는 문자형인데 숫자를 조건값으로 대입하면 형변환이 발생해 INDEX 를 이용할 수 없게 된다.
-- TO_NUMBER(지점코드) = 100
select 계좌번호, 계좌명, 고객번호 from 계좌 where 지점코드 = 100;

-- 계좌번호 컬럼은 숫자형인데 문자를 조건값으로 대입했다.
-- 이때 일반적으로는 문자형을 숫자형으로 자동형변환하지만 비교연산자가 LIKE라면 숫자형을 문자형으로 변환한다. 즉 좌변의 형변환이 일어나 인덱스를 사용할 수 없게 된다
-- TO_CHAR(계좌번호) LIKE :ACNT_NO || '%'
select 계좌번호, 계좌명, 고객번호 from 계좌 where 계좌번호 like :acnt_no || '%';
-- 인덱스 X01은 지점코드, 개설일시가 모두 null 허용컬럼이기 때문에 두 컬럼값이 모두 null인 경우는 인덱스에 포함되지 않는다.
-- 지점코드가 NUll인 경우에 대해 스캔하면 개설일시가 Null인 컬럼이 누락되기 때문에 iNDEX RANGE SCAN 할 수 없다.
select 계좌번호, 계좌명, 고객번호 from 계좌 where 지점코드 is null;
-- 인덱스 x02의 구성컬럼인 고객번호는 null을 허용하지 않으므로 개설일시가 NUll인 경우라도 항상 인덱슬르 생성한다.
-- 아래의 경우 INDEX RANGE SCAN을 할 수 있다.
select 계좌번호, 계좌명, 고객번호 from 계좌 where 개설일시 is null;
-- 고객번호가 선두컬럼인 인덱스가 존재하지 않으므로 INDEX RANGE SCAN을 할 수 없다.
select 계좌번호, 계좌명, 고객번호 from 계좌 where 고객번호 = 123456;
```

25. INDEX RANGE SCAN

```sql
-- 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

-- 2 : 인덱스 선두컬럼이 조건절에 존재하지 않음
-- 3 : 인덱스 선두컬럼이 조건절에 존재하지 않을 수 있음
-- 4 : 부정형의 경우 기본적으로 INDEX RANGE SCAN이 불가 하다.
-- 하지만 NOT BETWEEN 조건인 경우, CONCATENATION이 일어나면 INDEX RANGE SCAN이 가능하다
-- 하지만 NO_EXPAND 사용시 CONCATENATION 하지않으므로 INDEX RANGE SCAN 하지 않는다.

```

26. INDEX RANGE SCAN

OR 조건은 기본적으로 INDEX RANGE SCAN을 위한 액세스 조건으로 사용할 수 없다.
수직적 탐색 스캔 시작점을 찾을 수 없기 때문이다.

다만 CONCATENATION(UNION ALL로 분기) 처리했을 때 각각 수직적 탐색을 위한 액세서 조건으로 사용할 인덱스가 있다면, INDEX RANGE SCAN이 가능하다.

```SQL
-- 고객_PK : 고객번호
-- 고객_X1 : 고객명 + 가입일자
-- 고객_X2: 휴대폰번호

-- 1 : 생년월일을 선두로 하는 인덱스가 존재하지 않으므로 옵티마이저는 concatenation 하지 않는다.

-- 2 : 가입일자를 선두로 하는 인덱스가 존재하지 않으므로 옵티마이저는 concatenation 하지 않는다.

-- 3 : UNION ALL 분기했을 때 한 쪽 브랜치는 고객번호 조건으로, 한쪽 브랜치는 휴대폰 번호 조건으로 index range scan 할 수 있다.
-- opt 변수에 입력한 값에 따라 둘 중 한쪽 브랜치만 실행된다.

-- 4 : 이런 형테의 OR 조거는 use_concat 힌트를 써도 UNION ALL 분기가 일어나지 않는다.
-- USE_CONCAT(OR_PREDICATES(1)) 힌트를 사용하면 union all 분기가 가능하긴 하지만 다른 옵션 조건 방식으로 변경하는 것이 좋다.

select *
from 고객
where :cust_no is null or 고객번호 = :cust_no

```

27. INDEX RANGE SCAN

```SQL
SELECT *
FROM 업체
WHERE 업체명 like '대한%';

SELECT *
FROM 업체
WHERE 월급여 >=  36000000 / 12;

SELECT *
FROM 주문
-- WHERE 주문수량 >= DECODE(NULL, FALSE, 100);
WHERE 주문수량 >= 100;

SELECT *
FROM 주문
WHERE 일시  >= TO_DATE(:DT, 'YYYYMMDD')
AND 일시 < TO_DATE(:DT, 'YYYYMMDD') + 1;

SELECT *
FROM 주문
WHERE 할인율 < CEIL(:dcrt);
```

28. INDEX RANGE SCAN

```SQL
SELECT
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 in (0,1,2,3,4,5)
AND 주문일자 between : dt1 and :dt2

SELECT
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 in (
    SELECT 주문상태코드
    FROM 주문상태
    WHERE 주문상태코드 <> 3
)
AND 주문일자 between : dt1 and :dt2

SELECT /*+no_merge(a) ordered use_nl(b)*/
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM (
    SELECT 주문상태코드
    FROM 주문상태
    WHERE 주문상태코드 <> 3
) a, 주문 b
WHERE b.주문상태코드 = a.주문상태코드
and 주문일자 between : dt1 and :dt2

SELECT /*+USE_CONCAT*/
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM 주문
WHERE (주문상태코드 < 3 or 주문상태코드 > 3)
AND 주문일자 between : dt1 and :dt2

SELECT
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 < 3
AND 주문일자 between : dt1 and :dt2
UNION ALL
SELECT
주문번호, 주문일시, 고객id, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 > 3
AND 주문일자 between : dt1 and :dt2

```

29. INDEX RANGE SCAN

```SQL
-- 월말계좌상태_pk : 계좌번호 + 계좌일렵번호 + 기준년월
-- 월말계좌상태_x1 : 기준년월 + 상태구분코드
UPDATE 월별계좌상태코드 SET 상태구분코드 = '07'
WHERE 상태구분코드 <> '01'
AND 기준년월 :BASE_DT
AND (계좌번호, 계좌일련번호) IN
(
    SELECT 계좌번호, 계좌일련번호
    FROM 계좌원장
    WHERE 개설이자 LIKE : STD_NM || '%'
)

```

30. INDEX RANGE SCAN

```SQL
-- 지수구분코드 VARCHAR2(1)
-- 지수업종코드 VARCHAR2(3)

-- 일별지수업종별거래_PK : 지수구분코드 + 지수업종코드 + 거래일자
-- 일별지수업종별거래_x1 : 거래일자

SELECT 거래일자
, SUM(DECODE(지수구분코드, '1', 지수종가 , 0)) KOSPI1200_IDX
, SUM(DECODE(지수구분코드, '1', 누적거래량 , 0)) KOSPI1200_IDX_TROVOL
, SUM(DECODE(지수구분코드, '2', 지수종가 , 0)) KOSDAQ_IDX
, SUM(DECODE(지수구분코드, '2', 지수종가 , 0)) KOSDAQ_IDX_TRIVOL
FROM 일별지수업종별거래 A
WHERE 거래일자 BETWEEN :startDd and :endDd
AND (지수구분코드, 지수업종코드) IN (('1','001'), ('2','003'))
GROUP BY 거래일자
```

31. INDEX TUNNING

```SQL
-- 주문_PK : 주문일자 + 주문번호

SELECT NVL(MAX(주문번호 + 1), 1)
FROM 주문
WHERE 주문일자 =: 주문일자

```

인덱스 컬럼인 주문 번호를 가공했으므로 FIRST ROW(MIN/MAX) 방식으로 작동하지 않았다.
아직 주문 데이터가 생성되지 않은 일자를 입력하면 MAX 함수가 NULL을 반환하므로 NV 처리가 반드시 필요하다.

```SQL
SELECT NVL(MAX(주문번호) + 1 , 1)
FROM 주문
WHERE 주문일자 =: 주문일자

-- SELECT
--  SORT (AGGREGATE)
--      FIRST ROW
--          INDEX (RANGE SCAN (MIN/MAX)) OF '주문_PK' (INDEX)
```

# 테이블 액세스 최소화

32. INDEX ROWID

인덱스 ROWID는 테이블 레코드와 직접 연결된 구조가 아니다.
데이터파일 상의 테이블 레코드를 찾아가기 위한 논리적인 주소 정보이다.

INDEX ROWID는 데이터파일번호 + 블록번호로 구성된 데이터 블록 주소를 가진 디스크 상의 블록 주소이다.

I/O성능을 위한 버퍼캐시를 활용한다. ROWID가 가리키는 블록을 버퍼캐시에서 먼저 찾아보고 찾지못하면 데이터파일에서 읽어 버퍼캐시에 적재한 후 사용한다.

캐시에서 블록을 읽을 때는 읽고자 하는 데이터 블록 주소를 해시 함수에 입력해서 반환되는 값으로 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.

캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로 버퍼 해더는 항상 같은 해시 체인에 연결된다.

반면, 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소 값을 버퍼 헤더가 가지고 있다.

버퍼 케시는 시스템 공유 메모리에 위치하므로 엑세스직렬화를 위해 LOCK 매커니즘이 작동한다.

버퍼캐시에서 블록을 읽을 때마다 LATCH와 BUFFER LOCK을 획득해야 한다.

동시 엑세스가 심할 때는 LATCH와 BUFFER LOCK에 대한 경합까지 발생하므로 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조이다.

33. 인덱스 클러스터링 팩터

인덱스를 재생성해도 클러스터링 팩터는 좋아지지 않는다.
클러스터링 팩터를 좋게하려면, 인덱스 컬럼 순으로 정렬되도록 테이블을 재생성해야 한다.

- 인덱스 클러스터링은 인덱스 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여 있는 정도를 의미한다.

- 통계정보의 일종으로서 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 미리 구해 놓은 값이다.

- 인덱스 성능은 클러스터링 팩터가 테이블 블록 수에 가까울수록 좋고, 테이블 레코드 수에 가까울 수록 나쁘다.

34. 인덱스 손익분기점

인덱스 클러스터링 팩터가 좋으면 테이블 액세스에서 발생하는 블록 I/O가 감소하므로 소요시간이 줄어든다.
따라서 그래프에서 테이블 액세스의 경사가 완만해지므로 인덱스 손익분기점이 올라간다.

MULTIBLOCK I/O의 단위를 늘릴수록 테이블 풀스캔의 디스크 I/O CALL 횟수가 줄고 테이블 전체 스캔 비용이 낮아져 소요시간이 줄어든다. 그래프 상의 인덱스 손익분기점은 내려간다.

데이터의 양이 많아지면 테이블 스캔 비용은 선형적으로 증가하지만, 인덱스를 이용한 테이블 엑세스의 비용은 기하급수적으로 증가한다.

첫 번째 이유는 데이터양이 늘수록 인덱스 CF가 나빠지기 때문이다. 레코드가 많을 수록 같은 값의 데이터가 한 테이블에 위치할 가능성이 낮다.

두 번째 이유는 버퍼캐시 히트율이 점점 낮아지기 때문이다. 버퍼캐시에 적제할 데이터가 많으면 블록을 버퍼캐시에서 찾을 가능성은 작아진다.

multiblock i/o 효과까지 고려하면, 데이터가 늘 때의 FULL SCAN 비용보다 테이블 렌덤 액세스의 비용 상승이 일반적으로 더 크다.

35. OLTP vs BATCH 프로그램

온라인 트랜잭션을 처리하는 프로그램에서는 인덱스와 NL 조인의 활용성이 높다.
배치 프로그램에서는 파티션과 병렬 처리의 효과성이 높다.
배치 프로그램에서는 FULL SCAN과 해시 조인의 활용성이 높다.

온라인 프로그램은 보통 소량의 데이터만 읽고 갱신하므로 인덱스를 효과적트로 활용하는 것이 중요하다. 조인도 대부분 NL 방식을 이용한다. 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면, 온라인 환경에서 대량의 데이터를 조회할 때도 빠른 응답속도를 낼 수 있다.

반면, 대량의 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다.
처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다. 대량 데이터를 빠르게 처리하려면, 인덱스와 NL 조인보다 FULL SCAN이 유리하다.

36. 인덱스 구성 변경

```sql
-- 로밍렌탈_N2 인덱스 : 서비스번호 + 사용여부

SELECT 렌탈관리번호, 고객명, 서비스관리번호, 서비스번호, 예약접수일시
, 방문국가코드, 로밍승인번호, 자동로밍여부
FROM 로밍렌탈
WHERE 서비스번호 LIKE '010%'
AND 사용여부 = 'Y'
AND 자동로밍여부 = 'N'

-- rows row source operation
-- 1909 TABLE ACCESS BY INDEX ROWID 로밍렌탈 (CR=266968 PR = 27830)
-- 266476 INDEX RANGE SCAN 로밍렌탈_N2 (CR=1011 PR=900 TIME=893462)
```

인덱스를 스캔하고서 얻은 건수는 266,476이다. 그 건수 만큼 테이블 랜덤 엑세스가 발생했는데 버퍼에서 읽은 1011 건을 제외하고 265,957 개의 블록을 디스크에서 읽었다.

문제는 테이블에 총 266,476 번 방문했지만 최종 결과집합이 1909뿐이라는데 있다.

자동로밍여부 조건에서 걸러진 것이다.
따라서 자동로밍여부를 인덱스에 추가하면 테이블 엑세스는 정확히 1909번만 발생하므로 총 블록 I/O는 인덱스 스캔 과정에 읽는 블록을 포함해 3000개 미만으로 줄어들 것이다.

인덱스 선두 컬럼을 변경하는 것은 다른 쿼리에 영향을 줄 수 있다.

현재 두 인덱스 컬럼의 순서만 바꾸는 것은 테이블랜덤액세스 수를 줄이는데 아무런 영향을 주지 못한다.

신규 인덱스를 추가하면 DML 성능이 나빠지게 된다.
따라서 성능을 크게 향상 시킬 수 있는 경우가 아니라면, 가급적으로 인덱스를 추가하지 않고 기본인덱스를 활용해 성능을 높이는 방안을 고려해야 한다.

37. 테이블 랜덤 엑세스 최소화

\- 테이블 랜덤 액세스가 많을 때는 가장 먼저 인덱스 컬럼 추가를 검토한다.
\- IOT 가 테이블 랜덤 엑세스를 없에는데 가장 효과적이다. 다만 테이블 구조 변경에 따른 부담과 IOT 자체가 갖는 부작용이 크기 때문에 운영 중 적용시 유의해야한다.
\- 인덱스를 재구성하면 인덱스 스캔 비효율을 줄이는 데 도움이 되지만 테이블 액세스에는 전혀 도움이 되지 않는다.
\- 인덱스 순으로 정렬되도록 테이블을 재생성하면, 클러스터링 팩터가 좋아져 테이블 랜덤 액세스를 줄이는데 상당한 도움을 준다.

38. 인덱스 컬럼추가

인덱스에 컬럼을 추가하면 인덱스 사이즈가 증가한다. 한 블록에 담을 수 있는 로우 수가 줄면 리프블록의 수가 증가하고, 인덱스의 높이도 증가하기 때문이다.
리프 블록 수가 증가하면 스캔 과정에서 블록 I/O가 증가하므로 스캔 효율이 나빠진다.

값이 같은 인덱스 레코드는 ROWID 순으로 정렬하므로 선두 컬럼의 NDV가 적다면 클러스터링 팩터는 비교적 좋다. 이때 뒤쪽에 컬럼을 추가하면 새로운 정렬 순서를 갖게 되므로 클러스터링 팩터가 나빠질 수 있다.
선두 컬럼의 NDV가 많은 상황에서 컬럼을 추가하더라도 클러스터링 팩터가 좋아지진 않는다.

39. 배치I/O

인덱스 ROWID 테이블 랜덤 액세스는 고비용의 구조이다.
인덱스를 이용해 대량 데잍를 조회하면, 디스크 I/O의 발생량이 증가하고 성능이 나빠진다.

BATCH I/O는 읽는 블록 마다 건건이 I/O CALL을 발생시키는 비효율을 줄이기 위해 고안한 기능이다. 인덱스를 이용해 테이블을 엑세스하다가 버퍼 캐시에서 찾지 못하면 바로 디스크 블록을 읽는대. 배치 I/O가 작동되면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽은 블록이 일정량 쌓이면 한번에 처리한다.

이 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다.

이 기능이 작동하더라도 실행 계획에서 SORT ORDER BY 오퍼레이션이 나타나지 않는 한 부분 범위처리는 가능하다.

40. 배치 I/O SORT ORDER BY

소트 연산을 생략할 수 있는 인덱스 구서이므로 배치 i/o가 작동하지 않는 한 변경 전 실행계획처럼 SORT ORDER BY는 자동으로 생략된다.

소트 연산을 생략할 수 있는 인덱스 구성이어도 배치 I/O가 작동할 수 있다면 SORT ORDER BY 오퍼레이션이 나타난다. 배치 I/O가 실제로 작동하면 데이터 정렬 순서를 보장할 수 없기 때문에 옵티마이져가 임의로 정렬 연산을 추가한 것이다.
이 경우 정렬순서는 보장이 되지만 부분범위 처리가 불가능해진다.

#

41. 인덱스 튜닝

세부적인 인덱스 튜닝 방법은 여러 가지가 있지만, 핵심요소는 크게 두 가지로 나뉜다. 첫 번째는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다.
즉, 인덱스 스캔 효율화 튜닝이다.

인덱스를 스캔한 양에 비해 얻은 결과 건수가 적으면 비효율이다.

두 번째 핵심요소는 테이블 액세스 횟수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 액세스 할때 랜덤 I/O 발생을 줄이는 것이다.

\- 1 . 10개의 레코드를 얻기 위해 8459 개의 블록을 스캔했으므로 매우 비효율이다. 한 블록에 1000개의 레코드가 저장돼 있다면, 10개 레코드를 얻기 위해 8459000 개의 레코드를 스캔한 셈이다.

\- 2 . 인덱스에서 얻은 결과 건수 만큼 테이블을 10만 번 액세스한 후에 100개만 남았으므로 매우 비효율적이다.

\- 3 . 테이블을 10번 액세스 한 후 모두 남았으므로 테이블 엑세스 과정에 비효율은 없다.
다만 3647 개의 블록을 읽었으므로 매우 비효율적이다.

\- 4. 인덱스에서 얻은 결과 건수 만큼 테이블을 10만 번 엑세스한 후에 모두 남았으므로 인덱스 스캔상의 비효율은 없다.

10만 번 엑세스하는 과정에서 34,094개의 블록만 읽었으므로 테이블 랜덤 엑세스 효율도 비교적 양호하다.

42. 인덱스 스캔 효율

테이블과 달리 인덱스에는 같은 값을 갖는 레코드들이 서로 군집해 있다.
'같은 값'을 찾을 때 = 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 = 로 조회하면 가장 효율적을 인덱스를 스캔할 수 있다.

따라서 모든 컬럼을 등차조건으로 사용할때 가장 좋다.

인덱스 선행 컬럼 중 어느 하나가 조건절에 없거나 = 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.

선행컬럼이 모두 = 조건인 상태에서 첫 번째로 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 군집해있지만, 그 이후 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.
따라서 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, lIKE 같은 범위 검색 조건이면 인덱스 스캔의 비효율이 생긴다.

43. 인덱스 스캔 효율

```sql
-- INDEX 구성 : 할인구분코드 + 상품코드 + 업체코드 + 상품유형코드
-- 최적인덱스 개선 : 업체코드 + 상품코드 + 할인구분코드
SELECT 주문일자, 상태코드, 정상가, 할인가, 할인구분코드
FROM 상품공급
WHERE 상품유형코드 = 'A'
AND 업체코드 = 'Z956'
AND 상품코드 = 'A0113509056'
AND 할인구분코드 BETWEEN 'A' AND 'C'
ORDER BY 주문일자 DESC
```

\- INDEX FAST FULL SCAN은 SELECT 절의 컬럼이 모두 인덱스에 존재해야 가능하다

\- 선행 범위 조건 컬럼의 NDV가 적고 후행 컬럼의 NDV가 많은 상황에서 INDEX SKIP SCAN은 매우 효과적이다.
INDEX SKIP SCAN을 이용하면 A와 C 사이에 속한 구간에서 나머지 조건에 해당하는 데이터만 골라서 읽을 수 있다.

\- 선행 컬럼의 NDV는 적고 후행 컬럼의 NDV는 많을 때 BETWEEN 조건의 인덱스 선두 컬럼을 IN 조건으로 변경하면 성능 향상에 큰 도움이 된다.

\- 조건절 나열 순서는 성능에 영향을 주지 않는다.

44. INDEX SCAN 효율화

```sql
-- 데이터 분포
-- 월별로 100만 개 레코드 저장
-- 총 10년치 데이터 보관 (1억 2000만 개의 데이터)
-- 판매구분코드가 'A'로 시작하는 데이터는 2%(240만 건)

-- 인덱스 구성
-- 월별고객판매집계_IDX2 : 판매월 + 판매구분코드

SELECT COUNT(*)
FROM 월별고객별판매집계
WHERE 판매구분코드 LIKE 'A%'
AND 판매월 BETWEEN '202001' AND '202012'

-- 1 SORT AGGREGATE (CR = 30000 PR = 8589 PW=0)
-- 240000 INDEX RANGE SCAN 월별고객별판매집계(CR= 30000 PR 8589)

```

1년간 저장되는 데이터는 1200만 건이다.
1200만 건을 인덱스에서 스캔하는 동안 30000 블록을 읽었다.

24만개

판매구분코드가 a로 시작하는 데이터는 2% 이므로 약 240만건 이다.
INDEX SKIP SCAN 방식을 사용한다면 30000 블록의 2%인 600 블록 + @ 로 줄일 수 있다.

BETWEEN 조건을 IN-LIST로 변경하면 수직적 탐색이 12번 일어난다.
만약 브랜치 레밸이 3이면 (3\*12 + 600) 개 정도의 블록을 읽게된다.

판매구분코드 + 판매월 순으로 인덱스를 변경해 사용하면,
판매월은 인덱스 필터 조건이 된다.

하지만 판매구분코드가 A로 시작하는 데이터는 2%에 불과하므로 I/O가 현저히 줄어들 것이다.
10년 치 데이터의 인덱스가 30만 블록이므로 그중 2%인 A로 시작하는 데이터의 인덱스는 6000블록만 읽을 것으로 예상할 수 있다.
이 테이블을 엑세스 하는 다른 쿼리는 없다는 가정이므로 인덱스 변경에 따른 영향도는 검토하지 않다ㅗ 된다.

```sql
WHERE 판매구분코드 IN (SELECT 판매구분코드 FROM 판매구분 WHERE 판매구분코드 LIKE 'A%')
```

인덱스 선두 컬럼인 판매월이 BETWEEN 조건인 상황에서 판매구분코드를 IN조건으로 처리하는 것은 성능향 상에 도움이 되지 않는다.
필터방식으로 처리하면 오히러 I/O가 증가하기 때문이다.

그나마 서브쿼리를 필터방식으로 처리할때의 캐싱기능으로 인해 크게 나빠지지 않을 수 있지만, 서브쿼리를 UNNSESTING 함으로써 판매구분을 먼저 읽고 월별고객별 판매집계와 NL 조인하는 방식으로 실행하면 성능이 크게 나빠진다.

판매구분코드가 A로 시작하는 데이터가 5개 일경우 판매월조건을 가진 테이블의 인덱스를 다섯번 스캔하므로 지금보다 5배 느려진다.ㄷ

45. INDEX SKIP SCAN

```SQL
-- 하루 승인요청 건수는 100만 건

-- query1
-- idx : 승인요청일시 + 승인요청자id
SELECT COUNT(*)
FROM 승인요청
WHERE 승인요청일시 >= trunc(sysdate - 6)
and 승인요청자id = :reqr_id ;

-- query2
-- idx : 승인요청일자 + 승인요청자id
SELECT COUNT(*)
FROM 승인요청
WHERE 승인요청일자 >= to_char(sysdate - 6, 'yyyymmdd')
and 승인요청자id = :reqr_id ;
```

쿼리2의 승인요청일자는 값 종류가 7개 이므로 INDEX SKIP SCAN이 큰 도움을 주지만 쿼리 1의 승인요청일시는 86,400초 \* 7 개의 값이 존재할 수 있으므로 INDEX SKIP SCAN이 큰 도움을 주지 않는다.

승인요청자 A가 3일 전에 승인을 요청했다고 가정할 때, A가 승인 요청할 가능성이 있는 시간은 3일전 86,400 초 모든 구간에 걸쳐있다.

따라서 쿼리 2로 조회하면 3일 전 구간에서는 100만 건 가량의 데이터를 모두 스캔한다

6일 전부터 오늘까지 모든 일자 구간을 같은 방식으로 스캔한다면, 결국 7일간 700만 건 가량의 데이터를 모두 스캔하게 된다.

46. IN LIST ITERATOR

```SQL
-- 주문             주문상세
-- # 고객번호        # 고객번호
-- # 주문일자        # 주문일자
-- # 주문순서        # 주문순번
-- * 결제쑤단코드     # 상품ID
--                 * 주문수량

-- 주문당 평균 20개 상품을 구매
-- 주문상세_PK : 고객번호 + 주문일자 + 주문순번 + 상품ID
-- 주문상세_X1 : 상품ID + 고객번호 + 주문일자
-- 주문상세_X2 : 상품ID + 주문일자 + 고객번호
-- 주문상세_X3 : 주문일자 + 상품ID + 고객번호

SELECT *
FROM 주문상세
WHERE 고객번호 = :cust_no
AND 주문일자 = :order_dt
AND 상품ID IN ('NM00037', 'PW73828', 'KR00050', 'ZQ74712')
```

상품 ID가 인덱스 선두로가면 상품IDI에 대한 조건을 IN-LIST-ITERATOR 방식으로 풀어야 INDEX RANGE SCAN이 가능하다.

이 방식이면 인덱스 수직탐색이 4번 발생하므로 인덱스 높이가 3이면 최대한 12개 블록을 읽어야 한다.

주문상세\_x3의 경우 상품id에 대한 IN 조건을 IN-LISI-ITETATOR 방식으로 풀면 최소 12개 블록을 읽어야 한다. in 조건을 필터 방식으로 풀면
인덱스에서 하루치 주문상세를 모두 스캔하면서 상품 ID와 고객번호를 필터링해야 하므로 많은 블록을 읽게된다.

주문상세\_PK는 고객번호와 주문일자 조건을 만족하는 데이터를 스캔하면서 상품 id 조건을 필터링 한다.
한 고객이 주문당 평균 20개 상품을 구매하므로 주문상세 레코드는 20개에 불과하다. 인덱스 리프 블록 하나에 모두 담길 수 있는양이므로 인덱스 높이가 3이면 3개 블록만 읽으면 된다.

47. IN 조건절

```sql
-- 고객별 가입상품은 평균 10개
SELECT *
FROM 고객별가입상품
WHERE 상품ID IN('', '', '', '')
AND 고객번호 = 1234
```

인덱스가 상품ID + 고객번호 일 때,

상품ID를 필터 방식으로 처리하면 전체 레코드 중 IN 조건절에 속하는 레코드에 대한 인덱스 풀 스캔 발생한다.

인덱스 높이가 3일때 상품ID를 IN LIST ITERATOR 방식으로 처리하면 최대 9개의 블록을 읽는다.

인덱스가 고객번호 + 상품ID 일 때,

상품ID를 필터 방식으로 처리하면 평균 10개의 레코드에 대한 스캔이 이루어진다.

인덱스 높이가 3일때 상품ID를 IN LIST ITERATOR 방식으로 처리하면 최대 9개의 블록을 읽는다.

48. 인덱스 튜닝

```sql
-- PK_거래 :  증서번호 + 이체사유발생일자 + 거래코드 + 순번

SELECT
NVL((A.기본이체금액 + A.정산이자) - (B.기본이체금액 + B.정산일자), 0)
FROM (
    SELECT NVL(SUM(기본이체금액), 0) 기본이체금액 ,
    NVL(SUM(정산이자),0) 정산이자
    FROM 거래
    WHERE 증서번호 = :증서번호
    AND 이체사유발생일자 <= :일자
    AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
    AND 투입인출구분코드 = 'G'
)A, (
    SELECT NVL(SUM(기본이체금액), 0) 기본이체금액 ,
    NVL(SUM(정산이자),0) 정산이자
    FROM 거래
    WHERE 증서번호 = :증서번호
    AND 이체사유발생일자 <= :일자
    AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
    AND 투입인출구분코드 = 'S'
)B

-- IDX_거래 : 증서번호  + 투입인출구분코드 + 이체사유발생일자 + 거래코드
SELECT (NVL(A.기본이체금액_G - A.기본이체금액_S))
FROM (
    SELECT
    DECODE(투입인출구분코드, 'G', SUM(기본이체금액), 0) '기본이체금액_G',
    DECODE(투입인출구분코드, 'S', SUM(기본이체금액), 0) '기본이체금액_S',
    FROM 거래
    WHERE 증서번호 = :증서번호
    AND 이체사유발생일자 <= :일자
    AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
    AND 투입인출구분코드 IN ('G', 'S')
    GROUP BY 투입인출구분코드
) A


```

기존 인덱스에서 두 인라인뷰 모두 인덱스 엑세스 조건은 증서번호와 이체사유발생일자다. 거래코드와 투입인출구분코드는 필터조건이다.
따라서 인덱스에서 동일 범위를 두 번 스캔한다.
테이블 레코드도 두 번씩 엑세스한다. 인덱스에 투입인출구분코드가 없기 때문이다.
두 번 액세스 한후 인라인뷰 A에서 투입인출구분코드가 G인 레코드를 선책하고,
인라인 뷰 B에서는 투입인출구분코드가 S인 데이터만 선택한다.

투입인출구분코드를 인덱스에 추가하면 인덱스에서 스캔하는 구간이 서로 달라진다. 인덱스가 투입인출구분코드를 포함하므로 테이블 레코드도 중복 액세스 하지 않는다.

SQL을 변경하면 인덱스와 테이블 모두 각각 한번씩만 엑세스한다.

거래코드 NOT IN 조건을 만족하는 데이터가 적다면, 거래코드를 인덱스 뒤쪽에 추가하는 것이 좋다. 테이블 랜덤 액세스를 줄이기 위함이다.
NOT IN 조건을 만족하는 데이터가 대다수라면 굳이 인덱스에 추가하지 않는 것이 좋다.

인덱스 사이즈를 줄이고, DML 성능을 좋게하기 위함이다.

```sql

SELECT (G_기본이체금액 + G.정산이자) - (S_기본이체금액 + S.정산이자)
FROM (
    SELECT NVL(SUM(CASE WHEN 투입인출구분코드 = 'G' then 기본이체금액 END), 0) G_기본이체금액
    , NVL(SUM(CASE WHEN 투입인출구분코드 = 'G' then 정산이자 END), 0) G_정산이자
    , NVL(SUM(CASE WHEN 투입인출구분코드 = 'S' then 기본이체금액 END), 0) S_기본이체금액
    , NVL(SUM(CASE WHEN 투입인출구분코드 = 'S' then 정산이자 END), 0) S_정산이자
    FROM 거래
    WHERE 증서번호 = :증서번호
    ZJFFAND 이체사유발생일자 <= :일자
    AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
    AND 투입인출구분코드 IN ('G', 'S')
)

```

49. like 조건절

```sql
SELECT * FROM 거래
WHERE 고객ID LIKE :CUST_ID || '%'
AND 거래일자 BETWEEN :DT1 AND :DT2
```

거래일자 조건을 만족하는 모든 거래를 조회하려할 때 :CUST_ID 변수에 null을 입력하면 조건절은 [고객 id like || '%'] 가 된다.
[NULL || '%'] 의 결과는 공집합이므로
이때 고객id 컬럼이 null 허용 컬럼이라면 고객 id 가 Null 값인 컬럼은 조회결과에 포함되지 못한다.

고객iD가 숫자형 컬럼이면 자동 형변환이 일어나므로 고객 iD는 무조건 필터 조건으로 사용된다.

고객 id가 가변 숫자형일 경우 123을 입력하면, 고객번호가 123으로 시작하는 모든 고객이 출력된다.

고객 iD가 인덱스 선두 컬럼이면 index range scan이 불가하고, 거리일자가 선두 컬럼이면 인덱스 스캔 비효율이 발생한다.

고객 ID가 문자형 컬럼일 때는 인덱스를 어떻게 구성하든 INDEX RANGE SCAN이 가능하다. 그래서 문제가 발생하는데, 고객ID가 선두 컬럼인 인덱스를 RANGE SCAN 하는 실행계획이 수립됐을 때, CUST_ID 변수에 값을 입력하지 않으면 모든 거레 데이터를 스캔한다.
대용량 테이블일때 인덱스 선두 컬럼에 대한 옵션조건을 lIKE로 처리하면 안 되는 이유이다.

거래일자가 인덱스 선두 컬럼이라면 BETWEEN 구간만큼만 스캔하겠지만,
이때는 CUST_ID 변수에 값을 입력한 경우에 스캔 비효율이 발생한다.
BETWEEN구간에속한 모든 거래 데이터를 스캔하면서 고객 ID 조건을 필터링하기 때문이다.

50. 동적컬럼

동적 조건절을 SQL로 표현할때 주의해야할 사항은 다음과 같다.

```sql

-- OR 방식을 사용하면 고객ID가 인덱스 선두 컬럼이더라도 index range scan을 할 수 없다.

SELECT * FROM TRANSAC
WHERE (#CUST_DT# IS NULL OR CUST_ID = #CUST_ID#)
AND TRAN_DATE BETWEEN #DT1# AND #DT2#

-- like 조건으로 구현된 옵션조건에 고객ID가 선두 컬럼인 인덱스를 RANGE SCAN 하는 실행계획이 수립되면, #CUST_ID 변수에 값을 입력하지 않았을때 거래일자를 액세스 조건으로 사용가는 것이 아닌 모든 고객번호(%)를 찾기위해 인덱스에서 모든 거래 데이터를 스캔한다.

SELECT * FROM TRANSAC
WHERE #CUST_DT# LIKE #CUST_ID# || '%'
AND TRAN_DATE BETWEEN #DT1# AND #DT2#


-- 고객번호 파라미터 값이 들어오지 않으면 고객ID = 고객ID가 되므로 항상 참이다.
-- 옵션 조건에 NVL이나 DECODE 함수를 사용하면 UNION ALL 형태로 쿼리변환이 작동하므로 고객ID 처럼 변별력이 좋은 컬럼에 효과적으로 사용할 수 있다.

SELECT * FROM TRANSAC
WHERE 고객ID = NLV(#CUST_ID#, 고객ID)
AND TRAN_DATE BETWEEN #DT1# AND #DT2#

SELECT * FROM TRANSAC
WHERE :CUST_ID IS NULL
AND TRAN_DATE BETWEEN #DT1# AND #DT2#
UNION ALL
SELECT * FROM TRANSAC
WHERE :CUST_ID IS NOT NULL
AND 고객ID = :CUST_ID
AND TRAN_DATE BETWEEN #DT1# AND #DT2

-- 옵션조건에 CASE문을 사용하면 UNION ALL 형태로 쿼리변환이 일어나지 않는다.
SELECT * FROM TRANSAC
WHERE 고객ID = (CASE WHEN #CUST_ID# IS NULL THEN 고객ID ELSE #CUST_ID# END)
AND TRAN_DATE BETWEEN #DT1# AND #DT2#

```

51. 인덱스 설계

조건절 나열 순서는 SQL 성능과 무관하다.
SQL 수행빈도는 인덱스를 생성하는 매우 중요한 판단 기준이다.
수행빈도가 낮더라도 업무상 중요한 SQL이라면 인덱스 생성을 고려할 수 있다.
데이터양이 많고 DML 발생빈도가 높은 테이블에는 인덱스 생성을 최소화해야한다.

52. 인덱스 수직적 탐색

인덱스가 성별 + 이름 순이라면 남자를 모두 찾고 홍길동을 찾는다.
반면 인덱스가 이름 + 성별이라면 홍길동을 먼저 찾고 남자를 찾는다.

엑셀 시트처럼 평면적인 정렬구조에서는 이름 + 성별 순서로 찾는게 도움이 된다.

하지만 B\*TREE 구조에서는 루트에서 브랜치를 거쳐 리프 블록까지 탐색하면서 남자 홍길동인 첫 번째 사원을 바로 찾아가는 다단계구조이다. 따라서 일량에는 차이가 없다.

53. 인덱스 컬럼 구성

```sql
-- sql1
select *
from 거래
where 상품코드 = :prd_cd
and 거래일자 between :trd_dt1 and :trd_dt2;

--sql2

select *
from 거래
where 상품코드 = :prd_cd
and 공급업체코드 LIKE :supl_co_cd || '%'
and 거래일자 between :trd_dt1 and :trd_dt2;

```

인덱스 구성 : 상품코드 + 거래일자 + 공급업체코드

INDEX RANGE SCAN이 가능하려면 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다.

따라서 결합 인덱스를 구성할 때 첫 번째 기준은, 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것이다.

두번째 기준은, 그렇게 선정한 컬럼 중 '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 두어야 한다는 것이다.

위의 두 SQL에서 공통적으로 사용된 조건절은 상품코드와 거래일자이다.
둘 중 =조건에 사용한 상품코드를 선두에 도구 BETWEEN 조건인 거래일자를 뒤쪽에 두어야 효율이 좋다.

만약 거래일자 BETWEEN 조건보다 공급업체코드 LIKE 조건의 선택도가 낮다면 SQL2를 위해 상품코드 + 공급업체코드 + 거래일자 로 인덱스를 구성할 수도 있지만 이 경우 SQL1의 효율이 매우 떨어진다.

두 SQL의 수행빈도가 동일하고 단 하나의 인덱스만 생성해야한다면, SQL2 에서 약간의 비효율이 있떠라도 상품코드 + 거래일자 + 공급업체코드로 구성하는 것이 좋다.

54. 인덱스 구성

```sql
SELECT 고객번호, 고객명, 등록일자, 전화번호, 고객등급
FROM 고객
WHERE 등록일자 BETWEEN :DT1 AND :DT2
AND 등록지점 = '마포'
AND 성별 = '남자'
```

테이블 랜덤 엑세스 횟수는 모두 같다. 따라서 인덱스 스캔 범위에 의해 성능이 결정된다.

스캔 효율을 위한 최적 인덱스는 성별 + 등록지점 + 등록일자 또는 등록지점 + 성별 + 등록일자 이다.

세 컬럼 모두 인덱스 엑세스 조건으로 사용되기 때문이다.

다만 등록지점보다 성별의 선택도가 높으므로 성별 + 등록지점 + 등록일자의 인덱스 스캔량이 더 많다.

55. 인덱스 컬럼 구성

```sql
-- 총 고객수 =  100만 명
-- 월 등록고객수 = 2만 명
-- 전화번호가 '02' 로 시작하는 고객수 = 50만 명

SELECT 고객번호, 고객명, 등록쇼핑몰, 등록일자, 전화번호, 고객등급
FROM 고객
WHERE 등록일자 >= ADD_MONTHS(SYSDATE, -1)
AND 등록쇼핑몰 iN ('ACT', 'CPN')
AND 전화번호 like '02%'
```

인덱스를 설계할 때 '=' 조건을 앞쪽에 두어야 하는데 현재 '=' 조건이 없다.

IN 조건은 IN-LIST ITERATOR 방식으로 풀면 = 조건으로 처리할 수 있다.

UNION ALL로 분기한 SQL에서 인덱스 선두 컬럼은 등록 쇼핑몰이다.
등록일자와 전화번호는 둘 다 범위검색 조건이므로 하나를 액세스 조건으로 사용하면 하나는 인덱스 필터조건이 된다.

따라서 둘 중 선택도가 낮은 컬럼이 선두 컬럼이 되야한다.

전화번호조건의 선택도는 50%이고, 등록일자조건의 선택도는 2%이다. 따라서 등록일자 컬럼이 전화번호 컬럼보다 인덱스 선두에 위치해야한다.

56. 인덱스 구성

```sql
-- 테이블은 파티션하지 않은 상태이며, 인덱스 스캔 효율이나 테이블 랜덤 액세스 발생량에 큰 차이가 없다면, 인덱스 개수를 최소화해야 한다.

-- sql1
SELECT *
FROM 거래
WHERE 고객번호 = :cust_no
AND 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) AND SYSDATE;

-- sql2

SELECT *
FROM 거래
WHERE 고객번호 = :cust_no
AND 상품번호 = :prd_no
AND 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) AND SYSDATE;

-- sql3

SELECT *
FROM 거래
AND 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) AND SYSDATE;
```

거래\_IDX1 = 고객번호 + 거래일자 + 상품번호
거래\_IDX2 = 거래일자

SQL2를 위해서 고객번호 + 상품번호 + 거래일자 가 최적이긴하지만 고객별 특정 거래일자에 해당하는 일반적으로 많지 않으므로 고객번호 + 거래일자 + 상품번호로 SQL1을 최적화 하는 것이 더 이득이다.

57. 인덱스 스캔

```sql
-- 조직별판매집계_PK : 판매조직코드 + 상품코드 + 판매월
-- 조직별판매집계_X1 : 판매조직코드 + 판매금액
-- 조직별판매집계_X2 : 판매월
-- 조직별판매집계_X3 : 판매월 + 판매조직코드
-- 조직별판매집계_X4 : 판매월 + 판매금액 + 판매조직코드
-- 조직별판매집계_X5 : 판매조직코드 + 판매월

SELECT SUM(판매금액)
FROM 조직별판매집계
WHERE 판매조직코드 = :ORG_CD
AND 판매월 BETWEEN '202101' AND '202106'

-- EXECUTION PLAN
-- 1    SORT AGGREGATE
-- 50       TABLE ACCESS BY INDEX ROWID 조직별판매집계
-- 100          INDEX RANGE SCAN
```

인덱스 스캔한 레코드와 실제 읽어온 레코드의 수가 다른 '테이블 랜덤 액세스 비효율'이 발생했다.

조건절에서 사용된 컬럼이 누락된 인덱스를 사용할 경우 발생한다.

PK 인덱스와 X3 인덱스, X5 인덱스는 조건절에 사용된 모든 컬럼을 포함하므로 스캔건수와 테이블 액세스 후 얻은 건수가 다를 수 없다.

x4 인덱스는 SQL 전체에 사용된 컬럼을 모두 포함하므로 TALBE ACCESS가 발생하지않는다.

X1 인덱스는 판매조직코드로 인덱스 스캔하고 테이블에서 판매월을 필터링 했을 것이고, X2 인덱스를 사용하면 테이블에서 판매조직코드를 필터링 했을 것이다.
따라서 INDEX SCAN의 수와 실제 조회된 레코드의 수가 다를 수 있다.

58. 인덱스 구성

```sql
SELECT *
FROM EMP
WHERE DEPTNO = :DEPTNO
AND SAL > :SAL
ORDER BY JOB, ENAME

-- EXECUTION PLAN
-- SELECT STATEMENT
--  TABLE ACCESS BY INDEX ROWID OF EMP
--      INDEX (RANGE SCAN) OF

-- EMP_PK : EMPNO
-- EMP_X1 : JOB + ENAME + DEPTNO
-- EMP_X2 : DEPTNO + JOB + ENAME
-- EMP_X3 :  DEPTNO + JOB + SAL + ENAME
-- EMP_X4 :  DEPTNO + SAL + JOB + ENAME
-- EMP_X5 : DEPTNO + JOB + ENAME + SAL
```

i/o를 최소화하면서 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.

\- = 연산자로 사용한 조건절 컬럼 선정
\- ORDER BY 절에 기술한 컬럼 추가
\- = 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

ORDER BY 에 사용된 컬럼이 인덱스에 존재할 경우 SORT ORDER BY 오퍼레이션이 생략된다.

X1 인덱스를 사용하면 인덱스 선두 컬럼이 조건절에 없기 때문에 INDEX FULL SCAN 실행계획이 나타났을 것이다.

X2 인덱스는 = 조건이 인덱스 선두 컬럼이고 ORDER BY 컬럼인 JOB, ENAME이 바로뒤에 위치하므로 INDEX RANGE SCAN이 가능하고 소트 생략도 가능하다

X3 인덱스는 JOB 과 ENAME 사이에 SAL이 위치하므로 소트 생략을 할 수 없다.

X4 인덱스는 = 조건인 DEPTNO 와 ORDER BY 컬럼인 JOB, ENAME 사이에 부등호 조건인 SAL 칼럼이 끼었으므로 소트 연산을 생략할 수 없다.

X5 인덱스는 = 조건이 인덱스 선두 컬럼이고 ORDER BY 컬럼인 JOB, ENAME이 바로뒤에 위치하므로 INDEX RANGE SCAN이 가능하고 소트 생략도 가능하다

59. 인덱스 구성

```SQL
SELECT  계약ID, 청약일자, 입력자iD, 계약상태코드, 보험시작일자, 보험종료일자
FROM 계약
WHERE 취급지점iD = :TRT_BRCH_ID
AND 청약일자 >= TRUNC(SYSDATE -3)
AND 입력일자 >= TRUNC(SYSDATE -7)
AND 계약상태코드 IN (:CTR_STAT_CD1, :CTR_STAT_CD2, :CTR_STAT_CD3)
ORDER BY 청약일자, 입력자ID
```

부분범위 처리 가능하다는 것은 소트 연산을 생략할 수 있음을 의미한다.

소트연산을 생략하면서도 i/o를 최소화하려면, 아래 공식에 따라 인덱스를 구성하면 된다.

\- = 연산자로 사용한 조건절 컬럼 선정
\- ORDER BY 절에 기술한 컬럼 추가
\- = 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

따라서 최적 인덱스는 [취급지점ID + 청약일자 + 입력자ID] 순으로 구성하면 된다.

입력일자와 계약상태 코드는 뒤쪽에 붙여도되고 안 붙여도 된다.

이들 조건을 만족하는 데이터가 적으면, 인덱스에 추가하는게 좋다. 테이블 랜덤 엑세스를 줄일 수 있기 때문이다.

이들 조건을 만족하는 데이터가 많으면, 굳이 인덱스에 추가하지 않아도 된다. 테이블에서 필터링할때와 성능 상 차이가 없기 때문이다.

IN 조건을 IN-LIST-ITERATOR 방식으로 풀면 정렬 순서가 깨진다.

60. 인덱스 구성

```SQL
-- PK_IDX : 거래일자 + 관리지점번호 + 일련번호
-- X1_IDX : 계좌번호 + 거래일자
-- X2_IDX : 결제일자 + 관리자지점번호
-- X3_IDX : 거래일자 + 종목코드
-- X4_IDX : 거래일자 + 계좌번호
```

PK 인덱스는 삭제할 수 없다.

X1 인덱스는 계좌번호 = 단일 조건으로 검색하거나 계좌번호 =, 거래일자 BETWEEN 조건으로 검색할 때 사용된다.

X2 인덱스는 결제일자 단일 조건으로 검색하거나 결제일자와 관리지점번호로 검색할 때 사용한다.

X3 인덱스는 거래일자 단일 조건으로 검색하거나 거래일자와 종목코든로 검색할 때 사용한다.

X4 인덱스는 거래일자 BETWEEN 단일 조건으로 검색하거나 거래일자 BETWEEN, 계좌번호 = 조건으로 검색할 때 사용된다.

전자는 PX 또는 X3 인덱스를 사용하면 되고, 후자는 X1 인덱스를 사용하는 것이 훨씬효율적이다.

61. 인덱스 구성

```sql
-- 고객연락처변경이력
-- 고객 10만명, 연락처구분 휴대전화, 집전화, 회사전화, 팩스, 이메일, 기타
-- # 고객ID number
-- # 연락처구분 Varchar2(10)
-- # 시작일자 VARCHAR2(8)
-- * 종료일자 VARCHAR2(8)
-- * 연락처번호 VARCHAR2(12)

SELECT *
FROM 고객연락처변경이력
WHERE 고객ID = 200
AND 연락처구분 IN('휴대전화', '집전화', '회사전화')
AND :BASE_DT BETWEEN 시작일자 AND 종료일자

```

문제 해결을 위한 두 가지 쟁점이 있다.

1. 선분이력 테이블에 대한 인덱스를 설계할 때 시작일자와 종료일자 중 어느 컬럼을 앞쪽에 둘것인가?

2. IN 조건인 연락처구분을 범위검색 조건(BETWEEN, 부등호) 앞에 둘 것인가, 뒤에 둘 것인가?

선분이력에서 특정 시점을 조회할 때는 아래와 같은 조건절을 사용한다.

```sql
WHERE :BASE_DT BETWEEN 시작일자 AND 종료일자

-- 위 조건을 분해하면 아래와 같다.

WHERE 시작일자 <= :BASE_DT
AND 종료일자 >= :BASE_DT
```

이 조건절로 최근 시점 이력을 조회할 때는 종료일자 조건을 이용하는 것이 유리하다. 종료일자 >= :BASE_DT 조건을 만족하는 데이터가 소량이기 때문이다.

반대로 오래된 과거 이력을 조회할 때는 시작일자 조건을 이용한느 것이 유리하다.

이력 테이블은 일반적으로 최근 데이터를 조회하므로 일반적으로 종료일자 조건을 이용하는 것이 유리하다.

과거 데이터 조회 할 때를 고려해 시작일자도 인덱스에 포함하는 것이 좋다.

2 번 쟁점을 설명하기 위해 아래 테이블을 생성하고 테스트해보자.

각 고객의 연락처구분별로 평군 5번씩 변경이력이 발생한다고 가정한다.

```sql
create table 고객연락처변경이력
nologging
as
select
고객ID,
연락처구분,
시작일자,
종료일자,
(
case when 연락처구분 = '휴대전화' then '010' else lpad(round(dbms_random.value(1,999)), 3, '0') end)
|| lpad(round(dbms_random.value(1,9999)), 4, '0')
|| lpad(round(dbms_random.value(1,9999)), 4, '0') 연락처번호
from (select rownum as 고객ID FROM XMLTABLE('1 to 100000'))
,(
    select (case rownum
    when 1 then '휴대전화'
    when 2 then '집전화'
    when 3 then '회사전화'
    when 4 then '팩스'
    when 5 then '이메일'
    when 6 then '기타' end
)
from xmltable('1 to 6')
),
(select to_char(add_months(sysdate, -rownum*12), 'yyyymmdd') 시작일자
, (case when rownum = 1 then '99991231' else to_char(add_months(sysdate, -(rownum*12)+12) - 1, 'yyyymmdd') end) 종료일자
from xmltable('1 to 5') -- 연락처구분별로 5번씩 변경이력 발생
)
order by dbms_random.value

create index 고객연락처변경이력_x01
on 고객연락처변경이력 (고객ID, 종료일자, 시작일자, 연락처구분) nologging;
create index 고객연락처변경이력_x02
on 고객연락처변경이력 (고객ID, 연락처구분, 종료일자, 시작일자) nologging;
-- 또는
create index 고객연락처변경이력_x02
on 고객연락처변경이력 (연락처구분, 고객ID, 종료일자, 시작일자) nologging;

select index_name, blevel
from user_indexes
where table_name = '고객연락처변경이력'

-- X01 = 2 , X02 = 2
-- 브랜치가 2 레벨이므로 리프 블록을 포함해 인덱스는 총 3 레벨이다.

-- 아래 SQL로 인덱스 스캔 단계에서 블록 i/o 발생량을 측정해 보자.

set serveroutput off;

variable base_dt varchr2(8);

exec :base_dt := to_char(sysdate, 'yyyymmdd');

select /*+gather_plan_statistics index(c(고객ID,종료일자))*/
count(*)
from 고객연락처변경이력 C
where 고객ID = 200
and 연락처구분 in ('휴대전화', '집전화', '회사전화')
and :base_dt between 시작일자 and 종료일자;

select /*+gather_plan_statistics index(c(고객ID,연락처구분))*/
count(*)
from 고객연락처변경이력 C
where 고객ID = 200
and 연락처구분 in ('휴대전화', '집전화', '회사전화')
and :base_dt between 시작일자 and 종료일자;
```

in-list iterator 방식을 사용한 아래 쿼리가 5개많은 블록 I/O가 발생했다.

인덱스 수직탐색을 3번 반복하기 때문이다.

리프블록 하나에 300개 레코드를 저장한다고 가정하면, 인덱스 리프 블록에서 1500개 정도의 레코드를 더 스캔한 것이다.

이 테스트를 통해 고객iD = 종료일자 >= 조건을 만족하는 데이터가 1500개를 넘지 않는다면 연락처 구분을 필터로 처리하는게 더 유리하다는 것을 알 수 있다.

고객iD = 종료일자 >= 조건이 1500 개를 넘으려면 각 고객이 각각의 연락처구분 별로 250번 이상 변경해야 한다.

이는 현실적으로 불가능한 수치이므로 연락처 구분을 필드 조건으로 사용하는 것이 유리하다.

in 조건을 인덱스 앞에 위치하는것이 도움이 되려면 후행 인덱스에 해당하는 레코드가 in 조건에 의한 수직적 탐색 블록 I/O를 상쇄할 정도로 많아야 한다.

따라서 iN 조건을 필터로 처리하는게 유리한 경우가 더 많다는 사실을 기억해야 한다.
