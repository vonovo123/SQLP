### Dynamic SQL 사용에 관한 기본 원칙

Static Sql을 지원하는 PowerBuilder, PL/SQL, Pro\*c, SQLJ 같은 개발환경이라면 Static SQL로 작성하는 것을 원칙으로 한다.

Static SQL은 PreComplie 과정을 거치므로 런타임시 안정적인 프로그램 Bulid가 가능하다는 장점이 있다.

그리고 Dynamic SQL을 사용하면 애플리케이션 커서 캐싱이 작동하지 않는 경우가 있는데, 이 기능이 필요한 상황에서 Dynamic SQL을 사용하면 성능이 나빠지기 때문이다.

아래의 경우에는 Dynamic SQL을 사용해도 무방하다.

- PreCompile 과정에서 컴파일 에러가 나는 구문(스칼라 서브쿼리, 분석함수, ANSI join 등)

- 상황과 조건에 따라 생성될 수 있는 SQL 최대 개수가 많아 Static SQL로 일일히 나눠 작성하려면 생산성이 저하되고 유지보수 비용이 커질 때

위 경우에 해당하여 Dynamic SQL을 사용하더라도 조건절에는 바인드 변수를 사용하는 것을 원칙으로 한다.

특히, 사용빈도가 높고 조건절 컬럼의 값 종류가 매우 많을 때는 반드시 이를 준수해야한다.

바인드 변수 사용원칙을 준수하되 다음과 같은 경우는 예외적으로 인정한다.

1. 배치 프로그램이나 DW, OLAP 등 정보계 시스템에서 사용되는 LONG RUNNING QUERY

이든 쿼리는 파싱 소요시간이 쿼리 총 소요시간에서 차지하는 비중이 매우 넓고, 수행빈도가 낮아 하드파싱에 의한 라이브러리 캐시 부하를 유발할 가능성이 낮다.

2. OLTP성 애플리케이션이더라도 사용빈도가 매우 낮아 하드파싱에 의한 라이브러리 캐시 부하를 유발할 가능성이 없을때.

3. 조건절 컬럼의 값 종류가 소수일 때, 특히 값 분포가 균일하지 않아 옵티마이저가 칼럼 히스토그램 정보를 활용하도록 유도하고자할때

Static SQL을 지원하지 않는 개발 환경이라면 모든 SQLdl Dynamic 쿼리이지만 런타임시 SQL이 동적으로 바뀌도록 개발하는 것 만큼은 삼가야한다.

그런 환경에서는 Static과 Dynamic SQL을 편의상 아래와 같이 재정의하고, 위의 원칙을 동일하게 적용해야한다.

\- Static SQL : SQL Repository 에 완성된 형태로 저장한 SQL
\- Dynamic SQL : SQL Repository 에 불완전한 형태로 지정한 후 런타임 시 상황과 조건에 따라 동적으로 생성되도록 작성한 SQL

## 선택적 검색조건

런타임 시 조건절 변수 값의 값에 따라 동적으로 SQL이 바뀌는 패턴은 검색조건이 다양해 사용자 선택에 따라 조건절이 동적으로 바뀌는 경우에 주로 사용된다.

```sql
select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where 거래일자 between :시작일자 and :종료일자
%option
```

사용자의 선택이나 입력 값에 따라 %option 부분에 조건절을 동적으로 붙여나간다.

```sql
%option = "and 종목코드 = 'KR123456' and 투자자유형코드 = '1000'"
```

이와 같은 동적쿼리를 줄이기 위해서 주로 NVL을 사용한다.

```sql
select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where 거래일자 between :시작일자 and :종료일자
and 종목코드 = nvl(:종목코드, 종목코드)
and 투자자유형코드 = nvl(:투자자유형코드, 투자자유형코드)
and 주문매체구분코드 = nvl(:주문매체구분코드, 주문매체구분코드)

```

이렇게 하면 사용자가 어떤 값을 입력하더라도 단 한 개의 실행계획을 공유하면서 반복 재사용하게 되므로 라이브러리 캐시 효율 측면에서는 최상의 선택이다.

하지만 인덱스를 이용한 액세스가 효과적인 상황에서는 낭패를 보게 된다.

인덱스를 전혀 사용 못하거나 비효율적으로 사용하기 때문이다.

라이브러리 캐시 효율과 I/o 효율을 모두 고려하면서 SQL을 개발하려면 SQL을 모두 분리해서 개발하는 방법 밖에 없다.

1. 거래일자 Between
2. 거래일자 between, 종목코드 =
3. 거래일자 between, 종목코드 = , 투자자유형코드 =
4. 거래일자 between, 종목코드 = , 투자자유형코드 =, 주문매체구분코드 =
5. 거래일자 between, 종목코드 = , 주문매체구분코드 =
6. 거래일자 between, 투자자유형코드 =
7. 거래일자 between, 투자자유형코드 = , 주문매체구분코드 =
8. 거래일자 between, 주문매체구분코드 =

인덱스 원리를 이해하고 있다면 위 요건을 만족하려고 인덱스를 8개나 만들 필요는 없다.

변별역이 좋지 않은 컬럼은 인덱스 액세스 효율에 도움이 되지 않으므로 , 인덱스 구성을 고려해 변별력이 좋은 컬럼을 중심으로 2~3개 만 만들면 된다.

애플리캐이션에서 if문을 이용해 분기하거나 아래처럼 union all을 사용하는 방법이 있따.

```sql
-- index
-- index01 : 종목코드 + 거래일자
-- index02 : 투자자유형코드 + 거래일자 + 주문매체코드
-- index03 : 거래일자 + 주문매체구분코드

select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where :종목거래 is not null
and 종목코드 = :종목코드
and 거래일자  between :시작일자 and :종료일자
and 투자자유형코드 = nvl(:투자자유형코드, 투자자유형코드)
and 주문매체구분코드 = nvl(:주문매체구분코드, 주문매체구분코드)
union all
select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where :종목거래 is null and 투자자유형코드 is not null
and 투자자유형코드 = :투자자유형코드
and 거래일자  between :시작일자 and :종료일자
and 주문매체구분코드 = nvl(:주문매체구분코드, 주문매체구분코드)
union all
select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where :종목거래 is null and 투자자유형코드 is null
and 주문매체구분코드 = nvl(:주문매체구분코드, 주문매체구분코드)
and 거래일자  between :시작일자 and :종료일자

```

하지만 개발 기간 내내 SQL마다 이런 식으로 최적의 인덱스 구성전략을 고민하면서 개발하는 게쉬운일은 아니다.

위와 같이 Union all로 분기하는 기법은, 일반적인 SQL 작성 표준보다는 튜닝차원에서 접근하고 필요에 따라 적절히 활용하는 것이 바람직하다.

### 선택적 검색 조건에 대한 현실적인 대안

Static SQL 사용을 원칙으로 하되 사용자 입력 조건에 따라 생성될 수 있는 SQL 최대 개수가 너무 많을 때는 Dynamic SQL 사용을 허용해야한다.

조건절에 따른 SQL 개수가 많더라도 그 중 일부만 주로 사용되므로 실질적인 하드파싱 부하는 거의 없다. 다만 라이브버리 캐시 효율화의 핵심인 바인드 변수 사용원칙은 준수해야한다.

```sql
--pl/sql
SQLStmt = 'select 거래일자, 종목코드, 투자자유형코드, 주문매체코드, 체결건수, 체결수량, 거래대금
from 일별종목거래
where 거래일자 between :1 and :2'

IF :종목코드 IS NULL THEN
  SQLStmt := SQLStmt || 'AND :3 is null';
Else
  SQLStmt := SQLStmt || 'AND 종목코드 = :3';
END if;

IF :투자자유형코드 IS NULL THEN
  SQLStmt := SQLStmt || 'AND :4 is null';
Else
  SQLStmt := SQLStmt || 'AND 투자자유형코드 = :4';
END if;

EXECUTE IMMEDIATE SQLS슷
  INTO :A, :B, :C, :D, :E, :F, :G
  USING :시작일자, :종료일자, :종목코드 , :투자자유형코드
```

이처럼 SQL을 Dynamic 하게 구성하면, 인덱스를 설계할 때 다소 불편하다는 단점이 있다.

SQL Repository 에서 SQL을 수집해 테이블별 액세스 유형을 분석하면서 인덱스를 설계해야하는데, 조건절이 프로그램 수행 도중 동적으로 바뀌기 때문이다.

그리고 옵티마이저 힌트를 사용해 튜닝하기도 곤란하다.

개발이 어느정도 진행된 시점에 성능 요건을 만족하기 어려운 대상을 추출해 튜닝하고, 그때 튜닝 관점에서 필요한 조치들을 취하면 된다.

인덱스는 액세스경로를 기준으로 설계하면 된다.

조건절이 위와 같이 동적으로 바뀌면 힌트를 함부로 사용할 수 없다.

그때는 할 수 없이 Static SQL을 사용해야 하며, 인덱스 구성과 컬럼분석, 자주 사용하는 액세스 유형을 고려해 SQL을 통합하고 힌트를 기술할 수 있는 형태로 재작성해야한다.

### 선택적 검색 조건에 사용할 수 있는 기법 성능비교

A. OR 조건을 사용하는경우

```sql
select * from 일별종목거래
where (:isu_cd is null or isu_cd = :isu_cd)
```

항상 TAble Full Scan으로 처리되므로 인덱스 활용이 필요할 때는 이 방식으로 사용해선 안된다.

B. Like 연산자를 사용하는 경우

```sql
select * from 일별종목거래
where isu_cd like :isu_cd || '%'
```

인덱스 사용이 가능하지만 사용자가 :isu_cd를 입력하지 않았을 때 Table Full Scan이 유리함에도 인덱스를 사용하게 되므로 성능이 저하된다.
또한 null 허용컬럼일 때 결과집합이 달라질 수 있으므로 반드시 not null 컬럼일때만 사용해야한다.

C. NVL 함수를 사용하는 경우

```sql
select * from 일별종목거래
where isu_cd = nvl(:isu_cd, isu_cd )
```

D. DECODE 함수를 사용하는 경우

```sql
select * from 일별종목거래
where isu_cd = decode(:isu_cd, null, isu_cd,  :isu_cd )
```

C와 D 방식은 :isu_cd 입력 여부에 따라 Full Table Scan 과 Index Range Scan이 자동분기된다.

해당 칼럼이 not null 이어야하며 null 허용 컬럼일 경우 결과집합이 달라질 수 있다.

사용자가 :iuusu_cd 값을 입력하지 않으면 조건절이 isu_cd = isu_cd가 되는데 값이 Null 일때 오라클은 false를 리턴하므로

실제 값이 null인 경우가 결과집합에서 제외될 수 있다.

E. UNION ALL을 사용하는 경우

```sql
select * from 일별종목거래
where :isu_cd  is null
union all
select * from 일별종목거래
where :isu_cd  is not null
and isu_cd = :isu_cd

```

5가지 방식에 대한 선택 기준을 정리하면 아래와 같다.

1. not null 컬럼일 때는 nvl, decode를 사용하는 것이 편하다.
2. null 허용 칼럼인 경우, 인덱스 액세스 조건으로 의미있는 컬럼이라면 union all을 사용해 명시적을 ㅗ분기한다.
3. 인덱스 액세스 조건으로 ㅊ참여하지 않는경우, 적 인덱스 필터 혹은 테이블 필터 조건으로만 사용되는 컬럼이라면 (c: is null or col = :c) 또는
   (c like :c || '%') 중 어떤 방식을 사용해도 무방하다.
