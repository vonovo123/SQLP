바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고 실행시점에는 그것을 그대로 가져와 값을 다르게 바인딩하면서 반복 재사용한다.

여기서, 변수를 바인딩하는 시점이 최적화 시점보다 나중이라는 사실이 중요하다.

즉, SQL을 최적화하는 시점에 조건절 컬럼의 데이터 분포도를 활용하지 못한다.

정확히 말하면 칼럼 히스토그램 정보를 사용하지 못하는 것이다.

따라서 바인드 변수를 사용할 때 옵티마이저는 평균 분포를 가정한 실행계획을 생성한다.

컬럼 분포가 균일할 때는 문제가 없지만, 그렇지 않을 때는 실행시점에 바인딩되는 값에 따라 최적이 아닌 실행계획이 수립될 수 있다.

특히, 등치 조건이 아닌 부등호나 BETWEEN 같은 범위 기반 검색조건일 때는 고정된 규칙을 사용하므로 더 부정확한 예측에 기반한 실행계획이 수립된다.

비용 계산에 기초가 되는 카더널리티는 전체 레코드 수에 선택도를 곱한 값이다.

선택도가 정확하지 않다면 비용또한 정확하지 않다.

```sql
create table t
as
select rownum no from dual connect by level <= 1000;

analyze table t compute statistics for table for all columns;


explain plab for select * from t where <= :no;

select * from table(dbms_xplan.display(null,null,'basic rows'));

explan plans for select * from t where no between :no1 and :no2;

select * from table(dbms_xplan.display(null,null,'basic rows'));
```

바인드 변수를 사용했을 때 옵티마이저는 각각 50개와 3개의 카디널리티를 예상한다. 사용자가 실제 입력한 값에 따라 전혀 결과가 달라질 수 있지만 옵티마이저로서는 어쩔 수 없는 선택을 한 것이다.

상수 조건식을 사용하면 거의 정확ㅎ나 카디널리티를 계산해 낸다.

```sql
explain plan for select * from t where no <= 100;

select * from table(dbms_xplan.display*null,null,'basic rows');

explain plan for select * from t where between 500 and 600;

select * from table(dbms_xplan.display*null,null,'basic rows');
```

바인드변수를 사용할때는 정확한 컬럼 히스토그램에 근거하지 않고 카디널리티를 구하는 정해진 산식예 기초해 비용을 계산하므로 최적이 아닌 실행계획일 가능성이 높다.

바인드 변수를 활용하면 컬럼 히스토리를 제대로 활용하지 못할 뿐아니라. 파티션 테이블을 쿼리할 때 파티션 레밸통계보다 다소 부정확한 테이블 레밸 통계를 이용함으로써 악성 실행계획을 수립한다.

### 바인드 변수 PEEKING

바인드 변수의 부작용을 극복하기위해 바인드 변수 Peeking 기능이 도입됐따.

SQL이 첫 번째 수행되면서 하드파싱될 때 함께 딸려 온 바인드 변수 값을 참조하여 그 값에 대한 컬럼 분포를 이용해 실행계획을 결정하는 것이다.

특졍 값에 의해 향후 실행계획이 확정되어버리는 부작용이 있다.

또한, 바인드 변수 Peeking 기능이 활성화됬어도 Explain Plan 명령을 통해 확인하는 사전 실행계획은 이 기능이 적용되지 않은 실행계획이다.

실제 실행은 다르게 동작할 수도 있다.

이런 이슈로 인해 대부분 운영 시스템에서는 바인드 변수 Peeking 기능이 비활성돼있다.

### 적응적 커서 공유

입력된 바인드 변수 값의 분포에 따라 다슨 실행계획을 사용한다.

쿼리가 처음 수행되는 시점에 선택도가 높은 레코드가 입력되면 테이블을 Full scan 하는 실행계획을 수립하고 1번 커서로 삼는다.

선택도가 낮은 값이 입력되면 컬럼 히스토리를 확인 후 인덱스를 이용하는 새로운 실행계획을 만든다. 캐시에는 Child 커거사 동시에 캐싱돼 있다.

이를 2번 커서로 삼는다.

1번 커서만큼 선택도가 높은 값이 입력되면 히스토그램을 확인한 후 1번 커서를 사용한다.

선택토가 낮은 값이 입력되면 히스토그램을 확인한 후 2번 커서를 사용한다.

적응적 커서 공유와 관련한 수행 통계를 관찰할 수 있도록 세 가지 뷰를 재공합니다.

\- v$sql_cs_statistics
\- v$sql_cs_histogram
\- v$sql_cs_selectivity

이 기능이 작동하려면 기본적으로 조건절 칼럼에 히스토그램이 생성돼 있어야 한다.

그 상태에서, 옵티마이저가 방니드 변수 값에 따라 실행계획을 달리 가져갈 필요가 있다고 판단되는 SQL 커서에 대해 이 기능이 활성화 된다.

그런 커서를 Bind Sensitive 커서 라고 부르며, v$SQL을 조회해 보면 is_bind_sensitive 칼럼이 Y로 표시돼 있다.

Bind Sensitive 모드에서는 아직 바인드 값에 따라 실행계획이 바뀌지 않으며, Bind Aware 모드로의 전환이 필요하다.

오라클은 Bind Sensitive 커서에 대해 내부적으로 별도의 히스토그램과 수행 통계를 관ㄹ히마ㅕ, 특정 값으로 실행했을 때 이전에 비해 많은 일량을 처리한 것으로 판단되는 순가

해당 커서를 Bind Aware 모드로 전환한다.

이때부터 기존 커서는 사용이 중지되고 새로운 커서가 생성된다.

커서가 바인드 값 별로 따로 만들어지는 것은 아니며, 선택도가 비슷한 것 끼리는 같은 커서를 공유한다.

실제 동작 메커니즘은 다음과 같다.

1번 커서가 만들어진 상태에서 선택도가 낮은 값으로 실행되면 처음에는 1번 커서의 실행계획을 그대로 사용해본다.

수행 결과 이전보다 많은 일량을 처리한것으로 판단되면 Bind Aware 모드로 전환한다.

그 상테에서 다시 선택도가 낮은 값이 입력되면 이를 위한 새로운 커서가 만들어진다.

만약 낮은 값을 입력하지 않고 높은값을 입력해도 기존 것을 버리고 새로운 실행계획을 만든다. 이미 Bind Aware 모드로 전환했기 때문이다.

기존에 사용되던 커서는 v$sql 에서 is_shareable 컬럼이 N으로 설정되어, 이후 라이브러리 캐시에 공간이 필요할 때 가장 먼저 밀려난다.

이 기능을 사용하려면 조건절칼럼에 히스토그램이 생성돼 있어야 한다. 데이터 딕셔너리에 저장되는 히스토그램에는 여러 버킷이 존재하고, 옵티마이저가 실행계획을 수립할 때

이 정보를 이용해 입력 값에 대한 선택도를 산정한다.

각 Bind Aware 커서는 히스토그램상 자신이 처리해야 할 버킷이 내부적으로 결정된다.

따라서 이 모드에서 SQL을 실행하면, 현재 입력된 파인드 값을 처리할 커서가 캐싱돼 있는지 먼저 찾는다. 만약 적당한 커서를 찾지 못하면 하드파싱을 통해

새로운 실행계획을 생성한다.

이때 새로 생성된 커서의 실행계획이 기존에 캐싱된 커서의 실행계획과 결과적으로 같다면, 그 중 하나만 사용하고 나머지는 버린다.

이를 통해 커서가 불필요하게 많아지는 것을 방지한다.

## 입력 값에 따라 SQL 분리

바인드 변수가 시스템 성능과 확정성을 위해 중요하므로 인덱스 액세서 경로로서 중요하고 조건절 컬럼의 데이터 분포가 균일하지 않은 상황에서

바인드 변수 사용에 따른 부작용을 ㅣ하려면 바인딩 되는 값에 따라 실행계획을 분리하는 방안을 고려해 볼 수 있다.

```sql
select /*+Full(a)*/ *
from 아파트매물
where :CITY IN ('서울시', '경기도')
and 도시 = :CITY
union all
select /*+Full(a)*/ *
from 아파트매물
where :CITY NOT IN ('서울시', '경기도')
and 도시 = :CITY
```

주의할 것은 OLTP 시스템에서 union all을 이용해 SQL을 지나치게 길게 작성하면 라이브러리 캐시 효율이 저하된다.

union all을 사용해 결합한 SQl의 수 만큼 최적화를 진행해야 한다.

그리고 그만큼 Shared Pool에서 많은 공간을 차지하게된다.

몇 개의 공간만 주로 사용된다면 나머지는 불필요한 공간을 낭비하는 것이다.

매번 수행할 때마다 긴 텍스르를 파싱하면서 Syntax를 체크하고 파싱트리를 만들어 Semantic 체크하는 과정을 반복하는 것은 CPU 자원을 과도하게 낭비하게 된다.

실행계획 분기 조건에 의해 제외되는 부분이라도 I/O를 일으키지 않을 뿐 실제 실행은 발생한다.

```sql
select /*+full(emp)*/ *
from emp
where :deptno = '30'
and deptno = :deptno
union all
select /*+index(emp emp_deptno_idx)*/
from emp
where :deptno <> '30'
and deptno = :deptno

```

한 sql에서 리턴된 결과 집합이 0이고 블록 i/o 또한 발생하지 않더라도 그 sql 을 처리하는 Time 항목은 0보다 크다.

배치 프로그램이나 DSS 시스템이라면 상관없지만 OLTP 시스템이라면 union all을 이용하는 것이 보다 클라이언트 단에서 SQL을 분기하는 것이 바람직하다.

```sql
IF:CITY IN ('서울시', '경기도') THEN
 select /*+full(a)*/
 from 아파트매물 a
 where 도시 = :CITY
ELSE
  select /*+INDEX(a IDX01)*/
 from 아파트매물 a
 where 도시 = :CITY
END IF
```

### 예외적으로 Literal 상수값 사용

입력 값에 따라 SQL을 분리하는 방법은 모든 경우에 적용될 수 있는 해법은 아니다.

값의 종류가 많을 수도 있고, 값의 종류가 늘거나 줄 때 소스를 일일이 변경해줘야 하는 관리상의 부담도 있다.

조건절 컬럼의 값 종류가 소수일 때는 바인드 변수보다 오히려 Literal 상수를 사용하는게 나은 선택일 수도 있다.

입력값 종류가 몇 개에 불과하다면 하드파싱 부하가 미미할테고, Literal 상수를 사용함으로써 옵티마이저가 더 나은 선택을 할 가능성이 커진다.

부등호나 Between 같은 범위 검색조건일 때도 Literal 상수를 사용하는 것이 최적화 측면에서 유리하다.

특히 배치 프로그램이나 DW, OLAP 등 정보계 시스템에서는 일자 조건이 빠지지 않고, 거의 대부분 범위 검색조건이므로 Literal 상수 값을 사용할 때 더 나은 실행계획이 수립된다.

배치 프로그램이나 정보계 시스템에서 수행되는 SQL은 대부분 Long Running 쿼리이므로 파싱 소요시간이 쿼리 총 소요시간에서 차지흔 비중이 매우 낮고,

사용빈도도 낮아 하드파싱에 의한 라이브러리 캐시 부하를 크게 염려할 필요가 없다.

OLTP성 애플리케이션이더라도 사용빈도가 아주 낮아 하드파싱에 의한 라이브러리 캐시 부하를 유발할 가능성이 없다면, Literal 상수 값 사용을 고려해볼 수 있다.
