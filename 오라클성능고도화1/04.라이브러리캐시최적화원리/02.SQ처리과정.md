사용자가 SQL 질의를 던지면 오라클은 SQL 파싱을 거친 후 해당 SQL이 메모리에 캐싱 돼 있는지를 먼저 확인한다.

메모리에서 찾으면 곧바로 실행할 수 있지만 찾지 못하면 최적화 단계를 거쳐 메모리에 적재 후 실행한다.

SQL 커서를 메모리에서 찾아 곧바로 실행하는 것을 소프트 파싱, 최적화 및 ROW-Source Generate 단계를 거치는 것을 하드 파싱이라고 한다.

처음 실행하는 쿼리를 5천번 반복 실행하면 Parse call은 5천번 발생한다.

처음 1회는 하드파싱되므로 Misses in Library cache during parse : 1 이되고 나머지 4,999번은 라이브러리 캐시에 공유된 커서를 반복 재사용했다.

만약 Misses in Library cache during parse 가 0이면 최초 수행할 때부터 이미 다른 세션에 의해 커서가 캐싱된 경우이다.

### SQL 파싱

사용자가 던진 SQL을 가장 먼저 받아 처리하는 엔진이 SQL 파서이다.

SQL 파서는 SQL 문장을 이루는 개별 구성요소를 분석하고 파싱해서 파싱트리를 만든다.

그 과정에서 사용자가 던진 SQL에 문법적 오류가 없는지 Syntax 체크가 이루어진다.

예를 들어, 사용할 수 없는 키워드를 사용했거나 순서가 바르지 않거나 누락된 키워드가 있는지 체크한다.

파싱 트리가 만들어지고 나면 Semantic 체크를 통해 의미상 오류가 없는지 확인한다.

존재하지 않거나 권한 없는 오브젝트르 사용했을 때, 또는 존재하지 않는 칼럼을 참조했다면 이 단계에서 에러 메시지를 만난다.

문법적으로 완전하고 의미상 오류가 없다면 해싱 알고리즘을 이용해 해당 SQL 커서가 Shared Pool에 캐싱돼 있는지 확인한다.

그러기 위해 먼저 SQL ASCII 텍스트에 대한 숫자 값을 계산하고 이를 다시 해시 값으로 변환한다.

SHARED POOL에서 찾은 SQL문이 현재 수행하려는 SQL문과 일치하더라도 파싱을 요청한 사용자가 다르거나 옵티마이저 관련 파라미터 설정이 다르면

새로운 SQL 커서를 생성한다.

Shared Pool에서 정확하게 일치하는 SQL 커서를 찾았다면 바로 실행단계로 넘어가면 되지만 매치오디는 SQL문을 못 찾거나, 새로운 SQL 커서를 생성해야하면

옵티마이저가 최적화를 수행한다.

### SQL 최적화

옵티마이저는 시스템 통계 및 오브젝트 통계정보를 판단기준으로 다양한 액세스 경로를 비교하고 그 중 가장 효율적인 실행계획을 선택한다.

옵티마이저는 3개의 서브엔진을 사용한다,

#### Query Transformer

사용자가 던진 SQL을 최적화하기 쉬운 형태로 변환한다. 쿼리 변환 전후 수행 결과가 동일함이 보장돼야한다.

#### Plan Generator

하나의 쿼리를 수행할때, 후보군이 될만한 실행계획을 생성한다.

#### Estimator

쿼리 오퍼레이션 각 단게의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로 실행계획 전체에 대한 예상비용을 계산한다.

각 단계를 수행하는 필요한 I/O, CPU, 메모리 사용량 등을 예측하기 위해 데이터베이스 오브젝트 통계정보와 하드웨어적인 시스템 성능 통계정보를 이용한다.

오브젝트 통계와 시스템 통계정보는 오라클이 자동으로 수집하거나 DB 관리자의 정책에 따라 수집된다.

최적의 실행계획을 선택하려면 선택의 폭이 넓어야한다.

옵티마이저가 많이 만들고 이에 대한 비용을 평가할 수 있어야한다. 하나의 쿼리를 수행하는데 있어 너무 다양한 액세스 경로와 조인방식 조인 순사가 존재한다.

현실적으로 모든 실행계획을 평가하는 것은 불가능하므로 최적화에 걸리는 소요시간을 단축시킬 목적으로 몇 가지 테크니긍ㄹ 사용한다.

우선, 쿼리 수행 시 예상되는 총 수행시간에 비해 쿼리 최적화에 걸리는 시간이 일정비율을 넘지 않도록 적응적 탐색 전략을 이용한다.

조인순서를 무순위로 평가하는게아니라 최적의 실행계획을 발견할 가능성이 높은 순서대로 평가한다.

실행계획을 평가하는 도중에 멈추더라도 그중에서 선택된 실행계획이 거의 최적이거나, 최소한 만족할 만한 수준의 좋은실행계획에 속할 가능성을 높인다.

#### ROW-SOURCE GENERATOR

옵티마이저의 최적화 과정을 거치면 실행계획이 만들어진다.

이것을 실행가능한 코드 또는 프로시저 형태로 포맷팅하는 작업이 필요하며, 이 역할을 ROW-SOURCE GENERATOR가 담당한다.

ROW-SOURCE는 레코드 집합을 반복 처리하면서 사용자가 요구한 최종 결과집합을 실제적으로 생성하는데 사용되는 제어 구조를 말한다.

하드 파싱은 CPU 자원을 많이 사용하는 작업이다

하드 파싱과정에서 Shared Pool과 라이브러리 캐시에 대해 발생하는 래치 경합도 CPU를 많이 소비하게 만드는 요인이다.

한번 수행될 때마다 내부적으로 많은 데이터 딕셔너리 조회를 수반하므로 하드 파싱은 비용이 크다.

무거운 작업을 거쳐 얻은 결과물을 한 번만 사용하고 버린다면 비효율이 크다. 그래서 파시 과정을 거친 SQL 커서를 재사용할 수 있도록

캐싱해두는 메모리 공간이 라이브러리 캐시이다.
