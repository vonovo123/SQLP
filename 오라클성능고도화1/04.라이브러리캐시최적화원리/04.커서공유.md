커서는 상황에 따라 여러가지 의미로 사용된다.

\- 공유 커서 : 라이브러리 캐시에 공유돼 있는 Shared SQL Area
\- 세션 커서 : Private SQL Area에 저장된 커서
\- 애플리케이션 커서 : 세션 커서를 가리키는 핸들

### 공유 커서

클라이언트가 SQL을 수행하면, 서버 프로세스는 해당 SQL이 라이브러리 캐시에 공유돼 있는지를 먼저 확인한다.

공유돼있지 않으면 최적화 과정을 통해 실행계획을 만들고, 라이브러리 캐시에 공유한다.

라이브러리 캐시에 공유돼 있는 Shared SQL Area를 커서라고 부른다.

### 세션 커서

라이브러리 캐시에 공유돼 있는 커서를 실행할 때는 우선 PGA 영역에 메모리를 할당한다.

이를 Private SQL Area라고 하는데, Persistent Area와 Runtim Area로 나뉜다.

Shared SQL Area를 읽어 커서를 실핼하는데 필요한 정보를 Private SQL Area에 담고, 공유 커서를 가리키는 포인터를 유지한다.

커서의 상태정보도 관리한다.

커서를 실행하기 위한 준비과정을 커서를 오픈한다고 표현하고, PGA에 저장된 커서 정보를 커서라고 부른다.

라이브러리 캐시에 공유돼 있는 커서는 SQL을 수행하는데 필요한 루틴을 정의한 것이다. 루틴을 정의하고 클래스를 디자인한 것은 옵티마이저이다.

커서를 오픈, 즉 라이브러리 캐시에 공유돼 있는 커서를 PGA에 인스턴스화하는 것은 PGA에 커서를 위한 메모리 공간을 할당하고, 실제 데이터 추출을 시작하기 위한 준비작업이다.

### 애플리케이션 커서

PGA에 있는 커서를 핸들링하려면 클라이언트 애플리케이션에도 리소스를 할당해야한다. 클라이언트에 할당하는 리소스 또한 커서라고한다.

## 커서공유

커서를 공유한다는 말에서 커서는 라이브러리 캐시의 공유 커서를 말한다.

세션커서, 애플리케이션 커서는 다른 프로세스와 공유할 수 없다.

라이브러리 캐시에 공유돼 있는 커서의 수행 통계를 v$sql을 통해 조회해 볼 수 있다.

```sql
alter system flush shared_pool;

select /*+cursor_test*/ emono, ename, job, sal, deptno
from emp
where empno = 7788;

select /*+cursor_test*/ emono, ename, job, sal, deptno
from emp
where empno = 7788;


select /*+cursor_test*/ emono, ename, job, sal, deptno
from emp
where empno = 7788;


select sql_id, parse_calls, load, executions, invalidations, decode(sign(invalidations), 1,(loads-invalidations), 0) reloads
from v$sql
where sql_text like '%cursor_test%'
and sql_text not like '%v$sql%'
```

v%sql에서 조회한 항목의 의미는 다음과 같다.

\- parse_calls : 라이브러리 캐시에서 sql 커서르 찾으려는 요청 횟수
\- loads : 하드파싱을 거친 SQL 실행계획을 라이브러리 캐시에에 적재한 수
\- executions : SQL을 수행한 횟수
\- invalidations : 커서가 무효화된 횟수, 커서가 참조하고 있는 오브젝트에 중요한 변화가 일어났음을 의미

같은 SQL을 3번 수행하면 라이브러리 캐시에서 SQL을 찾는 PArse Call이 세 번 발생하고, 하드파싱은 단 한 번 일어난다.

```sql
disconnect

connect scott@ora10g

select /*+cursor_test*/ emono, ename, job, sal, deptno
from emp
where empno = 7788;


```

다른 세션에서 같은 SQL을 수행할 때도 이전 세션에서 적재한 커서를 재사용할 수 있다.

공유돼 있떤 커서가 어떤이유에서건 무효화 될 수 있는데 커서가 참조하고 있던오브젝트에 컬럼이 추가/삭제 되거나 새로운 인덱스가 만들어지거나 오브젝트 통계를

새로 수집하는 등의 DDL문이 수행되는 경우다.

칼럼이 삭제되면 이전 커서가 잘못된 컬럼 참조를 할 수 있기 때문에 무효화되어야하고, 오브젝트 통계를 재수집하면 이전에 수집된 실행계획이 최적이 아닐 수 있으므로 해당 커서는 무효화되야만 한다.

공유된 커서를 사용할 때는 최적화 및 ROW_SOURCE Generation 단계를 생략하고 곧바로 실행 단계로 넘어가므로 효율적이고 빠르게 SQL을 수행한다.

커서가 공유되려면 커서를 식별하는 키 값이 같아야 하는데, 라이브러리 캐시에서 커서를 식별하기 위해 사용하는 키는 SQL 문장 그 자체이다.

SQL 문을 구성하는 전체 문자열이 이름 역할을 한다.

sql_id와 sql_fulltext는 1:1로 대응된다. 따라서 SQL문 중간에 작은 공백문자만 하나 추가하더라도 서로 다른 SQL 문장으로 인식해 새로운 sql_id를 발급받는다. 즉 커서가 공유되지 않는다.

### Child 커서를 공유하지 못하는 경우

SQL 문장이 100% 동일함에도 커서를 공유하지 못하고 별도의 SQL 커서를 생성해야할 때가 있다.

DROP 하기전까지 영구적으로 보관되는 Stored Obejct는 생성될 때부터 유일하게 식별 가능한 이름이 부여되므로 Child 오브젝트를 사용할 필요가 없다.

하지만 SQL 커서처럼 실행시점에 생성돼서 인스턴스가 떠있는 동안에만 존재하는 Transaction Object는 이름을 따로 지정하지 않고 문장을 구성하는 전체 문자열 그대로가 라이브러리 캐시 오브젝트를 식별하는 이름역할을 한다.

그래서 전체 문자열은 같지만 다른 방식으로 실행해야 하거나, 파싱 스키마에 따라 다른 오브젝트를 참조하는 상황에서 Child 커서가 필요하다.

SQL 마다 하나의 Parent 커서를 가지며, Child 커서는 여러 개일 수 있다. 실제 수행에 필요한 정보느 Child 커서에 담기므로 적어도 한 개의 Child 커서를 갖는다.

V$sqlaera는 Parent 커서 정보를 보여주고, v$sql은 Child 커서 정보를 보여준다.

Version Count 수치가 높은 SQL 일수록 커서를 탐색하는데 많은 시간이 소비되므로 library cache latch에 대한 경합 발생 가능성을 높인다.

예를emfdj, ASP 서비스를 하면서 테이블을 하나로 통합하지 않고 각 고객사마다 별도의 사용자 계정을 발급하는 방식으로 설계하면 각 사용자 계정마다 같은 테이블을 생성해 두고,

로그인할 때 각자의 계정을 사용함으로써 같은 SQL을 사용하면서 각기 자신의 테이블에 액세스하도록 구현한다.

Parent 커서는 공유하겠지만 Child 커서는 개별적으로 생성될 것이고 모든 SQL이 대해 많은 Child 커서를 갖는 구조이므로 라이브러리 캐시 효율은 나빠진다.

하나의 SQL 문장이 여러 Child 커서를 갖는 이유는 여러가지가 있다.

1. SQL에서 참조하는 오브젝트명이 같지만 SQL을 실행한 사용자에 따라 다른 오브젝트를 가리킬 때
2. 참조 오브젝트가 변경돼 커서가 무효화 되면 이후 그 커서를 처음 사용하는 세션에 의해 다시 하드파싱돼야하는데, 특정 세션이 아직 기존 커서를 사용중일 때
3. 옵티마이저 모드를 비롯해 옵티마이저 관련 파라미터가 다를때
4. 입력된 바인드 값의 길이가 다를 때
5. NLs 파라미터를 다르게 설저할때
6. SQL 트레이슬르 활성화할때

## Parent 커서 공유하지 못하는 경우

의미적으로 같고 실행환경이 같은데도 커서를 공유하지못해 Parent 커서 자체가 여러 개 생성되는 경우가 있다.

1. 공백문자 또는 줄바꿈
2. 대소문자 구분
3. 테이블 Owner 명시
4. 주석
5. 옵티마이저 힌트 사용
6. 조건절 비교 값

문자열을 조금 다르게 기술했다는 이유로 서로 다른 SQL로 각각 하드파싱을 일으키고 서로 다른 공간을 차지하면서 Shared Pool을 낭비한다.

이런 비효율을 줄이고 공유 가능한 형태로 SQL을 작성하려면 개발 초기에 SQL 작성 표준을 정해 이를 준수해야한다.

5번의 경우 의도적으로 실행계획을 달리 가져가려는 것이므로 논외로하고 라이브러리 캐시효율과 직접적인 관련이 큰 것은 6번 패턴이다.

조건절에 바인드변수를 사용하지않고 서로 다른 Literal 값으로 문자열을 대체하는 경우다.
