사용자의 데이터에 대한 요구 사항은 너무 다양해 미리 최적화해서 컴파일 해놓는 것은 불가능에 가깝다.

따라서 SQL이라는 구조화된 질의언어를 이용해 DB에 요구사항을 전달하면 그것을 위한 처리루틴을 동적으로 생성해서 최적화하고,

이를 처리하는 실제적인 프로시저를 내부적으로 생성해 컴파일한다.

사용자 요구사항을 처리하는 중에 발생하는 Call은 User Call과 Recursive Call로 구분된다.

DBA로부터의 관리적 명령어든 사용자러부터의 데이터 조작 명령이든 모두 데이터베이스 CALL을 통해 서버 프로세스로 전달되며.

불필요하고 반복적인 CALL 수행횟수를 최소화하는 것은 데이터베이스 수행속도를 향상시키고 확장성을 높이는 중요한 튜닝요소이다.

커서의 활동 상태는 Parse, Execute, Fetch 세 단계로 구분된다.

Parse Call은 커서를 파싱하는 과정이다. 실행계획을 생성하거나 찾는과정에 관한 정보를 포함한다.

Execute Calldms 커서를 실행하는 단계이다.

Fetch Call은 Select문에서 실제 레코드를 읽어 사용자가 요구한 결과집합을 반환하는 과정에 대한 통계이다.

Parse Call을 최소화 및 최적화 하는 방식에는 바인드 변수를 이용해 Parse Call을 가볍게하는 방법,

세션 커서 캐싱을 통해 Parse Call을 더 가볍게 하는 방법, 애플리케이션 커서 캐싱을 통해 Parse Call이

아예 발생하지 않게 하는 방법이 있다.

insert, update, delete, merge 등 DML문은 Execute Call 시점에 모든 처리과정을 서버 내에서 완료하고 처리결과만을 리턴하므로

Fetch Call이 전혀 발생하지 않는다. Insert ... select 문도 마찬가지이다.

클라이언트로부터 명시적인 Fetch call을 받지 않으며 서버 내에서 묵시적으로 Fetch가 이루어진다.

select문일 때 Execute Call 단계에서는 커서만 오픈하고, 실제 데이터를 처리하는 과정은 모두 Fetch 단계에서 일어난다.

for update 구문을 사용하면 Execute Call 단계에서 모든 레코드를 읽어 Lock을 설정한다.
