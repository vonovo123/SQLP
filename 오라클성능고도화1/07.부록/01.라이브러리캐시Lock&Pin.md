### 라이브러리 캐시 Lock

라이브러리 캐시 Lock 은 라이브러리 캐시 오브젝트에 대한 핸들을 보호하며, 세 가지 모드를 사용한다.

\- Shared 모드 : 읽기작업시
\- Exclusive 모드 : 생성 또는 변경 작업 시
\- Null 모드 : Lock 을 장시간 유지하려 할때 사용. 실제 대기를 발생시키지는 않으며, 오브젝트간 의존성을 관리하는데 사용

NULL 모드는 모든 모드와 호환되고 Shared모드는 Null과 Shared 모드 , Exclusive 모드는 Null와만 호환된다.

테이블 정의를 변경하거나 사용자 정의 함수/프로시저를 컴파일 할 때는 Exclusive 모드로 Lock을 설정하고, 읽을 때는 Shared 모드로 Lock을 설정한다.

```sql
create table t (id number, name, char(10));

insert into t
select rownum, lpad(rownum, 10, '0' ) from dual
connect by level <= 100000;
commit;
alter table t modify naem char(20);
```

맨 마지막 ALTER 문장은 100만 건을 갱신해야 하므로 T 테이블 LCO 핸들에 대한 Lock을 Exclusive 모드로 획득한 채 오랫동안 수행된다.

그 동안 COUNT 쿼리를 수행하면 SQL 문을 파싱하려고 T 테이블 LCO 핸들에 대해 Shared mode Lock을 요청한다.

```sql
select count(*) from t;
```

Exclusive와 Shared 모드는 서로 호환되지 않으므로 두 번째 세션은 라이브러리 캐시 Lock을 대기한다.

NULL 모드는 Lock을 장시간 유지하려 할 때 상요하며, 커서, 프로시저, 함수, 패키지 처럼 실행 가능한 오브젝트를 NULL 모드로 설정할 수 있다.

특히, 커서는 항상 Null 모드만을 사용한다.

오라클 메뉴얼에는 라이브러리 캐시 Lock을 Breakable Parse Lock이라고 언급하는데, 이는 Null 모드의 Parse Lock은 대기없이 언제든 해제될 수 있기 때문에 붙여진 이름이다.

스키마 오브젝트가 변경되거나 Drop 되면 그 오브젝트를 참조하는 실행가능 LCO는 무효화 되야한다.

이를 위해 Shared Pool 에 캐싱된 실행가능 LCO는 자신이 참조하는 각 스키마 오브젝트에 대해 하나의 Parse Lock을 보유한다.

오브젝트 정보가 변경되면 Parse Lock을 해제함으로써 그것을 참조하는 실행가능 LCO를 무효화한다.

예를들어 alter table EMP 문장이 수행되면 수정되는 테이블의 핸들에 대한 Lock을 무효화해야하므로 Parse Lock을 해제한다.

이로써 오브젝트를 참조하던 두 SQL 커서는 무효화된다.

Null 모드의 Parse Lock은 ,그것을 해제함으로써 해당 실행가능 LCO를 사용하려는 이후의 세션에게 그 LCO가 더 이상 유효하지 않음을 알리는 메커니즘으로 사용된다.

대기 없이 언제든 해제할 수 있도록 하려고 Null 모드를 사용하는 것이다.

Parse Lock은 SQL 또는 PL/SQL이 처음 수행되면서 파싱되는 시점에서 얻어지고 해당 SQL문을 위한 shared SQL area가 Shared Pool에 남아있는 한 계속 유지된다.

### 라이브러리 캐시 pin

라이브러리 캐시 pin은 LCO의 실제 내용이 담긴 힙을 보호한다.

라이브러리 캐시 Pin을 얻은 프로세스만이 해당 LCO의 실제 내용을 읽고, 변경하고, 실행할 수 있다.

파싱/컴파일하거나 정보를 새로 로드할 때도 Pin을 얻어야 한다.

라이브러리 캐시 힙을 pin 하려면 먼저 라이브러리 캐시 Lock을 얻어야한다.

세션에 의해 얻어진 Null Lock이 해제된 상태라면 pin 오퍼레이션은 실패하게된다.

그리고 Lock을 얻고 Pin 하려는 순간, 힙에 저장된 내용이 캐시에서 밀려나고 없다면 다시 적재해야한다.

Parse 단계에서 SQL 커서를 찾지 못해 하드파싱 하게 되면 SQL 트레이스에서 아래와 같은 항목을 발견할 수 있다.

misses in library cache during parse : 1

캐시 Miss가 Execute 단계에 나타나는 경우가 있다.

Parse 단계에서 커서 LCO 핸들을 찾았는데, 실행 시점에 커서를 오픈하려고 LCO 힙을 확인해보니 캐시에서 밀려나고 없어 실행단계에서 하드파싱하는 경우가 여기에 속한다.

실행계획이 내부적으로는 커서 LCO 힙과는 별도의 힙 영역에 저장된다면 파싱과 실행단계 모두에서 라이브러리 캐시 Miss가 발생할 수 있다.

sql문이 달라 라이브러리 캐시가 다른 Hash 값으로 저장되지만 실행계획은 동일할 때가 이 경우에 속한다.

두 SQL 커서가 같은 실행계획을 공유하는 경우, SQL 커서를 찾지 못해 Parse 단계에서 하드파싱한다. 하드파싱한 결과 같은 실행계획이 이미 라이브러리 캐시에

공유된 것이 확인됬다.

그래서 그 실행계획에 대한 포인터만 LCO에 담고 Parse 단계를 마친다.

실행 단계로 넘어가서 커서를 오픈하려고 LCO 힙에 저장된 포인터로 실행계획을 찾아가 보니 그 실행계획에 대한 핸들은 캐싱돼 있는데, 그 실제 내용에 해당하는 힙 영역은 사라지고 없다.

라이브러리 캐시 효율을 위해 무엇보다 중요한 것은 라이브러리 캐시 힙에 저장된 오브젝트가 새로 로딩되는 비율을 감소시키는 것이다.

PIN 모드로는 Share, Exclusive 두 가지가 있고, Stored 오브젝트와 Transient 오브젝트 둘 다 이 두 가지 모드 중 하나를 사용해야 한다.

읽기 작업을 위해서라면 항상 Shared 모드로 Pin한다.

LCO를 변경할 때는 에러와 보안 체크를 위해 먼저 Shared 모드로 Pin 한다. 그러고 나서 실제 변경작업을 위해서는 Exclusive 모드로 다시 Pin을 설정한다.

개념적으로 Pin은 힙에 설정되지만 Pin 소유자와 대기자 목록도 내부적으로는 LCO 핸들에서 관리된다.

### 라이브러리 캐시 Lock과 Pin, 두 개의 직렬화 장치를 따로 두는 이유

SQL 커서를 하드파싱할 때, SQL이 참조하는 오브젝트에 대해서는 읽기 작업이므로 Shared 모드 Lock 과 Shared 모드 Pin을 설정한다.

테이블, 인덱스 같은 오브젝트 LCO 핸들에, Lock을 걸고 또다시 LCO 힙에 Pin을 설정하는 이유는 무엇일까?

LCO 핸들은 영구적인 Fixed Array 영역에 할당되는 반면 LCO 자체는 동적으로 관리되는 힙 영역에 할당되는데,

힙에 할당된 전체 또는 일부 청크가 언제든 유실될 가능성이 있기 때문이다.

테이블 정보를 읽으려고 LCO 핸들에서 Lcok과 모두 Shared 모드로 설정하고 힙을 찾아갔는데, 힙 정보가 사라지고 없다면

pin을 Exclusive 모드로 재설정 후 테이블 정보를 다시 로드하게 된다.

함수/프로시저도 마찬가지이다. 예를들어 SQL을 하드파싱할 때 거기서 참조하는 함수에 대해서는

Shared 모드로 Lock을 얻는다. 실행할 때는 함수에 대한 Lock과 Pin을 각각 Null과 Shared 모드로 설정하는데,

실제 힙을 찾아갔을 때 힙 정보가 사라지고 없다면 Pin을 Exclusive 모드로 제설정해야한다.

하나의 LCO에 대해 Lock 과 Pin 두 개의 직렬화 장치를 따로 두는 이유는 실제 LCO 컨텐츠의 정합성은 Pin을 통해 보장되고,

그것과 별도로 Lock을 둠으로써 동시성을 높이도록 하는 것이다.
