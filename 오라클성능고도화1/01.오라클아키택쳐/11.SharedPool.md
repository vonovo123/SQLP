SGA의 가장 중요한 구성요소 중 하나인 Shared pool은 크게 딕셔너리 캐시와 라이브러리 캐시로 구분된다.

## 딕셔너리 캐시

딕셔너리 캐시는 오라클 딕셔너리 정보를 저장해두는 캐시영역으로 Row 단위로 읽고 쓰기 때문에 '로우 캐시'라고도 불린다.

테이블, 인덱스 같은 오브젝트는 물론 테이블스페이스, 데이터파일, 세그먼트, 익스텐트,사용자, 제약, sequence,DBLink 에 관한 정보들을 캐싱한다.

사용자가 Sequence 객체를 하나 만들면 오라클 딕셔너리에 저장되고, 로우 캐시를 거쳐 읽고 쓰기가 이루어진다.

사용자가 Sequence로부터 새로운 값을 인출하기 위해 nextval을 호출할때마다 로우캐를 통해 update가 이루어진다.

---

### sequence cache 옵션

잦은 채번은 로우 캐시에 경합을 발생시킨다. 이를 해소하기 위해 Cache 옵션을 사용해야하며, cache의 크기가 10이면 Nochace일 때보다 로우 캐시를 갱신하는 횟수가 10%로 줄어든다.
동시에 채번이 많이 발생하는 Sequence 일수록 cache 사이즈를 크게 설정하는 것이 중요하다. 기본설정값은 20이다.

---

V$rowcache 뷰를 통해 딕셔너리 캐시의 활동성에 대한 통계를 조회해 볼수 있다.

히트율을 조사했을때 수치가 낮게나오면 Shared Pool 사이즈를 늘리는 것을 고려해 볼 필요가 있다.

```sql
COLUMN HIT_RATIO FORMAT 990.00
SELECT ROUND(SUM(GETS - GETMISSES)/SUM(GETS)*100,2) HIT_RATIO
FROM V$ROWCACHE;
```

v$rowcache에서 TYPE = 'PARENT' 인 엔트리와 v$latch_chilren에서 이름이 'row cache objects' 인 래치 개수를 조회해 보면, 항상 값이 일치하는 것을 알 수 있다.

즉, 로우 캐시에 관리되는 엔트리 각각에 대해 하나의 래치가 할당돼 있음을 짐작할 수 있다.

## 라이브러리 캐시

라이브러리 캐시는 사용자가 던진 SQL과 그 실행계획을 저장해 두는 캐시영역이다. 사용자가 SQL이라는 명령어롤 통해 결과집합을 요청하면 이를 최적으로 수행하기 위한 루틴이필요하다.

이를 실행계획이라고 한다.

쿼리 구문을 분석해서 문법 오류 및 실행 권한을 체크하고, 최적화 과정을 거쳐 실행계획을 만들고, SQL 실행엔진이 이해할 수 있는 형채로 포맷팅하는 전 과정을 하드파싱이라고 한다.

특히 최적화는 하드 파싱을 무겁게 만드는 가장 결정적인 요인인데, 같은 SQL을 처리하려고 이런 무거운 작업을 반복 수행하는 것은 매우 비효율 적이다.

그래서 같은 SQL에 대한 반복적인 하드파싱을 최소화하기 위한 새로운 캐시 공간을 두게 되었고, 그것이 바로 라이브러리 캐시 영역이다.

당연히 라이브러리 캐시 최적화 원리는 캐싱된 SQL과 그 실행계획의 재사용성을 높이는데 있다.
ㅕㅡ89
