단일 sql이 수행되는 도중에 다른 트랜잭션에 의해 데이터가 변경,추가,삭제된다면 일관성 없는 결과를 리턴할 수 있다.

이를 방지하고자 Oracle은 문장수준 읽기 일관성을 제공한다.

## 문장수준 읽기 일관성이란?

단일 SQL문이 수행되는 도중 다른 트랜잭션에 의해 데이터의 추가, 변경, 삭제가 발생하더라도 일관성 있는 결과집합을 리턴하는 것을 말한다.

오라클을 제외한 다른 DBMS는 읽기 작업에 Shared Lock을 사용해, Exclusive Lock이 걸린 로우를 읽지 못하게 하는 로우 Lock으로 Dirty Read를 방지한다.

테이블 단위 Lock을 사용하지 않는 한 Dirty Read를 방지하는 것만으로는 문장수준 읽기 일관성이 완벽하게 보장되지 않는다.

```sql
--TX1
select sum(잔고) from 계좌

--TX2
insert into 계좌(계좌번호, 잔고) values(11,1000);
commit;
```

새 레코드가 맨 뒤쪽에 추가되면 잔고 총합계에 포함되지만 이미 읽고 지나가간 위치에 Tx2 의 데이터가 삽압되면 총합계에서 누락된다.

레코드 입력 위치에 따라 총합계가 달라지면 읽기 일관성이 아니다.

이런 현상을 방지하려면 트랜잭션 고립화 수준을 높이거나 테이블 Lock을 사용해야 한다.

오라클은 Shared Lock을 사용하지 않고 UNDO 세그먼트에 저장해둔 데이터를 활용하므로 고립화수준 변경이나 table lock 완벽한 문장수준 읽기 일관성을 보장한다.

TX1 : 잔고의 총합을 구하는 쿼리
TX2 : 특정 레코드의 잔고를 차감해 다른 특정 레코드에 더하는 쿼리

TX1에서 잔고 총합을 구하는 쿼리가 진행 중일 때 TX2가 TX1이 이미 읽고 지나각 레코드에서 잔고를 차감하거나 반대로 TX1이 앞으로 읽을 레코드에서 잔고를 차감해
이미 읽고 지나각 레코드에 더하면 총 합계가 달라질 수 있다.

이런 현상을 방지하려면 트랜잭션 고립화 수준을 올리거나 테이블 Lock을 사용해야한다. 하지만 오라클에선 이런 현상이 발생하지 않는다.

```sql
-- TX1 : 잔고 총합을 구하는 쿼리
-- TX2 :
update 계좌 set 잔고 = 잔고 + 100 where 계좌번호 = 7;
update 계좌 set 잔고 = 잔고 - 100 where 계좌번호 = 3;
commit;

```

1. TX1 : 2번계좌까지 읽는다
2. TX2 : 1번 update를 실행한다.
3. TX1 : 6번 계좌까지 읽어 내려간다.
4. TX2 : 2번 update를 실행하고 커밋한다.
5. TX 1 : 끝까지 읽어 내려간다.

7번 계좌 잔고를 1100으로 바꾼 TX2 가 커밋되었으므로 잔고 총합은 10,100으로 계산됐지만 실제 잔고 총합은 10,000 이다. TX1은 일관성 없게 잔고 총합계를 구한 것이다.

### 테이블 레벨 Lock을 통한 읽기 일관성 확보

비일관성 읽기 문제를 해결하기 위한 일반적인 해법은 트랜잭션 고립화 수준을 상향 조정하는 것이다.

기본 트랜잭션 고립화 수준(level1 Read Committed)에서는 값을 읽는 순간만 Shared Lock을 걸었다가 다음 레코드로 이동할때 해제한다.

이미 읽고 지나간 레코드는 다른 트랜잭션이 변경할 수 있어 비일관성 읽기 문제가 발생한다.

트랜잭션 고립화 수준을 레벨2(Repetable Read) 로 조정하면 TX1 쿼리가 진행되는 동안 읽는 레코드는 Shared Lock이 계속 유지되며 쿼리가 끝나고 다음 쿼리가 진행되는 동안에도 Lock을 풀지않는다.

심지어 쿼리가 끝나고 다음 쿼리가 진행되는 동안에도 Lock을 불지 않는다.

커밋 또는 롤백을 통해 트랜잭션이 완료될 때 비로소 Lock이 해제되므로 더 높은 수준의 읽기 읽관성이 보장된다.

하지만 트랜잭션 고립화 수준을 상향하면 Lock 발생범위가 넒어지고 더 오래 유지되기 때문에 동시성이 저하되고 교착상태가 발생할 가능성이 높아진다.

위 사례가 대표적인데 TX2가 1번 update를 통해 7번 레코드에 Exclusive Lock을 설정하고 TX1은 3번 레코드에 Shared Lock을 설정한다.

TX2는 2번 update를 실행하는 단계에서 3번 레코드에 걸린 Shared Lock을 대기하게 되고 Tx1번이 7번 레코드를 읽으려는 순간 영원히 교착상태가 된다.

반면, 오라클은 높은 수준의 동시성을 유지하면서도 완변한 문장수준 읽기 읽관성을 보장한다.

## Consistent 모드 블록 읽기

오라클은 쿼리가 시작된 시점을 기준으로 데이터를 읽어 들인다.

쿼리가 시작되기 전에 이미 커밋된 데이터를 읽고, 쿼리 시작 이후 커밋된 변경사항은 읽어들이지 않는다.

변경이 발생한 블록을 읽을 때는 현재 Current블록으로부터 CR 블록을 생성해서 쿼리가 시작됨 시점으로 되돌린 후 그것을 읽는다.

Current 블록은 디스크로부터 읽혀진 후 사용자의 갱신사항이 반영된 최종 상태의 원본 블록을 말하며 CR 블록은 Current 블록의 복사본이다.

CR copy 블록으로 복사해 읽기 일관성을 지원하는 오라클만의 독특한 메커니즘을 다중 버전 읽기 일관성 모델이라고 한다.

---

### RAC 환경에서의 Current 블록

단일 인스턴스 환경이라면 캐싱된 Current 블록은 오직 하나지만 RAC 환경이라면 Share 모드의 Current 블록이 여러 노드에 캐싱돼 있을 수 있다.

하지만 Share 모드와 달리 Exclusiv 모드의 Current 블록은 오직 한 노드에만 존재할 수 있다.

Share 모드의 Current 블록이 여러 노드에 공유된 상태에서 특정 노드가 Exclusive 모드로 업그레이드하면 나머지 노드에 캐싱된 Current 블록들은
전부 Null 모드로 다운그레이드 된다.

Null 모드로 다운그레이드 된 블록을 읽을 때는 다른 노드 또는 디스크로부터 블록을 다시 읽어야한다.

따라서 RAC 환경에서도 Shared모드이든 Exclusive 모드이든 Current 블록의 SCN이 쿼리 SCN보다 작으면 쿼리가 시작된 이후에 변경이 없었던 블록임을

보장받을 수 있다.

---

때로는 시작 시점이 아닌, 데이터를 찾아간 바로 그 시점의 최종 값을 읽어야 할 때도 있다. 시작 지점부터 읽는 것을 Consistent mode 읽기, 후자를 Current mode라고 한다.

Consistent 모드로 데이터를 읽을 때, 쿼리 시작 시점과 블록의 마지막 변경 시점을 확인하기 위해 SCN이라고 하는 시간정보를 이용한다.

이 값은 기본적으로 사용자가 커밋을 할때마가 1씩 증가한다. 또는 커밋이 없더라도 오라클 백그라운드 프로세스에 의해 조금씩 증가한다.

SCN은 읽기 일관성과 동시성 제어를 위해 사용되고, 생성된 Redo 로그 정보의 순서를 식별하는데도 사용되며, 데이터 복구를 위해서도 사용된다.

Consistent 모드 읽기를 이해하기 위해선 블록 SCN 개념이 필요하다.

오라클은 블록이 마지막으로 변경된 시점 정보를 식별하기 위해 모든 블록해더에 SCN 정보를 관리한다. 이를 블록 SCN이라고 한다.

블록 ITL 엔트리에 저장되는 트랜잭션별 커밋 SCN과는 별도로 관리된다 .

## Consistent 모드 블록 읽기의 세부원리

오라클에서 수행되는 모든 쿼리는 Global 변수인 SCN 값을 먼저 확인하고 나서 읽기 작업을 시작한다. 이를 쿼리 SCN 또는 스냅샷 SCN이라고 한다.

쿼리 SCN을 들고 다니면서 읽는 블록마다 블록 SCN과 비교해 읽을 수 있는 버전인지를 판단하는 것이다.

쿠리 SCN을 가지고 Consistent 모드로 읽을 때, 읽는 블록 상태에 따라 일관성을 유지하는 방법이 다르다.

A. Current 블록 SCN <= 쿼리 SCN 이고 committed 상태

Consistent 모드에서 데이터를 읽을 때는 블록 SCN이 쿼리 SCN 보다 작거나 같은 블록만 읽을 수 있다.

이때의 블록은 Current 블록을 의미하며, Current 블록은 오직 한 개뿐이다.

데이터 갱신은 항상 Current 블록에만 발생하므로, Current 블록의 SCN이 쿼리 SCN보다 작고 commited 상태라면 쿼리 시작이후 해당 블록에 변경이 가해지지 않았다는 의미로 CR블록을 생성하지 않고 그대로 읽는다.

B. Current 블록 SCN > 쿼리 SCN 이고 committed 상태

Current 블록이 commited 상태지만 블록 SCN이 쿼리 SCN보다 크다면 쿼리가 시작된 이후 해당 블록에 변경이 가해지고 커밋되었다는것을 의미한다.

블록 원본에 해당는 Current 블록의 SCN이 쿼리 SCN 보다 크면 블록 복사본에 해당하는 CR 블록을 먼저 생성한다.

CR 블록을 쿼리가 읽을 수 있는 과거 상태로 되돌리기 위해 Undo 정보가 필요하다. ITL 슬롯에서 UBA가 가리키는 UNDO 블록을 찾아 변경이전값을 읽는다.

CR 블록을 한 단계 이전 상태로 되돌렸는데 거기에 커밋되지 않은 변경사항이 포함돼 있거나 여전히 블록 SCN이 쿼리 SCN보다 높다면 다시 ITL 슬롯에 있는 UBA 가 가리키는 UNDO 블록을 찾아 변경 이전 값을 읽는 작업을 계속한다.

최종적으로 완성된 버전의 CR 블록은 , 블록 SCN이 쿼리 SCN보다 작거나 같으면서 커밋되지 않은 내용은 전혀 포함되지 않은 상태가 된다 .

UBA를 통해 계속적인 롤백이 가능한 것은 ITL에 대한 변경내역까지도 UNDO 레코드에 기록되기 때문이다.

같은 레코드를 계속 변경할 때, 그 레코드를 조회하는 다른 세션에서의 CR 블록 읽기 횟수도 계속 증가하는 것을 통해 이 사실을 확인할 수 있다.

```sql
--TX1
update emp set sal = sal + 1 where empno = 7900;

--TX2
set autotrace on statistics
select * from emp where empno = 7900;

```

update 횟수가 증가할 때마다 consistent gets도 하나씩 계속 증가한다.

10g부터는 IMU 메커니즘이 작동하므로 update를 수행하는 세션에서 아래처럼 파라미터를 변경하고 테스트해야 한다.

```sql
alter session set "_in_memory_undo_" = false
```

IMU 기능이 작동하면 CR 롤백을 위해 UNDO를 참조하지 않고 Shared POll 내의 IMU Pool에 저장된 값을 이용하므로 update를 일정 횟수 반복하기 전까지는 consistent gets가 증가하지 않는다.

---

#### IN-Memory Undo

오라클은 Undo 데이터를 Undo 세그먼트가 아닌 Shared Pool 내의 미리 할당된 IMU POOL에 생성한다. 각 POOL은 하나의 트랜잭션에 전용으로 할당되며 IN Memory undo latch에 의해 보호된다.

Pool이 다 차면 그때까지 저장해 둔 Undo 데이터를 Undo 세그먼트로 일괄 기록하며 이후 계속 발생하는 Undo 데이터는 예전처럼 UNDO 세그먼트에 저장된다.

작은 트랜잭션을 위해 고안된 기능으로 이를 통해 undo 세그먼트 헤더 블록과 undo 세그먼트 블록 버퍼에 대한 래치 경합과 pinning을 줄일 수 있다.

---

만약 CR 블록을 과거 상태로 되돌리는 과정에서 필요한 undo 정보가 제거되면 snapshot too old 에러가 발생한다. 또는 블록 클린아웃 과정에서 트랜잭션 테이블 슬롯이 이미 다른 트랜잭션에 의해 재사용되는 바람에 현재 읽고자 하는 클린아웃되지 않은 블록의 정확한 커밋 시점 정보를 알 수 없을 때도 마찬가지이다.

C. Current 블록이 Active 상태, 즉 갱신이 진행중인 것으로 표시된 상태

읽으려는 레코드에 Lock Byte가 설정돼 있는데 ,ITL에 커밋정보가 기록되지 않았따면 현재 갱신중인 상태로 인식할 수 있다.

하지만 오라클은 커밋 시 곧바로 블록을 클린아웃하지 않기때문에 ITL의 상태만 보고 갱신이 진행중이라고 단정할 수는 없다.

따라서 Active 상태의 블록일 때는 일단 트랜잭션 테이블로 부터 커밋정보를 가져와 블록 클린아웃을 시도한다.

그 결과, 쿼리 SCN 이전에 이미 커밋된 블록으로 확인되면 A 처럼 그대로 읽는다.

그렇지 않은 경우 B경우처럼 하면 된다.
