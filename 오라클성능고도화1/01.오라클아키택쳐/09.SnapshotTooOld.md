Snapshot too old 오류의 원인든 두 가지로 정리할 수 있다.

첫째, 데이터를 읽어 내려가다가 쿼리 SCN 이후에 변경된 블록을 만나 과거 시점으로 롤백한 후 Read Consistent 이미지를 얻으료고 하는데 Undo 블록이 다른 트랜잭션에 의해 이미 재사용되어
필요한 Undo 정보를 얻을 수 없는 경우.

Undo 세그먼트 크기가가 너무 작다는 신호일 수 있따.

둘째, 커밋된 트랜잭션 테이블 슬롯이 다른 트랜잭션에 재사용되 커밋 정보를 확인할 수 없는 경우로 Undo 세그먼트 수가 너무 적다는 신호일 수 있다.

### Undo 실패

1. SCN123 시점에 쿼리가 시작됐다.
2. 쿼리가 진행되는 동안 추가로 다수의 레코드에 update 를 실행하는 쿼리를 실행하는 배치프로그램이 동작하면서 커밋이 진행되 SCN이 129로 변경된다.
3. 배치프로그램으로 발생한 트랜잭션으로인한 변경내역을 담은 UNDO 블록이 다른 트랜잭션에 의해 재사용된다.
4. SCN123 시점에 동작한 쿼리가 이미 배치프로그램으로 인해 update된 블록에 도달했을때 블록 SCN이 123보다 큰 것을 확인하고 undo를 찾는다.
5. ITL 엔트리에 기록된 UBA륽어 undo 세그먼트를 찾아가지만 이미 재사용된 상태로 ORA-01555 에러를 발생시킨다.

대량의 데이터를 NL 조인하면 쿼리 수행시간이 오래걸릴 뿐아니라 inner 테이블에 대해 같은 블록을 반복해서 방문할 가능성이 커진다.

여러 세션에서 동시에 트랜잭션이 몰리지 않더라고 독립적으로 수행되는 도중에 snapshot too old에러가 발생할 수도 있다.

1. scn100 시점에서 커서를 오픈한다.
2. Update 문에 의해 특정 레코드의 값이 변경되고 커밋된다. 변경된 레코드가 담긴 블록 SCN이 120으로 변경된다.
   프로그램 내에서 커밋을 반복하기 때문에 insert 문과 update 문은 모두 개별 트랜잭션으로 처리된다.
3. for 문으로 인해 트랜잭션이 반복되다가 Before Image 가 담긴 Undo 블록이 다른 트랜잭션에 의해 재상요된다.
4. 커서가 Fetch 하다가 롤백 데이터를 찾아 undo 블록을 뒤지지만 이미 다른 트랜잭션에의해 재사용된 상태이다.

명시적으로 커서를 열어 로우를 하나씩 fetch 하면서 값을 변경하고 루프 내에서 게속해서 커밋을 날리는 방식을 fetch across commit이라고 한다 .
이는 동일 블록에 대한 잦은 접근으로 snapshot too old 에러를 숩게 발생시킨다.

### 블록 클린아울 실패

대량 업데이트 후에 커밋된 트랜잭션은 변경한 블록ㅇ르 모두 클린아웃하지 않은 상태에서 자신이 사용하던 트랜잭션 테이블 슬롯을 free 상태로 변경하고 트랜잭션을 완료한다.

이때부터 그 트랜잭션 테이블 슬롯은 다른 트랜잭션에 의해 제사용될 수 있다.

시간이 흘러 그 변경된 블록들이 읽혀야하는 시점에 delayed 블록 클린아웃을 위해 트랜잭션 테이블 슬롯을 찾아갔는데, 해당 슬롯이 다른 트랜잭션에 의해 이미 재사용됐으면

정상적인 블록 클린아웃과 일관성 모드 일기가 불가능해진다.

오라클은 일반 데이터 블록과 마찬가지로 Undo 세그먼트 헤더블록을 갱신한 내용도 Undo 레코드로서 기록한다.

따라서 트랜잭션 테이블 슬롯이 덮어 쓰인 것을발견하면 undo 세그먼트 헤더 블록에 가해진 변경사항을 롤백하려고 시도한다.

찾고자 하는 트랜잭션에 대한 커밋정보가 undo 블록에 남아있다면 현재 읽고자 하는 블록의 정확한 커밋 SCN을 가지고 블록 클린아웃을 수행할 수 있다.

클린아웃에 필요한 트랜잭션 테이블 undo 정보는 언젠가 필연적으로 덮어 쓰인다. 하지만 블록 클린아웃에 의한 snapshot too old는 거의 발생하지 않는다.

트랜잭션 슬롯이 필요해지면 커밋 SCN이 가장 낮은 트랜잭션 슬롯부터 재사용하는데, 그 슬롯에 기록돼 있떤 커밋 SCN을 UNDO 세그먼트 헤더에 최저 커밋 SCN으로 기록해 둔다.

트랜잭션 슬롯이 재사용되고 나면 그 슬롯을 사용하기 이전 트랜잭션의 정확한 커밋 SCN을 확인하는 것이 블가능하짐나 최저 커밋 SCN을 통해 이전에 커밋됐따는 사실은 짐작할 수 있따.

따라서 아직 클린아웃되지 않은 블록을 클린아웃하려고 ITL 이 가리키는 트랜잭션 테이블 슬롯을 찾아갔을때 커밋 정보가 지워지고 ㅇ벗으면, UNDO 세그먼트 헤더에 있는 최저 커밋 SCN을

블록 ITL 엔트레어 커밋 SCN으로 기록함으로써 블록 클린아웃을 마무리한다.

최저 커밋 SCN으로 추정된 블록 SCN은 대게 쿼리 SCN 보다 작다. 따라서 시작된 이후 해당 블록에 변경이 가해지지 않으면 정상적인 일관성 모드 읽기가 가능하다.

결론적으로 Delayed 블록 클린아웃에 의해 Snapshot too old 가 발생하는 원인은, 최저 커밋 SCN이 쿼리 SCN보다 높아질 정도로 갑자기 트랜잭션이 몰릴때 이다.

### Snapshot too old 회피방법

Undo 메커니즘을 도입한 배경은 Lock에 의한 동시성 저하를 방지하기 위함인데, 동시성을 높인 대신 발생하는 부작용이다.

Undo 세그먼트를 수동으로 관리하면 에러 발생을 최소화하기위해 Undo 튜닝도 직접 해야한다.

AUM이 되입돼 트랜잭션 발생 상황에 따라 UNDO 세그먼트 크기와 개수를 오라클이 동적으로 자동 조절해 준다.

애플리케이션 구현측면에서는 오라클만의 독특한 읽기 일관성 모델과 undo 메커니즘을 이해하는 것이 필수이다.

1. 불필요한 커밋을 줄인다.
2. fetch across commit 형태의 프로그램작성을 피한다. 커밋 이전에 열려있던 커서는 더이상 Fetch 하면 안된다.
3. 트랜잭션이 몰리는 시간대를 피한다.
4. 큰 테이블을 일정 범위로 나눠 읽고 단계적으로 실행할 수 있도록 코딩한다.
5. 같은 블록을 여려 번 방문하는 Nested LooP 조인을 피한다.
6. 소트부하를 감수하더라도 order by 등을 강제로 삽입해 소트연산이 발생하도록한다. 서버 내에서 데이터를 읽어 temp 세그먼트에 저장하는데 성공하면 같은 방문을 수차레 재방문해도 상관없다.

7. 대량 업데이트 후에 곧바로 해당 테이블에 대해 Full scan 하는 것도 해결바엉비 될 수 있다. 만약 인덱스 블록에서 문제가 발생한다고 판단되면 인덱스 리프 블록을 모두 스캔하도록 한다.
