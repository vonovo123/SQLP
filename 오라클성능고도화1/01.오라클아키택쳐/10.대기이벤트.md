오라클 인스턴스는 많은 프로세스들이 역할을 분담해 각자 맡은 바 임무를 수행한다. 프로세스 간 커뮤니케이션과 상호작용이 필요하고 때로는 다른 프로세스가 일을 마칠 때까지 기다려야한다.

오라클 프로세스는 일을 계속 진행할 수 있는 조건이 충족될 때까지 수면 상태에 빠진다. 이런 현상을 '대기 이벤트' 라고 부른다.

오라클은 그 상태정보를 파일 또는 SGA 메모리에 저장해 둔다.

대기 이벤트를 시스템 커널 레벨에서 설명하면, 프로세스가 할 일을 모두 마쳤거나 다른 프로세스를 기다려야 하는 상황에서 CPU를 쥔 채 대기하면 불필요하게 CPU 자원을 낭비하는 것이므로

CPU를 OS에 반환하고 수면 상태로 빠지는 것을 말한다.

wait queue에 놓인 프로세스에는 CPU를 할당할 필요가 없으므로 OS는 해당 프로세스를 스케쥴링 대상에서 제외한다.

선행 프로세스가 일을 마치면 OS에게 그 사실을 알려 자신을 기다리던 수면 상태의 프로세스를 깨우도록 신호를 보낸다. 그러면 OS는 그 프로세스를 runnable queue로 옮김으로써

가능한 빨리 CPU를 할당 받아 일ㅇ르 재개할 ㅅ 있도록 스케쥴링한다.

Reunable queue에서 CPU 리소스를 기다리는 프로세스의 수가 CPU 개수를 초과하고 CPU 사용률이100$를 근첩하면 CPU병목현상이 발생한 것이다.

Sleep 상태의 프로세스의 수가 많은 것도 병목일 수 있다. 오라클 입장에서는 대기 이벤트가 많이 발생한 것이므로 어떤 종류의 대기 이벤트가 발생 중인지 확인해야 한다.

### 대기 이벤트는 언제 발생할까?

대기 이벤트가 지속적으로 다량 발생하면 데이터베이스에 병목이 있음을 알리는 신호지만 모든 대기 이벤트가 그렇지는 않다.

서버 프로세스가 사용자의 명령이나 신호를 기다닐 때 나타나는 이벤트, 서버 프로세스가 관여하지 않는 이벤트 등은 데이터베이스 튜닝 시 무시해도 된다.

대기 이벤트가 발생하게 되는 상황은 아래와 같이 크게 3가지로 요약할 수 있다.

1. 자신이 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용 중일 때.

자신이 읽으려하는 버퍼에 다른 프로세스가 쓰기 작업을 진행 중이라면 선행 프로세스가 일을 마칠때 까지 기다려야 한다.

buffer busy waits, latch free, enqueue 관련 대기 이벤트가 여기 속한다.

2. 다른 프로세스에 의해 선행작업이 완료되기를 기다릴 때

DBWR가 Dirty 버퍼를 디스크에 기록할 때는 먼저 LGWR가 로그 버퍼에 있는 Redo entry 를 Redo Log 파일에 기록하는 작업이 선행되야 한다.

따라서 DBWR는 LGWR를 깨워 로그 버퍼를 비우라는 신호를 보내고 LGWR가 일ㅇ르 마칠 때까지 수면 상태로 대기한다.

LGWR가 일을 마치면 DBWR를 깨우고 자신은 다시 대기 상태로 빠진다.

write complete waits, checkpoint completed, log file sync, log file, swiathc 이벤트가 여기 속한다.

3. 할일이 없을 때

서버 프로세스는 쿼리 결과를 사용자에게 전송하는 동한 ARray 단위로 일을 처리하는데, Array 크기만큼 데이터를 전송하면 다음 Fetch call까지 기다려야 한다.

쿼리 결과집합을 모두 전송하고 나서도 다음 Parse Call 또는 Execute Call을 받을 때까지 기다린다.

또 다른 예로, 병렬 쿼리를 수행하면 자신이 맡은 일을 먼저 끝마치는 병렬 Slave 프로세스가 생기는데 그럴 때면 다른 Slave들이 일을 마칠 때까지 대기 상태로 기다린다.

### 대기 이벤트는 언제 사라질가?

선행 프로세스가 자신을 깨우지 않더라도 타이머에 설정된 시간이 도래하면 한번씩 깨어나 자신이 기다리던 리소스가 사용 가능해졌거나 해야할 일이 있는지 확인한다.

타임아웃 설정 값은 대기 이벤트마다 모두 다르다.

예를 들어, DBWR와 LGWR 간 상호작용에 의한 대기 이벤트 발생 시 타임아웃은 둘다 3초이다. 커밋할 때마다 LGWR를 깨워 REDO 버퍼를 비우도록 할 때 발생하는 타임아웃은 모두 3초로 설정된다.

커밋할 때마다 LGWR를 깨워 REDO 버퍼를 비우도록 할 때 발생하는 Log file sync 대기 이벤트의 타임아웃은 1초, buffer busy wait 대기 이벤트도 1초이다.

enqueue 관련 Lock 대기 이벤트의 타임아웃은 3초이다.

타임아웃에 의해 깨어났는데 리소스가 아직 사용중이거나 선행 프로세스가 아직 작업중이라면 다시 수면 상태로 빠지만.

타임아웃이 자주 발생한다면 대기 이벤트에 의한 지연 시간이 길어진다.

반대로 대기 중이던 이벤트가 활동을 재개하는 시점은 다음과 같다.

1. 대기 상태에 빠진 프로세스를 기다리던 리로스가 사용 가능해졌을 떄
2. 작업을 계속 진행하기 위한 선행작업이 완료될때.
3. 해야할 일이 생겼을때

### 래치와 대기 이벤트 개념 명확화

래치와 대기 이벤트는 구별되어야 한다.

래치를 얻는 과정 자체가 경합을 의미하지는 않는다. 공유된 자원을 읽으려면 래치를 얻어야함므로 v$latch 뷰에서 gets 횟수가 증가한다.

\- gets : 래치 요청 횟수를 말한다.
\- misses : 래치를 요청했는데 다른 프로세스에 의해 자원이 사용 중이어서 첫 시도에서 곧바로 래치를 얻지 못한 횟수
래치 Miss를 만난 프로세스는, spin 과정에서 래치 획득에 성공하거나 정해진 횟수만큼의 spin 후에도 래치획득에 실패해 대기상태로 간다.
gets에서 Misses 횟수를 빼면 다른 프로세스의 래치 해제를 기다리지 않고 획득에 성공한 횟수(simple_gets)가 구해진다.

\- spin_gets : 래치를 요청한 첫 번째 시도에서 곧바로 래치를 얻지는 못했지만 이후 spin 하는 과정에서 래치 획득에 성공한 횟수.
misses에서 sleeps를 뺀 횟수와 일치한다. 즉, 첫번째 시도에서 래치를 얻지는 못했지만 다행히 sleep 전에 래치를 얻게되는 경우이다.

\- sleeps : 래치를 요청했는데 자원이 사용 중이라 곧바로 래치를 얻지 못했고, 정해진 횟수만큼 계속 spin 했는데도 결국 래치를 얻지 못해 대기 상태로 빠진 횟수.
이때 latch free 대기 이벤트가 발생한다. 잠시 후에 깨어나 다시 spin을 했는데도 래치 획득에 실패하면 또다시 latch free 대기 상태로 빠지게 된다.

래치는 Lock 처럼 큐잉 메커니즘이 작동하지 않기 때문에 래치 획득에 성공할 때까지 반복적인 엑세스 시도가 있을 뿐, 우선권을 부여받지 못한다.
