블록 클린아웃은 트랜잭션에 의해 설정된 row Lock을 해제하고 블록 헤더에 커밋 정보를 기록하는 오퍼레이션이다.

오라클에서 로우 단위 Lock은 레코드의 속성으로 관리되며, 이는 로우 헤더로부터 블록 헤더에 있는 ITL 엔트리를 가리키는 포인터다.

트랜잭션을 커밋하고 블록 클린아웃까지 완료해야 완전한 커밋이라고 할 수 있다.

대량 갱신 작업이 있고 나서 커밋을 위해 해당 블록들을 찾아다니며 클린 아웃을 수행하려면 긴 시간이 소요된다.

오라클은 그래서 대량의 갱신 작업이 있고 나서는 커밋 정보를 트랜잭션 테이블에만 기록하고 커밋을 끝낸다.

나중에 해당 블록이 액세스되는 시점에 클린 아웃을 진행한다.

이처럼 오라클은 delayed 블록 클린아웃과 커밋 클린아웃 두 가지 메커니즘을 사용한다.

### Delayed 블록 클린아웃

트랜잭션이 갱신한 블록 개수가 총 버퍼 캐시 블록 수의 10%를 초과할 때 사용하는 방식이다.

커밋 이후 해당 블록을 액세스하는 첫 번째 쿼리에 의해 클린아웃이 이루어진다.

아래와 같은 작업을 수행한다.

1. ITL 슬롯에 커밋 정보 저장
2. 레코드에 기록된 Lock Byte 해재
3. online redo에 logging

블록을 읽는 과정에서 다른 트랜잭션이 발생시킨 변경사항에 대한 커밋 정보가 아직 ITL에 기록되지 않은 Active 상태라면 읽기 전에 먼저 블록 클린아웃을 시도한다.

ITL 슬롯에 기록된 트랜잭션 ID를 이용해 UNDO 세그먼트 헤더에 있는 트랜잭션 테이블 슬롯을 찾아가 트랜잭션의 현재 상태를 확인하고

커밋된 트랜잭션이라면 ITL 슬롯에 반영하고 로우 Lock 정보를 해제해 블롯을 클린아웃한다.

블록 크린아웃을 위한 갱신내용도 REDO에 로깅하며, 블록 SCN도 변경한다.

### 커밋 클린아웃

모든 클린아웃을 Delayed 블록 클린아웃 방식으로 처리하면 select 시에 블록을 클린아웃하는 일이 빈번하게 발생한다.

블록 클린아웃도 쓰기 작업이므로 Current 블록을 요청하게 된다. RAC에서는 Dirty 상태의 버퍼 블록을 디스크 쓰기 작업 없이 인스턴스끼리 주고받는 것이 가능하지만,
OPS 환경에서는 일단 Dirty 블록을 디스크에 기록하면 그것을 디스크에서 읽어간다. 이처럼 디스크를 거처 인스턴스간 블록을 주고받는 과정을 핑이라고 한다.

과도한 핑이 발생하는 문제를 해결하기 위해 커밋 클린아웃 방식이 도입됐다.

트랜잭션이 갱신한 블록 개사구 버퍼 캐시 블록 수의 10%를 초과하지 않을때 커밋 시점에 곧바로 블록 클린아웃을 수행한다. 버퍼캐시에서 밀려나면서 데이터파일에 기록됐거나 다른 트랜잭션에 의해

사용 중인 블록은 놔둠으로서 delayed 블록 클린아웃을 따르도록 한다.

다만, 이 경우에도 커밋 시점에는 불완전한 형태의 클린아웃을 수행하며 해당 블록을 갱신하는 다음 트랜잭션에 의한 완전한 클린아웃이 이뤄진다.

커밋 시점에는 ITL 블록에 커밋 정보만 저장하고 로우 헤더에 설정된 LOCK BYTE는 해제하지 않는다.

커밋 시점에 완전한 커밋 정보가 ITL에 기록돼있기 때문에 CR모드 읽기 시 커밋 여부와 커밋 SCN을 확인하기위해 트랜잭션 테이블을 조회하지 않아도 되고, LOCK BYTE를 무시하고 그대로 블록을 읽는다.

ITL 슬롯에 커밋 정보를 저장하면서 lock byte를 해제하지 않는 이유는 로깅을 수행하지 않기 위해서다.

커밋 클린아웃 시에는 Onlie redo 로그를 남기지 않는다. 해당 블록을 갱신하려고 current 모드로 읽는 시점에 비로소 Lock byte를 해제하고 완전한 클린 아웃을 수행한다. 그리고 그 내역을 online redo에 로깅한다.

블록 클린아웃 정보를 나중에 로깅한다는 의미에서 이를 delayed 로깅 블록 클린아웃이라고 부른다.

### ITL과 블록 클린아웃

ITL에 담긴 정보정보

LCK1 : 로우 헤더에 LOCK BYTE가 해제되지 않은 상태

FSC : FAST 클린아웃 상태.

Fsc 상태의 슬롯은 곧바로 재사용 될 수 없다. 쓰기 작업을 위해 블록이 읽히는 순간 Lock Byte를 해제하고 나서야 재사용이 가능하다.
