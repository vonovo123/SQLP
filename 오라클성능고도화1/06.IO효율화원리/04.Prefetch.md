오라클을 포함한 모든 DBMS는 디스크 블록을 읽을 때 곧이어 읽을 가능성이 높은 블록을 미리 읽어온다.

디스크 I/O의 비용이 크기때문에 한번의 I/O call을 통해 다량의 블록을 퍼 올릴 수 있다면 그만큼 성능향상에 도움이 되기 때문이다.

테이블 Prefetch, 인덱스 Prefetch와 Multiblock I/O가 다른 점은 한 익스텐트에 속한 인접한 블록들을 Prefetch 한다는 점이다.

Prefetch는 한 번에 여러 개 Single Block I/O를 동시 수행하는 것을 말한다.

Multiblock I/O는 한번의 I/O Call로써 서로 인접한 블록을 같이 읽어 적재하는 것을 말한다.

테이블 Prefetch, 인덱스 Prefetch는 인접하지 않은 블록, 즉 서로 다른 익스텐트에 위치한 블록을 배치 방식으로 미리 적재하는 것을 말한다.

I/O Call을 병렬 방식으로 동시에 여러 개 수행하는 것이므로, 읽어야 할 블록들이 서로 다른 디스크 드라이브에 위치한다면 Prefetch에 의한 성능 향상은 배가도니다.

이 기능은 곧 읽을 가능성이 높은 블록을 미리 적재했을때만 성능 향상에 도움을 준다. 미리 적재했는데 실제 사용으로 연결되지 못하면 버퍼 캐시 효율만 나빠진다.

오라클은 미리 적재했을 때 효과를 얻을 수 있는 오퍼레이션에만 이 기능을 적용하지만, 그럼에도 Prefeth 한 블록들이 실제 액세스로 연결되지 못한 채 캐시에서 밀려나는 비율이

높다면 더는 이 기능이 작동되지 못하도록 정지시킨다.

Prefetch 된 블록들은 모니터링하는 기능은 CKPT 프로세스가 맏는다.

앞으로 읽어야 할 블록을 미리 적재하는 기능이므로 I/O를 위한 시스템 Call을 줄이고 개별 쿼리의 수행 속도를 향상시키는 데 도움을 준다.

데이터 블록을 읽는 도중에 물리적인 디스크 I/O가 필요할 때면 서버 프로세스는 I/O 서브시스템에 I/O Call을 발생시키고 잠깐 대기 상태에 빠진다.

대기 상태에서 곧이어 읽을 가능성이 높은 블록들을 버퍼 캐시에 미리 적재해 놓는다면 대기 이벤트 발생횟수를 줄일 수 있다

Prefetch 는 db file parallel read 이벤트로 측정된다.

### Index Prefetch

브랜치 블록에서 앞으로 읽게 될 리프 블록 주소를 미리 얻을 수 있으므로 I/O call이 필요한 시점에 미리 캐싱해 두는 것이 가능하다.

인덱스 리프노드를 읽는 시점에 논리적으로 연결된 주변 블록까지 같이 적재해 놓는다면 인덱스 리프노드를 스캔하는 동안 디스크 I/O 때문에 대기할 가능성을 줄일 수 있따.

인덱스 Prefetch 기능이 가장 효과적일 수 있는 상황은 Index full scan이 일어날 때다.

부분범위처리 방식으로 중간에 멈추지 않는다면 모든 인덱스 리프 블록을 읽게 되기 때문이다.

그런데 Index Full Scan시 Prefetch 방식으로 I/O하려면 리프 블록 위치에 있는 브랜치 블록을 추가로 읽어야 하기 때문에 Prefetch 하지 않을 때보다 I/O가 약간 더 발생한다.

### 테이블 Prefetch

테이블 Lookup Prefetch 또는 데이터 블록 Prefetch 라고도 한다.

인덱스르 경유해 테이블 레코드를 액세스하는 도중 디스크에서 캐시로 블록을 적재해야하는 상황이 발생할 수 있는데,

그때 다른 테이블 블록까지 미리 적재해 두는 기능이다.

리프블록에 있는 인덱스 레코드를 논리적 순서를 따라 읽는다.

읽는 도중에 디스크 I/O가 필요해지면 현재 읽던 리프 블록 내에서 앞으로 액세스해야 할 테이블 블록 주소를 미리 취합할 수 있다.

RANDOM ACCESS 성능을 향상시키기위해 버퍼 Pinning과 테이블 Prefetch 같은 기능을 사용한다.

버퍼 Pinning은 Random Access에 의한 블록 요청 횟수를 감소시키고, 테이블 Prefetch는 디스크 I/O에 의한 대기 횟수를 감소시킨다.

이 기능은 인덱스 클러스터링 팩터가 나쁠때 효과를 발휘한다. 클러스터링 팩터가 나쁘면 논리적 I/O가 증가할 뿐아니라 디스크 I/oEhgks aksgdl qkftodgkrl Eoansdelk.
