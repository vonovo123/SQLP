데이터베이스 동시 사용자가 많을 때 부하를 분산할 목적으로 시스템마다 다양한 데이터 분산 전략을 사용한다.

1. DB 서버 간 복제
2. 업무별 수직 분할
3. 데이터 구분에 따른 수평분할

1번은 여러 대의 데이터베이스 서버를 두고 각 서버에서 발생한 트랜잭션 데이터를 상호 복제하는 방식으로, 실시간 동기화가 필요할 때는 복제 과정에서 발생하는 부하로 인해

부하 분산 효과를 얻기 힘들다.

2번은 업무별로 DB를 따로두고 각각 다른 테이블을 관리하며, 다른 영역의 데이터는 분산 쿼리를 이용해 조회하는 방식이다.

분산 쿼리로 자주 액세스되는 공통 영역의 범위에 따라 성패가 좌우된다.

3번은 스키마는 같지만 데이터구분에 따라 DB를 따로 가져가는 방식을 말한다.

전국 고등학생의 수험정보를 관리하는데 테이블 구조는 같지만 시도에 따라 DB를 나누어 관리하는 것이다.

분할된 데이터 간 의존성이 낮을 때( 함께 조회되는 일이없고, 관계를 같는 테이블도 같은 기준으로 분할이 가능할떄)

성공적인 모델이지만 서버 간 데이터 이동이 발생할 때 처리방안 마련이 필요하다.

물리적으로 분산시킨 데이터를 논리적으로 다시 통합해 하나의 뷰를 통해 액세스 할 수 있도록 데이터베이스를 클러스터링 하는 기법도 발전해 왔다.

데이터베이스를 하나로 통합하고 이를 액세스하는 인스턴스를 여러 개 두는 공유 디스크 방식의 데이터베이스 클러스터링 기법이 도입됐다.

그 중 오라클 RAC 모델은 공유 디스크 방식에 기반을 두면서 인스턴스 간 버퍼 캐시까지 공유하는 캐시 퓨전 기술로 발전했다.

하나의 데이터베이스를 여러 원격 인스턴스가 공유한다.

데이터를 하나의 데이터베이스에 통합 모델로 관리함으로써 높은 정합성을 유지할 수 있다는 것이 장점이다.

튜닝이 잘 되지 않아 많은 블록 I/O를 일으키는 애플리케이션에서 RAC를 도입하면 단일 인스턴스 환경에서보다 더욱 심한 성능저하를 일으킨다.

여러 인스턴스에 놓인 프로세스끼리 하나의 데이터를 동시에 쓰려는 경합이 심하게 발생하기 대문이다.

그런 동시 액세스르 직렬화하려면 추가적인 동기화 메커니즘이 필요하고, 새로운 성능이슈가 발생한다.

RAC는 글로벌 캐시 개념을 사용한다.

클러스터링 돼 있는 모든 인스턴스 노드의 버퍼 캐시를 하나의 버퍼 캐시로 간주한다.

따라서 필요한 데이터 블록이 로컬 캐시에 없더라도 다른 노드에 캐싱돼 있다면 디스크 I/O를 일으키지 않고 가져와 읽고 쓴다.

모든 데이터 블록에 대해 마스터 노드가 정해져 있고, 그 노드를 통해 글로벌 캐싱돼 있는 블록의 상태와 Lock 정보를 관리한다.

마스터 노드는 각 블록주소의 해시 값에 의해 인스턴스가 기동되는 시점에 동적으로 정해진다.

캐시 퓨전 원리는 읽고자 하는 블록이 로컬 캐시에 없을때 마스터 노드에 전송 요청하고, 마스터 노드는 해당 블록을 캐싱하고 있는 노드에 메시지를 보낸다.

그 블록을 요청했떤 노드에 전송을 지시하는 방식이다. 만약 어느 노드에도 캐싱돼 있지 않다면 직접 디스크에서 읽도록 권한을 부여한다.

Current 블록은 디스크로부터 읽혀진 후 사용자의 갱신사항이 반영된 최종 상태의 원본 블록을 말하며, CR 블록은 Current 블록에 대한 복사본이다.

CR 블록은 여러 버전이 존재할 수 있지만 Current 블록은 오직 한개이다

RAC 환경에서 Current 블록은 Shared 모드 Current 와 Exclusive 모드 Current로 나뉜다.

Shared 모드 상태의 블록은 동시에 여러 노드에 캐싱될 수 있지만 Exclusive 상태의 블록은 단 하나의 노드에만 존재할 수 있다.

자주 읽히는 데이터 블록을 각 노드가 SCur 모드로 캐싱하고 있을때 가장 효율적인 상태가 된다.

그 중 한 노드가 XCur 모드로 업그레이드되면 다른 노드에 캐싱돼 있단 SCur 블록은 모두 Null 모드로 다운그레이드 된다.

### 전송없는 읽기

A 노드에서 K 블록을 읽으려는데, K노드는 현재 어떤 노드에도 캐싱돼 있지 않은 상태이다.

K블록의 SCN은 123이다.

1. K 블록을 읽으려고 하는 A 노드는 그 블록의 리소스 마스터인 B노드에게 전송 요청을 보낸다. 이때 gc cr request 이벤트에서 대기한다.

2. B노드는 현재 어떤 노드에서도 K 블록을 캐싱하고 있지 않음을 확인하고, A노드에게 데이터파일에서 직접 블록 SCur 모드로 읽도록 권한을 부여한다.

3. A노드는 디스크에서 블록을 읽어 로컬 캐시에 캐싱한다.

### 읽기/읽기 전송

A 노드만 K 블록을 SCur 모드로 캐싱한 상태에서 C 노드가 같은 K 블록을 SCur 모드로 읽으려고 한다.

1. C 노드는 마스터 B 노드에 K 블록에 대한 전송요청을보낸다. 이때 gc cr request 이벤트를 대기한다.

2. Bㅗ노드는 현재 K 블록을 A 노드가 캐싱하고 있음을 확인하고, C 노드에 블록을 정송하도롤 A노드에 지시한다.

3. A노드는 C노드에게 블록을 전송해준다.

4. C노드는 전송받아 SCur 모드로 캐싱햇음을 B노드에 알린다.

### 읽기/쓰기 전송

A와 C 노드 모두 K 블록을 SCur 모드로 캐싱하고 있다.

C노드가 갱신을 위해 K 블록을 XCur 모드로 업그레이드하려 한다.

1. 마스터 노드인 B에게 K 블록에 대한 업그레이드를 요청한다.

2. B노드에 현재 K 블록을 A 노드도 캐싱하고 잇ㅇ므을 확인하고 Null 모드로 다운그레이드하도록 지시한다.

3. A 노드는 C노드에게 Null 모드로 다운그레이드 했음ㅇ르 알린다.

4. C 노드는 K 블록을 XCur 모드로 업그레이드하고 그 결과를 마스터 노드인 B에게 알린다. 이때 A 노드에 캐싱된 블록이 Null a모드로 다운 그레이드 된 사실도 함께 알린다.

이제 C노드가 XCur모드로 K블록을 읻고 변경을 가하므로 블록 SCN은 증가한다.

### 쓰기/쓰기 전송

현재 A노드는 K 블록을 Null 모드로 갖고 있고 C 블록은 XCur 모드로 갖고있다.

C 노드가 갖고있는 Currnt 버전의 SCN은 154로 증가했다.

데이터파일에 있는 블록 SCN은 아직 123이므로 Dirty 버퍼 생테이다.

이때 A 노드가 K 블록을 XCur 모드로 읽으려 한다.

1. 마스터 노드에 B에게 K 블록을 XCur 모드로 요청한다.

2. B노드는 K블록을 C노드가 XCur 모드로 캐싱하고 있음을 확인하고 A노드에게 보내도록 지식한다.

3. C노드는 A 노드에게 블록을 전송하고 자신이 갖고있던 블록은 NULL모드로 다운 그레이드 한다.

C 노드가 갖고 있던 XCur 블록은 아직 커밋되지 않아 로우 Lock에 걸린상태이다.

4. A노드는 K 블록을 XCur 모드로 캐싱하게 됐음을 B노드에게 알린다.

다른 인스턴스가 갱신 중인 블록을 읽고자 할 때 로우Lock 이 해제될때까지 기다리지 않고 로우 Lock이 설정된체 블록을 주고 받는다.

RAC에서는 디스크 동기화 없이 로우 Lock이 설정된 채로 버퍼 캐시간 블록이 전송가능하다.

이전에는 쓰기/쓰기 전송상황에서는 C 노드는 일단 블록을 디스크에 기록한다. A노드는 이를 디스크에서 읽는다. 디스크럴 거쳐 블록을 주고 받는 과정을 핑이라고 한다.

A 노드가 XCur 모드로 K블록을 얻고 변경을 가하므로 블록 SCN은 증가한다.

### 쓰기/읽기 전송

현재 A노드는 K 블록을 XCur 모드로 갖고있고 C 노드는 null 모드로 갖고 있다.

A 노드의 K블록은 Current 버전으로 SCN은 168이고 데이터 파일에 있는 블록 SCN은 123 으로 Drity 버퍼 상태이다.

이때 C 노드가 K 블록을 SCur 모드로 읽으려고 한다.

1. 마스터노드인 B에게 K 블록을 SCur 모드로 요청한다.

2. B 노드는 현재 K 블록을 A노드가 XCur모드로 캐싱하고 있음을 확인하고, C노드에게 보내 주도록 지시한다

3. A노드는 C노드에게 블록을 전송하고 자신이 갖고 있는 블록은 sCur모드로 다움그레이드한다.

4. C 노드는 K 블록을 SCur 모드로 캐싱했음ㅇ르 B노드에게 알리고 A 노드에 캐싱된 블록ㅇ르 sCur모드로 다운그래이된 사실깢 ㅣ알려준다.

K 블록의 커밋 여부에 따라 다른데, 아직 커밋되지않았다면 Current 블록을 전송하는것ㅇ ㅣ나리다 Cr Copy를 만들어 전송한다.

C 노드는 읽기작업을 원하므로 굳이 Current 블록ㅇ르 보낼 필요가 ㅇ벗다.

A노드에서 갱신이 진행중이므로 Current 볼륵을 보내면 언젠가 다시 가져와햐 하기때문에 그렇게 처리한다.

K 블록이 커밋된 상태라면 처음에 CR Cpoy를 보내다가 일정 횟수 이상 요청이 반복적으로 들어오면 그때 Current 블록ㅇ르 보낸다.

Current 블록을 보내주려면 Xcur 모드를 SCur로 다운그래이드 해야하는데, 곧이어 갱신이 다시 발생하면 XCur 모드로 다시 업그레이드해야하는 일이 ㅂ라생한다.

그때는 SCur 블록을 가져갔떤 다른 노드도 모두 Null로 다운 그래이드 해야하므로 이런 일이 자주 발생하면 부하가 증가한다.

CR CPoy를 보내주는 횟수는 \_airness_threshold 파라미터에 의히 결정되며, 기본 값은 4이다.

커밋된 XCur 블록을 보유하고 있는 노드는 블록 전송요청을 받을때마다 CR Copy를 만들어 전송하고, fairness_count 값을 1씩 증가 시킨다.

파라미터 만큼의 값에 도달하면 Redo 로그 버퍼를 비우고 XCurd을 SCur로 다운그레이드한다.

읽기 요청을 보낸 노든느 곧바로 SCur 모드로 블록을 전송받는다.

읽기 작업 위주라면 파라미터를 낮게 설정하는 것이 좋다. 0이면 CR Copy 전송없이 곧바로 다운그래이하고 Current q블록을 전송한다.

Xcur모드를 SCur로 다운그레이드 했다가 또 다시 XCur로 업그레이드할 가능성이 적으면 가급적 빨리 SCur 모드로 보내주는 것이 좋다.

퓨전 원리에 따르면 RAC를 구성할 때 데이터를 가공하는 노드와 읽는 노드를 분리하는 것이 성능에 안좋다는 사실을 알 수 있다.

블록 읽기 요청횟수를 줄여 인터커넥트르 통한 데이터 전송량을 감소시키는 것이 가장 확실하고 근본적인 해결첵이다.
