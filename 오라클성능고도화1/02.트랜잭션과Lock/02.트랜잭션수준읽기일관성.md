### 트랜잭션 수준 읽기 일관성이란?

문장수준 읽기 일관성은 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것을 말한다.

트랜잭션 수준 읽기 일관성은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것을 말한다.

트랜잭션이 진행되는 동안 다른 트랜잭션에 의해 변경사항이 발생하더라도 이를 무시하고 계속해서 일관성 있는 데이터를 보고자하는 업무요건이 있을 수 있따.

물론 트랜잭션이 진행되는 동안 자신이 발생시킨 변경사항은 읽을 수 있어야 한다.

오라클은 완벽한 문장수준 읽기 일관성을 보장하지만, 트랜잭션에 대해서는 기본적으로 보장하지 않는다.

다른 dbms도 트랜잭션 수준의 읽기 일관성은 보장하지 않는다.

트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야 한다.

### 트랜잭션 고립화 수준

ANSI 기준으로 정의된 네 가지 트랜잭션 고립화 수준은 다음과 같다.

#### Level 0 (Read Uncommitted)

트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용

Dirty Read, Non-Repeatable Read, Phantom Read 현상 발생하고 Oracle은 이 레벨을 지원하지 않는다.

#### Level 1 (Read Committed)

Dirty Read를 방지하기위해 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용한다.

대부분의 DBMS가 기본모드로 채택하고 있는 일관성 모드이다.

Non-Repeatable Read와 Phantom Read 현상은 여전히 발생한다.

DB2, SQL Server, Sysbase의 경우 읽기 공유 Lock을 이용해 구현한다.

하나의 레코드를 읽을 때 Lock을 설정하고 해당 레코드를 빠져나가는 순간 Lock을 해제한다.

OracLe은 Lock 을 사용하지 않고 쿼리시작 시점의 UNDO 데이터를 제공하는 방식으로 구현한다.

#### 레벨 3 (Serializable)

선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐아니라 중간에 새로운 레코드를 삽입하는 것도 방지한다.

이를 통해 완벽한 읽기 일관성 모드를 제공할 수 있다.

DBMS에서 제공하는 트랜잭션 고립화 수준 조정기능을 이용해 트랜잭션 레벨 읽기 를 확보하려면 다음 명령어를 실행하면 된다.

```sql
set transaction isolation level serializable;
```

낮은 단계의 트랜잭션 고립화 수준을 사용할때 발생하는 세 가지 현상이 있다.

#### Dirty Read

아직 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생한다.

다른 트랜잭션에 의해 레코드의 값이 변경되면 쿼리의 최종 결과 값이 비일관성 상태에 놓이게 된다.

값을 변경한 트랜잭션이 어떤 이유에서건 롤백 될 수 있기 때문이다.

대부분의 DBMS가 기본 트랜잭션 고립화 수준을 레벨 1로 설정하고 있기 때문에 Dirty Read 현상은 발생하지 않는다.

즉, 커밋된 데이터만 읽을 수 있도록 허용한다.

SQL Server, Sysbase 등은 이를 구현하기 위해 데이터를 읽을 때 공유 Lock을 사용한다. 갱신 중인 레코드에는 베타적 Lock이 걸리는데, 이는 공유 Lock과

호환되지 않는 lock으로 갱신 중인 레코드를 읽지 못한다.

그런 DBMS에서는 Lock에 의한 동시성 저하가 자주 문제시되므로 쿼리에 옵션을 넣어 Dirty Read를 허용하는 프로그래밍을 하곤 한다.

즉 트랜잭션 고립화 수준의 레벨을 0으로 낮추는 것이다.

하지만 오라클은 다중 버전 읽기 일관성 모델을 채택함으로써 Lock을 사용하지 않고도 Drity Read를 피해 일관성 있는 데이터 읽기가 가능하고 따라서 Level 0 수준으로 트랜잭션 고립화 수준을
낮추는 방법을 아예 제공하지 않는다.

\- Non-Repeatable Read

한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말한다.

Non-Repeatable Read 현상을 방지하기 위해선 Select 문장에 for update를 추가해야한다.

레코드에 lock을 걸어 다른 트랜잭션의 접근을 블로킹 했다가 커밋하는 시점에 진행하도록 한다.

\- Phantom Read

한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에 나타나는 현상을 말한다.

트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타나는 현상이다.

Phantom Read 현상을 방지하려면 트랜잭션 고립화 수준을 레벨 3으로 올려야한다.

고립화 수준을 레벨 3으로 높히면, SQL SERVER에서는 Lock을 통해 t2 시점에 새로운 고객이 추가되는 것을 막는다.

반면 오라클은 Lock 을 사용하지 않은 상태에서 1번과 2번 쿼리 모두 SCN 확인 과정을 통해 t1 시점에 존재했던 고객만을 대상으로 집계를 수행하므로 동시성과 일관성을 유지한다.

---

### SERIALIZABLE_ABORTS

오라클은 For Update절을 사용하지 않는 한 절대 select 문에 Lock을 사용하지 않는다.

레벨을 상향 조정하더라도 이전과 동일한 동시성을 보장한다.

높은 일관성 수준에서도 높은 동시성을 제공할 수 있는 이유는 undo 데이터를 활용하기 때문이다.

단, 만약 트랜잭션 레벨에서 일관성 있는 데이터를 제공할 수 없는 상황이 발생하면 다른 DBMS에는 없는 에러를 던지게 된다.
ㄱ
