오라클은 공유리소스와 사용자 데이터를 보호할 목적으로 DML LOCK, DDL LOCK, 래치, 버퍼 LOCK, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.

래치는 SGA에 공유돼있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock이다.

버퍼 Lock은 버퍼 블록에 대한 액세스를 직렬화하기위해 사용한다.

라이브러리 캐시 Lock 과 라이브러리 캐시 Pin은 공유된 오브젝트 정의, 커서, PL/SQL프로그램 같은 실행가능한 오브젝트에 대한 정의 및 실행계획을 보호하낟.

라이브러리 캐시 Lock은 라이브러리 캐시 오브젝트에 대한 핸들을 보호하고 라이브러리 캐시 Pin은 라이브러리 캐시 오브젝트의 실제 내용이 담긴 힙을 보호한다.

애플리케이션 개발측면에서 가장 중요하게 다루어야할 Lock은 DML LOCK이다.

다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호한다. DML LOCK에는 테이블 LOCK과 로우 LOCK이 있다.

DML 테이블 LOCK은 ENQUEUE LOCK으로 구현한다.

DML 로우 LOCK은 로우 단위 LOCK과 트랜잭션 LOCK을 조합해서 구현한다.

DML Lock을 이해하기 위해선 Enqueue Lock 과 Transaction Lock의 개념을 이해해야 한다.

### Enqueue Lock

공유 리소스에 대한 액세스를 관리하는 Lock 메커니즘이다.

Enqueue에 의해 보호되는 공유 리소스로는 테이블, 트랜잭션, 테이블스페이스, 시퀀스, Temp 세그먼트 등이 있다.

Enqueue Lock은 래치와 달리 순서가 보장되는 큐 구조로 대기자 큐에 가장 먼저 Lock을 요청한 세션이 가장 먼저 Lock을 획득한다.

Enqueue Lock으로 관리되는 공유 리소스에 대해 Lock을 획득하려면 먼저 Enqueue 리소스를 할당받아야한다.

Enqueue 리소스는 소유자, 대기자의 목록을 관리할 수 있는 구조체이다.

Enqueue 리소스에는 고유한 식별자가 부여되며, 식별자는 Type-ID1-ID2로 구성된다.

오라클은 Enqueue 리소스 구조체를 통합 관리하는 리소스 테이블을 갖고있다.

리소스 테이블에서 관리되는 각 리소스를 찾을 때는 해싱알고리즘을 사용한다.

해싱 키로 리소스 식별자가 사용된다.

Enqueue 방식으로 관리되는 특정 리소스에 대해 Lock을 획득하려면 리소스 테이블에서 해당 리소스 구조체를 찾는다.

리소스 구조체의 소유자 목록에 자신을 등록한다.

호환되지 않는 모드로 먼저 Lock을 획득한 세션이 있다면 Lock 요청 대기자 목록에 등록하고 대기해야 한다.

소유자가 Exclusive 모드라면 한 순간에 하나의 세션만 Lock을 획득할 수 있지만, Shared mode는 여러 세션이 동시에 Lock을 획득할 수 있다.

Exclusive 모드로 Lock을 획득하려는 새션은 소유자가 있을 경우 항상 대기자 목록에서 대기해야하며, 하나의 리소스 구조체 대기자 목록에 동시에 여러 세션이

등록된 상태로 대기할 수도 있다.

Enqueue Lock의 작동 메커니즘은 아래와 같다.

1. A 세션이 Shared mode로 lock을 획득한다.
2. B 세션이 Shared mode로 Lock을 획득하려고하면 소유자인 A 세션과 호환되므로 정상적으로 Lock을 획득한다.
   소유자 목록에는 두 개의 세션이 달려있따.
3. C 세션이 Exclusive 모드로 Lock을 획득하려한다. Shared mode와 Exclusive 모드 간에 호환성이 없으므로 대기자 목록에 자신을 등록하고 대기한다.
4. 소유자 목록에 Shared mode로 달려있던 A,B 두 세션모두 Lock을 해제하면 C 세션이 Exclusive 모드로 소유자 목록에 등록된다.
5. A 세션이 Exclusive 모드로 다시 Lock을 획득하려고 하면, Exclusive 모드와 호환되지 않으므로 대기자 목록에 등록하고 대기한다.
6. B 세션이 다시 Shared 모드로 Lock을 획득하려고 할 때도, Exclusive 모드와 호환되지않음므로 대기자 목록에 자신을 등록하고 대기한다.
7. Enqueue lock은 순서가 보장되므로 C 세션이 Lock을 해제하면 A 세션이 가장먼저 Exclusive lock을 획득한다.

### TX Lock

트랜잭션을 시작하려면 undo segment header에 위치한 transaction table로 부터 slot을 1개 할당받아야한다.

이 트랜잭션이 변경을 가한 블록에 대한 Consistent 버전을 얻으려는 다른 트랜잭션은 트랜잭션 슬롯에 기록된 상태 정보를 확인하고, 필요하다면 CR 블록도 생성해서 읽는다.

이를 통해 레코드가 갱신 중이더라도 읽기 작업에 대해서는 블로킹 없이 작업을 진행할 수 있다.

하지만 변경중인 레코드를 동시에 변경하려는 트랜잭션에 대해서는 엑세스를 직렬화해야하며 그 목적으로 사용하는 Lock 메커니즘이 트랜잭션 Lock 이다.

TX Lock은 트랜잭션이 첫 번째 변경을 시작할 때 얻고, 커밋 또는 롤백할때 해재한다.

Tx Lock도 Enqueue Lock으로 구현됐다. Tx lock을 위한 Enqueue 리소스 구조체의 식별자는 다음과 같은 정보를 포함한다.

\- Type : Tx
\- ID1 : UNDO 세그먼트 + 트랜잭션 슬롯번호
\- ID2 : 트랜잭션 슬록 Sequence 번호

이 식별자를 갖는 리소스 구조체를 Enqueue 리소스 테이블 해시 체인에 연결하고, 소유자 목록에 트랜잭션을 등록함으로써 Lock을 획득한다.

1. Tx1 트랜잭션은 UNDO 세그먼트에서 트랜잭션 슬롯을 할당받고, Enqueue 리소스를 통해 Lock을 설정한다. r1~r5 5개의 레코드를 변경하고 커밋하지않는다.

2. Tx2 트랜잭션도 트랜잭션 테이블에서 하나의 슬롯을 할당받고 Enqueue 리소스를 통해 Tx Lock을 설정한 후 r6 레코드를 변경하나.

3. Tx2가 r3레코드를 액세스하려는 순간 호환되지 않은 모드로 Lock이 걸려있음을 인지하고 TX1 트랜잭션의 슬롯 상태를 확인하다.

4. Tx1이 Active 상태이므로 T2는 Tx1이 LocK을 설정한 Enqueue 리소스 구조체 대기자 목록에 자신을 등록하고, 대기상태로 들어간다.

5. Tx2는 대기하며 3초마다 한번씩 Tx1이 설정한 TxLock의 상태를 확인한다. 교착상태 발생여부를 확인하기 위함이다.

6. Tx1이 커밋 또는 롤백되면, Tx1이 설정한 TxLock의 대기자 목록에 가장 우선순위가 높은 Tx2 트랜잭션을 깨워 재개하도록 한다.

7. Tx2는 R3 레코드를 변경한다.

TX lock의 발생원인은 6가지이다

\- DML 로우 Lock
\- 무경설 제약 위배 가능성
\- 비트맵 인덱스 엔트리 갱신
\- ITL 슬롯 부족
\- 인덱스 분할
\- 기타

## TX LOCK > 무결성 제약 위배 가능성 또는 비트맵 인덱스 엔트리 갱신

로우 Lock 경합은 일반적으로 update나 delete 시에만 발생한다.

insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock 경합이 발생하지 않는다.

하지만 테이블에 Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 발생할 수 있다.

두 개 이상 트랜잭션이 같은 값을 입력하려 할 때, 선행 트랜잭션이 아직 진행중이라면 값의 중복여부가 확정되지 않았으므로 후행 트랜잭션은 대기해야만 한다.

dept table deptno 컬럼에 pk 인덱스가 생성돼 있는 상황에서 두 트랜잭션이 다음과 같이 진행하면,

enq:TX - row lock contention 대기 이벤트가 Shared 모드로 발생한다.

1. TX1이 Dept table에 deptno = 40 인 레코드를 입력한다.
2. TX2도 dept 테이블에 deptno = 40인 레코드를 입력하면, Tx1이 커밋 또는 롤백할 때 까지 Shared mode로 enq:tx - row lock contetion 대기 이벤트가 발생한다.
3. Tx1이 커밋하면 Tx2는 ORA-00001 에러를 만난다.
4. Tx1이 롤백하면 Tx2는 정상으로 입력된다.

dept 와 emp가 1:M 관계이고, deptno 컬럼으로 dept.deptno를 참조하도록 emp 테이블에 FK 제약이 설정돼 있다.

이때 두 트랜잭션이 아래와 같이 진행되면 마찬가지로 enq:TX - row lock contention 가 Shared 모드로 발생한다.

1. Tx1이 Dept 테이블에 deptno = 40인 레코드를 지운다.
2. Tx2가 emp 테이블에 deptno = 40인 레코드를 입력하면, Tx1이 커밋 또는 롤백할 때까지 enq:TX - row lock contention 대기 이벤트가 발생한다.
3. Tx1이 커밋하면 Tx2는 무결성 제약조건 에러를 만난다.
4. Tx1이 롤백하면 Tx2는 정상적으로 입력된다.

비트맵 인덱스 엔트리에 대한 갱신을 수행할 때도 Shared 모드로 enq:TX - row lock contention 이벤트가 발생할 수 있다.

비트맵 인덱스는 구조상 하나의 엔트리가 여러 개의 레코드와 매핑된다. 하나의 엔트리에 Lock을 설정하면 매핑되는 레코드 전체에 Lock이 설정되므로,

비트맵 인덱스 엔트리를 두 개 이상 트랜잭션이 동시에 갱신할 때 이 이벤트가 자주 발생한다.

Tx1 트랜잭션이 1번 레코드를 갱신하는 동안 Tx2 트랜잭션이 2번 레코드를 갱신하려고 할 수 있는데 이때 enq:TX - row lock contention가 Shared 모드로 발생한다.

## TX Lock > ITL 슬롯 부족

블록에 레코드를 추가/갱신/삭제하려면, ITL 슬롯을 먼저 할당 받고 그 곳에 트랜잭션 ID를 기록해야 한다. 비어있는 ITL 슬롯이 없다면, ITL 슬롯을 사용 중인 트랜잭션 중 하나가 커밋 또는 롤백할 때까지

기다려야하며, 이때 Shared 모드 enq:Tx - allocate ITL enyty 대기 이벤트가 발생한다.

한 블록을 동시에 갱신할 수 있는 트랜잭션 개수는 ITL 슬롯에 의해 결정된다. ITL 슬롯당 24바이트의 공간을 차지한다.

블록에 기본적으로 할당할 ITL 슬롯 개수는 INITRANS 파라미터로 설정한다.

```sql
create table t (...) initrans 5 maxtrans 255 pctfree 30;
```

PCTFREE는 원래 컬럼 update를 위해 예약된 공간이다.

하지만 INITRANS에 의해 미리 할당된 ITL 슬롯이 모두 사용 중일 때, 새로운 트랜잭션이 ITL 슬롯을 요청하면 PCTFREE 설정에 의해 비워둔 공간을 활용한다.

이 공간까지 활용해 최대한 생성할 수 있는 ITL 슬롯 개수는 MAXTRANS에 의해 결정된다.

ITL 슬롯 부족에 의해 대기현상이 발생했다면, 아래 둘 중 하나에 해당한다.

\- 동시에 블록을 갱신하려는 트랜잭션 개수가 MAXTRANS 값을 초과
\- PCTFREE를 0으로 지정했거나 PCTFREE 예약 공간을 모두 사용한 상태에서, 새로운 트랜잭션을 위한 ITL 슬롯이 부족

테이블에 insert 할때는 ITL 슬롯이 부족하더라도 굳이 대기할 필요가 없다. 새 블록을 할당해 그 곳에 insert 하면 되기 때문이다.

하지만 인덱스에 값을 삽입할 때는 정렬을 유지해야하므로 여전히 ITL 경합이 발생한다.

update, delete 일 때는 테이블, 인덱스를 불문하고 ITL 경합이 나타날 수 있다.

INITRANS, MAXTRANS 설정과 관련해, 오라클 버전이 올라가면 조금씩 변화가 없었다. 9i부터는, 테이블에 INITRANS를 3보다 작게 설정하더라도 오라클이 기본적으로 3을 할당한다.

10g 에서는 MAXTRNS를 위해 사용자가 지정한 값은 무시되며 항상 255개로 고정된다.

PCTFREE에 의해 예약된 공간이 update에 의해 모두 사용되고나면 여진히 ITL 경합이 발생할 수 있다.

ITL 경합에 의한 대기 현상이 자주 발생하는 세그먼트에 대해서는 INITRANS를 늘려줘야하며, 그런 세그먼트 목록은 v$segstat를 통해 확인할 수 있다.

INITRANS 값을 변경하덜다ㅗ 기존에 할당된 블록의 ITL 슬롯개수는 변함이 없고, 새로 할당되는 블록에만 적용된다. 따라서 기존 블록에 ITL 경합이 빈번하게 발생한다면,

테이블 또는 인덱스 전체를 재생성해야한다.

```sql
alter table t move INITRANS s;
alter index t_idx rebuild INITTRANS 5;
```

## TX LOCK > 인덱스 분할

테이블은 레코드간 정렬 상태를 유지하기 않기 때문에 입력할 공간이 부족할 때 새로운 블록을 할당 받아 입력하면 된다.

하지만 인덱스는 정렬된상태를 유지해야하므로 아무 블록에나 값을 입력할 수 없다.

따라서 새로운 값을 입력할 빈공간이 없으면 인덱스 분할을 실시해 새 값을 입력할 공간을 확보해야하고 이 과정에서 LOCK이 발생한다.

인덱스 분할이 진행되는 동안 그 블록에 새로운 값을입력하려는 트랜잭션이 발생할 수 있다.

그러면 두번 째 트랜잭션은 선행 트랜잭션이 인덱스 분할을 완료할 때까지 대기해야하며, Shared 모드 enq:Tx - index contention 이벤트가 발생한다.

TX LOCK은 선행 트랜잭션이 커밋 또는 롤백할 때 해제되는데, 만약 인덱스 분할을 진행한 트랜잭션이 커밋하지 않은체 계속 다른 갱신작업을 진행하면

TX Lock을 대기하던 트랜잭션은 어덯게 될까?

1. TX1 트랜잭션이 인덱스에 로우를 삽입하려는 순간 빈 공간을 찾지 못했다. 인덱스 분할이 필요하다.

2. TX1 트랜잭션은 autonomouse 트랜잭션 TX2를 생성해 인덱스 분할을 진행하도록 한다.

3. 인덱스 분할이 진행 중인 블록에 TX3 트랜잭션이 로우를 삽입하려고하면 TX-index contention 이벤트를 만나게 되고, TX2 트랜잭션이 커밋할 때까지 대기한다.

4. 인덱스 분할이 완료되면 TX2 트랜잭션은 커밋한다. autonomous 트랜잭션이므로 TX1은 커밋되지 않은 상태로도 계속 트랜잭션을 진행할 수 있다.

5. TX3 트랜잭션도 작업을 재개한다.

인덱스 분할 최소화 방안으로 PCTFREE를 증가시키면 된다고 알려져 있다.

이는 일시적인 방안이다.

인덱스에서 PCTFREE 설정은 인덱스를 처음 생성하거나 재생성하는 시점에만 적용되기 때문이다.

인덱스를 생성하는 시점에, 나중에 발생할 insert를 위해 공간을 남겨두는 것이므로 인덱스 분할을 최소화할 목적으로 제공되는 기능은 맞다.

하지만 공간을 남겨두더라도 언젠가 다시 채워짐로, 인덱스를 주기적으로 재생성하지 않는 한 근본해결책은 아니다.

## TX LOCK > 기타 트랜잭션 LOCK

Shared 모드 enq:TX -contention 대기 이벤트는 분산 트랙잭션에서 2-Phase 커밋을 위한 PREPARED TX LOCK을 대기할 때 발생한다.

읽기 전용 테이블스페이스로 전환할 때도 TX LOCK 경합이 발견된다. USERS 테이블 스페이스에 DML에 수행하는 트랜잭션이 아직 남아있는 상태에서 아래 명령을 수행하면 SHARED MODE TX LOCK을 대기한다.

## TX Lock > DML ROW LOCK

DML LOCK은 다중 사용자에 의해 동시에 액세스되는 사용자 데이터 무결성을 보호해 준다.

DML 수행 중에 호환되지 않는 다른 DML 또는 DDL 오퍼레이션의 수행을 방지한다.

그 중 로우 Lock은, 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다.

하나의 로우를 변경하려면 로우 Lockㅇ르 먼저 획득해야 한다.

오라클은 로우 lock을 로우단위 lock과 Tx Lock을 조합해서 구현한다.

즉 로우를 갱신하려면 Undo 세그먼트에서 트랜잭션 슬롯을 할당ㅂㄷ고, Enqueue 리소스를 통해 Tx Lock을 획득한다.

그런 후, insert, update, delete, merge 문을 통해 갱신하는 각 로우마다 Exclusive 모드로 로우 단위 Lock을 획득한다.

TX lock은 트랜잭션 을 시작할때 한 번만 획득한다.

TX1이 로우 정보를 갱신할 때는, 블록 헤더 ITL 슬롯에 트랜잭션 ID를 기록하고, 로우 헤더에 이를 가리키는 Lock Byte를 설정한다.

이 레코드를 액세스하려는 다른 트랜잭션은 로우 헤더에 설저한 Lock Byte를 통해 ITL 슬롯을 찾고, ITL 슬롯이 가리키는 UNDO 세그먼트 헤더 트랜잭션 슬롯에서 트랜잭션 상태 정보를

확인하여 해당 레코드에 대한 액세스 가능여부를 결정한다.

TX1 트랜잭션이 진행 중인 경우, 이 레코드를 읽으려는 다른 트랜잭션은 Tx1의 상태를 확인하고 CR 블록을 생성해 읽기 작업을 완료한다.

오라클은 로우단위 Lock과 다중버전읽기일관성 메커니즘을 이용하여 select for update 문이 아닌한 읽기 작업에 대해서는 절대 Lock에 의한 대기 현상이 발생하지 않는다.

TX LOCK의 경우 TX1이 갱신 중인 레코드를 같이 갱신하련느 TX2는 TX1이 완료될때까지 대기해야한다. 이를 위해 TX LOCK이 필요하다.

- 로우단위 LOCK : 블록 헤더 ITL과 로우 헤더 Lock byte 설정을 의미한다. 이를 통해 로우를 갱신 중인 트랜잭션 상태를 확인하고 액세스 가능 여부를 결정한다.

- TX Lock : Enqueue 리소스를 통해 TX LOCK을 설정하는 것을 의미한다. Lock이 설정된 레코드를 갱신하고자 할때 Enqueue 리소스에서 대기한다.

DML 로우 lock에 의한 TX LOCK 때문에 블로킹된 세션을 관찰해 보면, Exclusive 모드의 enq:TX - row lock contention 대기 이벤트가 지속적으로 발생한다.

## TM LOCK > DML TABLE LOCK

오라클은 로우 Lock 획득시, 해당 테이블에 대한 테이블 lock도 동시에 획득한다. 이를 통해 현재 트랜잭션이 갱신 중인 테이블에 대한 호환되지 않는 DDL 오퍼레이션을 방지한다.

테이블 구조를 변경하지 못하게 하는 것이다.

테이블 lock은 주로 DDL과 관련 있찌만 DML문 간에도 테이블 lock을 이용해 동시성을 제어할 때가 있다.

명시적으로 LOCK TABLE 명령어를 이용할 수 있다.

\- lock table emp in row share mode
\- lock table emp in row exclusive mode
\- lock table emp in share mode
\- lock table emp in share row exclusive mode
\- lock table emp in exclusive mode

DML 테이블 Lock은 DML 문장 수행 시 자동으로 테이블 Lock까지 함께 획득하는 메커니즘이다.

오라클은 변경 작업에만 로우 Lock을 사용하므로, 로우 Lock은 항상 EXclusive 모드다. 하지만 테이블 LOCK에는 여러 가지 LOCK 모드가 사용됨며, LOCK 모드간 호환성은 다음과 같다.

|      | NULL | RS  | RX  | S   | SRX | X   |
| ---- | ---- | --- | --- | --- | --- | --- |
| NULL | O    | O   | O   | O   | O   | O   |
| RS   | O    | O   | O   | O   | O   |     |
| RX   | O    | O   | O   |     |     |     |
| S    | O    | O   |     | O   |     |     |
| SRX  | O    | O   |     |     |     |     |
| X    | O    |     |     |     |     |     |

\- RS : row share
\- RX : row exclusive
\- S : share
\- SRX : share row exclusive
\- X : exclusive

선행 트랜재션과 호환되지 않는 모드 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.

insert, update, delete, merge 문을 위해 로우 LOCK을 설정하려면 해당 테이블에 RX 모드 테이블 LOCK을 먼저 획득해야 한다.

select for update 문을 위해 lock을 설정하려면 rs 모드 테이블 lock을 먼저 획득해야 한다.

rs, rx 간에는 항상 호환되므로 select for update 나 dml문 수행 시 이들 간에 테이블 Lock에 의한 경합은 절대 발생하지 않는다.

다만, 같은 로우를 갱신하려 할 때 로우 lock에 의한 경합이 발생한다.

오라클은 테이블 lock을 enqueue로 구현하였으며, TM Enqueue라고 부른다.

TM Enqueue를 이용하기 때문에 테이블 lock을 TM LOCK이라고 부르기도 한다.

TM Enqueue 리소스 구조체의 식별자는 아래와 같은 정보를 포함한다.

\- TYPE : TM
\- ID1 : 오브젝트 ID
\- ID2 : 0

선행 트랜잭션이 TM LOCK을 해제하길 기다리는 트랜잭션에서 발생하는 데기 이벤트를 모니터링히보면, enq:TM-content 이벤트가 지속적으로 나타난다.

테이블 lock이라고 하면, 테이블 전체에 lock을 거는 것으로 생각하기 쉽다. 그래서 다른 트랜잭션이 더는 레코드를 추가하거나 갱신하지 못하도록 막는다고 생각한다.

하지만 dml 수행시 항상 테이블 lock이 함께 설정되므로 그렇게 이해하는 것은 맞지 안핟.

오라클에서 말하는 테이블 Lock은 lock을 획득한 선행 트랜잭션이 해당 테이블에서 어떤 작업을 수행 중인지를 알리는 푯말이다.

테이블 Lock에는 여러 가지 모드가 있고, 각 모드에 따라 후행 트랜잭션이 수행할 수 있는 작업범위가 결정된다.

푯말에 기록된 lock 모드와 후행 트랜잭션이 현재 하려는 작업 내용에 따라 진행 여부가 결정된다.

진행할 수 없다면 기다릴지, 아니면 포기할지 진로를 결정해야 한다. 기다려야 한다면 TM Enqueue 리소스 대기자 목록에 Lock 요청을 등록하고 대기한다.

---

### 대상 리소스가 사용 중일 때, 진로 선택

LOCK을 얻고자 하는 리소스가 사용 중일 때, 프로세스는 아래 3가지 방법 중 하나를 택한다.

보통 내부적으로 진로가 결정돼 있지만, 사용자가 선택할 수 있는 경우도 있다.

사용자가 이 3가지 옵션을 모두 선택할 수 있는 문장이 select for update문이다.

1. Lock이 해제될 때까지 기다린다. (select \* from t for update)
2. 일정 시간만 기다리다 포기한다. (select \* from t for update wait 3)
3. 기다리지 않고 작업을 포기한다. (select \* from t for update nowait)

DML 문을 수행할 때 묵시적으로 table lock을 얻게 되는데 이때는 1번, 기다리는 방법을 택한다.

Lock table 명령을 이용해 멍시적으로 테이블 Lock을 얻을 때도 기본적으로 기다리는 방법을 택하지만, NOWAIT 옵션을 이용해 곧바로 작업을 포기하도록 지정할 수 있다.

lock table emp in exclusive mode NOWAIT;

DDL 문을 수행할 때도 내부적으로 table lock을 얻는데, 이때는 NOWAIT 옵션이 자동으로 지정된다.

---

예를 들어, DDL 문을 잉요해 테이블 구조를 변경하려는 세션은 테이블에 TM LOCK이 설정돼 있는지를 먼저 확인한다.

TM LOCK을 ROW EXCLUSIVE로 설정한 트랜잭션이 하나라도 잇으면, 현재 테이블을 갱신 중인 트랜잭션이 있다는 신호이다.

따라서 ORA-00054 메시지를 던지고 멈춘다.

DDL 문이 먼저 수행중일 때는 DML문을 수행하려는 세션이 TX LOCK을 얻으려고 대기한다. 이때 enq:TM-contention 이벤트가 발생한다.

테이블 lock은 DDL과 동시 진행을 막으려고 사용될 뿐 아니라 DML 간 동시성을 제어하기 위해 사용되기도 한다.

병령 DML 또는 Direct Path Insert 방식으로 작업을 수행할 때가 그렇다.

```sql
insert /*+append*/ into t select ... from ...
```

DML 문을 수행하면 TX LOCK과 TM Lock을 동시에 획득한다.

일반적인 DML문에서는 테이블 LOCK을 ROW RxCLUSIVE 모드로 설정하지만 APPEND 모드 INSERT 는 EXCLUSIVE 모드로 설정한다.

다른 세션에서 같은 테이블을 레코들르 갱신하는 Update문을 실행하면 ROW EXCLUSIVE 모드로 테이블 LOCK을 요청한다.

ROW EXCLUSIVE 모드 LOCK은 Exclusive 모드와 호환성이 없으므로 블로킹 된다.

로우 lock이 아니라 테이블 lock 때문에 블로킹된 점을 통해 로우 LOck 호환성을 확인하기전에 테이블 lock 호환성을 먼저 확인한다.

EXCLUSIVE MODE TALBE LOCK을 획득한 선행 트랜잭션을 커밋하면 후행 트랜잭션이 TX Lock과 TM LOCK을 동시에 획득한다.

선행 트랜잭션이 Lock 걸고 있는 레코드를 다른 세션에서 변경하면

테이블 Lock에 의한 블록킹이 아닌 로우 Lock 때문에 블로킹이 발생한다. Exclusive 모드 로우 Lock 간에는 호환성이 없고 Row-Exclusive 모드 테이블 Lock 간에는

호환성이 있으므로 Lock 경합이 발생하지 않는다,.

TX LOCK은 트랜잭션마다 오직 하나 씩 획득하지만 ,TM LOCK은 트랜잭션에 의해 변경이 가해진 오브젝트 수 만큼 획득한다.

## Lock을 푸는 열쇠 커밋.

블로킹은 Lock 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰선 경우를 말한다. 이를 해소하는 방법은 커밋 또는 롤백이다.

교착상태는, 두 세션이 각각 Lock을 설정한 리소스를, 서로 액세스하려고 마주보고 진행하는 상황을 말하며, 둘 중 하나가 뒤로 물러나지 않으면 영영 풀리지 않는다.

교착상태가 ㅂ라생하면 이를 먼저 인지한 세션이 문장 수준 롤벡을 진행한 후 에러 메시지를 던진다.

교착상태를 발생시킨 문장을 롤백하면 교착상태는 해소되지만 블로킹 상태에 놓인다.

따라서 롤백 메시지를 받은 세션은 커밋 또는 롤백을 결정ㅎ애햐 한다.

오라클은 데이터를 읽을 때 Lock을 사용하지 않으므로, 다른 DBMS에 비해 상대적으로 Lock 경합이 적게 발생한다.

읽는 세션의 진행을 막는 부담감이 없으므로 필요한 만큼 트랜잭션을 길게 가져갈 수 있다.

하지만 트랜잭션이 너무 길면, 트랜잭션을 롤백해야 할 때 너무 많은 시간이 걸릴 수 있고 undo 세그먼트가 고갈되거나 경합을 유발할 수 있다.

같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계하고, DML LOCK 때문에 동시성이 저하되지 않도록 적절한 시점에 커밋한다.

반대로, 불필요한 커밋을 너무 자주 수행하면 snapshot too old 에러를 유발할 가능성이 놓고

LGWR가 로그 버퍼를 비우는 동안 발생하는 log file sync 대기 이벤트로 인해 성능 저하 현상이 발생할 수 있다.

잦은 커밋으로 인해 성능이 저하되면, 비동기식 커밋 기능을 활용할 수 있다.

\- WAIT : LGWR가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때까지 대기하며, 그 동안 log file sync 대기 이벤트가 발생한다.

\- NOWAIT : LGWR의 완료 메시지를 기다리지 않고 바로 당므 트랜잭션을 진행하므로, Log file sync 대기 이벤트가 발생하지 않는다.

\- IMMEDIATE : 커밋 명령을 받을 때마다 LGWR가 로그 버퍼 파일에 기록한다.

\- BATH : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리한다.

4가지 옵션을 조합해 커밋 명령ㅇ르 사용할 수 있따.

```sql
commit write immeditate wait;
commit write immediate nowait;
commit write batch wait;
commit write batch nowait;
```

일반적인 imediate wait cmoiit은 트랜잭션 데이터가 데이터베이스에 안전하게 저장됨을 보장한다.

하지만 비동기식 커밋 옵션을 사용하면 트랜잭션 커밋 직후 인스턴스에 문제가 생기거나, redo 로그가 위치한 파일 시스템에 문제가 생겨

쓰기 작업이 진행될 수 없게되면 커밋이 정상적으로 완료되지 못할 수 있따.

트랜잭션에 의해 생성되는 덷이터 중요도에 따라 활용여부를 결졍해야한다.

0..
