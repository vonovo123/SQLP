온라인 트랜잭션을 처리하는 시스템에서 인덱스 설계의 중요성은 아무리 강조해도 지나치지 않다.
인덱스 튜닝, 더 나아가 SQL 튜닝의 하이라이트라고 할 수 있다. 많은 경험과 고도의 기술력이 요구되는 매우 전문적인 설계 영역ㅇ이기도 하다. 그런 전문성을 갖추려면 세밀한 인덱스 원리와 이론을 바탕으로 많으 시행착오를 겪어야 한다.

# 인덱스 설계가 어려운 이유

SQL 각각에 최적화된 인덱스를 마음껏 생성할 수 있다면, SQL 튜닝과 인덱스 설계만큼 쉬운 일도 없다. 몇 가지 공식만 알면 되기 때문이다. 하지만 그렇게 인덱스를 생성하다 보면 테이블마다 인덱스가 수십 개씩 달려 관리비용과 시스템 부하가 증가되는 요인이 된다. 인덱스가 많으면 아래와 같은 문제가 생긴다.

\- DML 성능 저하
\- 데이터베이스 사이즈 증가
\- 데이터베이스 관리 및 운영 비용 상승

예를 들어 테이블에 인덱스가 여섯 개 달려 있으면, 신규 데이터를 입력할 때마다 여섯개 인덱스에도 입력해야 한다. 테이블과 달리 인덱스는 정렬 상태를 유지해야하므로 수직적 탐색을 통해 입력할 블록부터 찾는다. 찾는 블록에 여유 공간이 없으면 인덱스 분할도 발생한다.

테이터를 지울 때도 마찬가지다. 여섯 개 인덱스에서 레코드를 찾아 일일이 지워줘야 한다. 핵심 트랜잭션이 참조하는 테이블에 대한 DML 성능 저하는 TPS 저하로 이어진다. 꼭 필요 하지 않은 인덱스를 많이 만들면 디스크 공간도 낭비하고, 데이터베이스 사이즈가 커지는 만큼 백업, 복제, 재구성 등을 위한 운영 비용도 상승한다.

개별 쿼리 성능뿐 아니라, 그 개수를 최소화함으로써 DML 부하를 줄여야 하므로 인덱스 설계가 어렵다. SQL 튜닝은 그래서 어렵고, OLTP 환경에서는 특히 그렇다. 인덱스 설계는 시스템 전체 시각에서 종합적, 전략적으로 접근해야 하는데, 전략을 논하기에 앞서 인덱스를 구성하는 원리를 살펴보자.

## SQL 튜닝 개발 단계에서 최적 인덱스 설계의 중요성

인덱스 개수를 최소화하려면 기존 인덱스 구성을 변경함으로써 문제를 해결해야 하는데, 인덱스 변경에 따른 시스템 변경 영향도가 매우 커서 이 역시 쉽지 않다. 영향받는 SQL을 모두 찾아 성능을 검증해야 하기 때문이다.

시스템 개발 단계에서는 비교적 쉽게 인덱스를 변경할 수 있지만, 개발을 마치고 운영 환경으로 이행하는 순간부터 인덱스 변경은 쉽지 않은 일이 돼 버린다.

신규 인덱스 추가는 비교적 변경 영향도가 적다. 그래서 기존 인덱스를 변경해서 해결할 수 있는 문제도 신규 인덱스를 추가해서 해결하곤 하는데, 그럴수록 시스템 수준 TPS는 점점 나빠진다.

정리하면, 인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 크다. 시스템 개발 단계에서 인덱스를 최적으로 설계하는 일이 무엇보다 중요한 이유가 바로 여기에 있다.

특히 핵심 트랜잭션에서 데이터를 추가, 변경, 삭제하는 테이블은 고도의 기술력을 가진 SQL 튜닝 전문가를 통해 인덱스를 정교하게 설계해야 한다,

도구의 지원도 필요하다. 인덱스 설계도를 작성하려면 각 테이블에 대한 엑세스 경로를 모두 수집해 패턴별로 정리해야 하는데, 이는 쉬운 작업이 아니다. 수천 개 테이블에 대한 수만 개 SQL을 수집해서 나온 수십만 개 액세스 경로를 패턴별로 압축해서 정리해야 하기 때문이다.

이 작업에 드는 엄청난 시간과 노력을 줄이고 설계 품질을 높이려면, 자동화된 인덱스 설계 도구가 필요하다.

---

# 3.4.2 가장 중요한 두 가지 선택 기준

인덱스 스캔 방식에 여러 가지가 있지만, 가장 정상적이고 일반적인 방식은 INDEX RANGE SCAN 이다. 이를 위해 인덱스 선두 칼럼을 조건절에 반드시 사용해야 한다.

따라서 결합 인덱스를 구성할 때 첫 번째 기준은, 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정하는 것이다.

두 번째 기준은, 그렇게 선정한 컬럼 중 '=' 조건으로 자주 조회하는 커럼을 앞쪽에 두는 것이다.

1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.
2. '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

---

# 3.4.3 스캔 효율성 이외의 판단 기준

인덱스 스캔 효율성 이외에 고려해야할 판단 기준을 나열하면 아래와 같다.

\- 수행 빈도
\- 업무상 중요도
\- 클러스터링 팩터
\- 데이터량
\- DML 부하(= 기존 인덱수 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
\- 저장 공간
\- 인덱스 관리 비용 등

이 중 가장 중요한 하나를 꼽으라면 수행 빈도라 할 수 있다. 자주 수행하지 않는 SQL이면 인덱스 스캔 과정에 약간의 비효율이 있어도 큰 문제가 아닐 수 있다. 반면, 수행빈도가 매우 높은 SQL에서는 앞서 설명한 공식을 이용해 최적의 인덱스를 구성해 줘야 한다.

수행빈도와 관련해, NL 조인할 때 어느 쪽에서 자주 액세스 되는지도 중요한 판단 기준이 된다.

NL 조인할 때 OUTER 쪽(드라이빙 집합)에서 액새스하는 인덱스는 스캔 과정에 비효율이 있어도 큰 문제가 아닐 수 있다. 예를 들어 아래 SQL에서 거래쪽 인덱스를 [거래일자 + 거래구분코드] 순으로 구성하는 경우를 말한다.

```sql
select /*+leading(a) use_no(b)*/
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = 'AC'
AND a.거래일자 between '20090101' and '20090131'
and b.상품번호 = a.상품번호
and b.상품분류 = '가전'
```

거래 쪽 인덱스를 스캔하는 과정에 비효율이 있더라도 NL 조인 메커니즘 상 비효율은 한 번에 그친다. 불필요한 테이블 액세서는 발생하지 않으므로 아주 넓은 거래일자 구간으로 조회하지 않는다면 성능도 비교적 나쁘지 않다,

당장 조회 성능에 별 문제가 없고 자주 수항해는 SQL이 아니라면 굳이 스캔 효율을 높이기 위해 [거래구분코드 + 거래일자] 인덱스를 따로 만들지 않아도 된다.

반대로 NL 조인에서 INNER 쪽 인덱스 스캔 과정에서 비효율이 있다면 이는 성능에 큰 문제를 야기할 수가 있다. 아래 SQL 에서 거래 쪽 인덱스를 [거래일자 + 상품번호 + 거래구분코드] 순으로 구성하는 경우가 그렇다.

BETWEEN 조건 컬럼이 인덱스 선두 컬럼이므로 OUTER 테이블로 부터 엑세스하는 횟수만큼 비효율적인 스캔을 반복한다.

```sql
select /*+leading(b) use_no(a)*/
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = 'AC'
AND a.거래일자 between '20090101' and '20090131'
and b.상품번호 = a.상품번호
and b.상품분류 = '가전'
```

수행빈도가 매우 높은 SQL 이라면, 테스트 과정에 당장 성능이 좋게 나오더라도 인덱스를 최적으로 구성해 줘야 한다. NL 조인 INNER 쪽 인덱스는 = 조건을 컬럼 선두에 두는 것이 중요하고 될 수 있으면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야 한다.

데이터량도 인덱스 설계할 때 중요한 판단 기준이 된다. 테이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없다. FULL SCAN으로도 충분히 빠르기 때문이다. 반대로, 인덱스를 많이 만들어도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제 될 것이 없다. 테이블이 적으면 심각하게 고민할 이유가 없다.

초대용량 테이블일 때는 어떨까? 초대용량 테이블은 INSERT도 많다. 초당 DML 발생량은 트랜잭션 성능에 직접적인 영향을 준다. 그런 테이블에 인덱스를 설계할 때 튜닝에 대하 고도의 전문지식이 필요하다. 인덱스를 하나라도 줄였을 때 그것이 시스템이 미치는 영향은 적지 않다.

---

# 3.4.4 공식을 초월한 전략적 설계

조건절 패턴이 열 개 있을 때, 패턴마다 인덱스를 하나씩 만들 수는 없다. 그런 식이라면 인덱스 설계의 두가지 기준만 있으면 누구나 쉽게 설계할 수 있다.

열 개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다.

단순한 공식에 의한 결정이 아니라, 업무 상황을 이해하고 나름의 판단 기준을 가지고 결정을 내리는 것이다.

어떤 보험사에 '가계약' 테이블이 있다. 가계약 목록을 조회할 때 우선 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택한다. 조건절 연산자는 = 이다. 그리고 청약일자, 보험개시자, 보험종료일자, 데이터생성일시 중 하나를 선택한다. 조건절 연산자는 BETWEEN이다.

이런 상황에서 인덱스 스캔효율을 위해 '=' 조건 컬럼을 앞에, BETWEEN 조건 컬럼을 뒤에 두려면 24개의 인덱스가 필요하다. 24개에 달하는 인덱스를 모두 생성할 수 없다면 전략적 판단이 필요하다.

반대로 일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식이다.

\- X01 : 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점 설계사 + 대리점 지사
\- X02 : 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점 설계사 + 대리점 지사
\- X03 : 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점 설계사 + 대리점 지사
\- X04 : 데이터생성일시 + 취급부서 + 취급지점 + 취급자 + 대리점 설계사 + 대리점 지사

이 방식으로 설계한 핵심 포인트는 두 가지다.

첫째, 일자 조회구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다.
둘째, 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소다.

업무요건상 가계약은 최근 3일 이내 데이터를 조회한다. 대개는 전일자로 조회하므로 인덱스 스캔량은 그리 많지 않다. 가끔 3일을 초과한 기간으로 조회할 수 있고, 어쩌다 한 달 치를 조회할 수 있지만 그렇더라도 불필요한 테이블 액세스는 전혀 발생하지 않도록 설계했으므로 사용자가 인내할 수 있는 수준의 성능은 낼 수 있다.

사용자가 인내할 수 있는 수주의 인덱스 스캔 비횽율이더라도 BETWENN 조건 컬럼을 선두에 두고 설계하는 것은 좀 찜찜하다. 그럼에도 이런 결정을 한 이유는 가계약 테이블이 다양한 패턴으로 조회하지만, 그중 가장 많이 사용하는 패턴은 입력자 '=', 데이터생성일시 BETWEEN 조건이기 때문이다. 따라서 이 패턴에 최적의 스캔 효율을 제공하면 다른 패턴에 다소 비효율이 있어도 크게 지장이 없다고 판단했기 때문이다.

앞서 설계한 네 개 인덱스에 아래 인덱스를 하나 더 추가한다.

\- X05 : 입력자 + 데이터생성일시

공식대로 설계하려면 24개 인덱스가 필요하지만 업무상황을 고려한 전략적 판단을 통해 다섯 개로 줄였다. 이렇게 인덱스 개수를 최소화하면 사용빈도가 높거나 중요한 액세스 경로가 새로 도출됐을 때 최적의 인덱스를 추가할 여유도 생긴다.

---

# 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

인덱스는 항상 정렬 상태를 유지하므로 ORDER BY , GROUP BY 를 위한 소트 연산을 생략할 수 있게 해준다.

따라서 조건절에서 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.

아래 쿼리에 ORDER BY 절이 있음에도 불구하고 소트 연산이 발생하지 않도록 인덱스를 구성해 보자.

```sql
SELECT 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
FROM 계약
WHERE 취급지점ID = :trt_brch_id
AND 청약일자 between :sbcp_id1 and :sbcp_dt2
AND 입력일자  >= trun(sysdate - 3)
AND 계약상태코드 in ( :ctr_stat_cd1, :ctr_stat_Cd2, ;ctr_stat_cd3)
ORDER BY 청약일자, 입력자 ID

-- [취급지점ID , 청약일자, 입력자 ID, 계약상태코드, 입력일자]
```

성능을 고려하지 않아도 된다면, 소트 연산을 생략하도록 인덱스를 구성하는 일은 쉽다. ORDER BY 절 순서대로 [청약일자 + 입력자 ID] 로 구성하면 된다.
'=' 조건절 컬럼은 ORDER BY 절에 없더라도 인덱스 구성에 포함할 수 있다. 취금지점 ID가 = 조건이다.
이를 포함해 [취급지점ID + 청약일자 + 입력자 ID] 순으로 구성해도 소트 연산을 생략할 수 있다는 뜻이다. 위치는 앞뒤 중간 어디에 두어도 상관없다.
= 이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.

인덱스를 그렇게 구성하면 일단 소트는 생략할 수 있다. 문제는 성능인데 조건을 만족하려면 데이터를 빨리 만날 수 있느냐가 관건이다.

다행히 앞쪽에서 만나면 결과집합이 빨리 출력되기 시작하겠지만 불행하게도 맨 뒤쪽에서 만나면 사용자는 그때까지 손 놓고 기다려야 한다.

그 순간 DBMS 내부에서 많은 I/O가 발생하고 있을 것이다.

I/0를 최소화하면서도 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.

1. = 연산자로 사용한 조건절 컬럼 선정
2. ORDER BY 절에 기술한 컬럼 추가
3. = 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

입력일자와 계약상태코드는 뒤쪽에 붙여도 되고 안 붙여도 된다. 이들 조건을 만족하는 데이터가 적으면 인덱스에 추가해 테이블랜덤엑세스를 줄이는 게 좋다.
이들 조건을 만족하는 데이터가 많으면, 굳이 인덱스에 추가하지 않아도 된다. 테이블에서 필터링할 때와 큰 성능 차이가 없기 때문이다.
단 몇 회라도 테이블 액세스를 줄이면 조회 성능은 좋지만, 반대급부가 있다.

## IN조건은 = 가 아니다.

방금 본 사례에 따라 계약상태코드를 인덱스 앞쪽에 두어도 소트연산을 생략할 수 있다고 생각했을 수 있다. IN 조건을 = 으로 생각하면 그렇다.

하지만 IN 조건은 '=' 가 아니다.

```sql
SELECT 고객번호, 고객명, 거주지역, 혈액형, 연령
FROM 고객
WHERE 거주지역 = '서울'
AND 혈액형 in ('A', 'o')
ORDER BY 연령
```

IN 조건이 = 가 되려면 IN-LIST ITERATOR 방식으로 풀려야 한다. 이는 SQL을 아래와 같은 방식으로 실행한다는 의미다.
그러먼 IN 조건은 = 가 됐지만, UNION ALL 아래 두 집합을 묶어 '연령' 순으로 정렬하는 문제가 남는다.

```sql
SELECT 고객번호, 고객명, 거주지역, 혈액형, 연령
FROM 고객
WHERE 거주지역 = '서울'
AND 혈액형 = 'A'
UNION ALL
SELECT 고객번호, 고객명, 거주지역, 혈액형, 연령
FROM 고객
WHERE 거주지역 = '서울'
AND 혈액형 = 'O'
ORDER BY 연령

```

ORDER BY 절이 있음에도 불구하고 소트 연산을 생략하려면, 위쪽 브랜치를 실행하고 이어 아래쪽을 실행했을 때 그 결과가 연령 순으로 정렬돼야 한다. 그것이 가능하려면, 서울에 거주하는 모든 A 형 고객이 O 형고객보다 연령이 낮아야한다.

불가능한 일이므로 옵티마이저는 소트 연산을 생략하지 않는다.

결론적으로 소트 연산이 생략되려면 IN 조건절이 IN-LIST-ITERAOTR 방식으로 풀려선 안된다. 즉, IN 조건절을 인덱스 엑세스 조건으로 사용하면 안된다. 필터 조건으로 사용해야 한다.

따라서 인덱스를 [거주지역 + 연령 + 혈액형] 순으로 구성해야 한다.

---

# 3.4.6 결합 인덱스 선택도

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준이다. '선택도' 란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다. 선택도에 총 레코드 수를 곱해서 카디널리티를 구한다.

인덱스 선택도는 인덱스 컬럼을 모두 = 로 조회할 때 평균적으로 선택되는 비율을 말한다. 선택도가 높은 인덱스는 생성해봐야 효용가치가 별로 없다. 테이블 액세스가 많이 발생하기 때문이다.

따라서 인덱스를 생성할 때는 반드시 선택도/카디널리티를 확인해야 한다.

```sql
-- 계약 ID, 취급지점ID 두 컬럼에 대한 카디널리티를 조회하는 쿼리다.
SELECT COUNT(*) AS NDV, max(cnt) as MX_CARD, MIN(CNT) MN_CARD, AVG(CNT) AS AVG_CARD
FROM (
  SELECT 계약ID, 취급지점ID, COUNT(*) AS CNT
  FROM 계약조직
  WHERE (계약 ID IS NOT NULL OR 취급지점 is not null)
  group by 계약ID, 취급지점ID
)

```

## 컬럼순서 결정 시, 선택도 이슈

결합 인덱스 컬럼 간 순서를 정할 때도 선택도가 중요할까? 결합 인덱스를 구성할 때도 선택도가 낮은 컬럼을 앞에 두는 것이 유리하다고 흔히 알려져 있다.

구체적인 예로 고객번호를 앞에 두는 것이 유리하다고 생각하겠지만, 그렇지 않다. 성별과 고객번호 중 어떤 칼럼이 앞으로 오든 인덱스 스캔 효율에 전혀 차이가 없다.

둘 다 인덱스 액세스 조건이므로 어떤 칼럼이 앞으로 오든 인덱스 스캔 범위는 똑같다.

인덱스 설계할 때 우리가 할 일은 항상 사용하는 컬럼을 앞쪽에 두고 그중 '=' 조건을 앞쪽에 위치시키는것 뿐이다. 그 중 선택도가 낮은 컬럼을 앞에 두려는 노력은 의미 없거나 오히려 손해일 수 있다.

```sql
-- 조건절 1
WHERE 고객등급 = :V1
AND 고객번호 = :V2
AND 거래일자 >= :V3

-- 조건절 2
WHERE 고객등급 = :V1
AND 고객번호 = :V2
AND 거래일자 >= :V3
AND 거래유형 = :V4

-- 조건절 3
WHERE 고객등급 = :V1
AND 고객번호 = :V2
AND 거래일자 >= :V3
AND 상품번호 = :V5

-- 조건절 4
WHERE 고객등급 = :V1
AND 고객번호 = :V2
AND 거래일자 >= :V3
AND 거래유형 = :V4
AND 상품번호 = :V5
```

여기서 항상 사용하는 고객번호, 고객등급, 거래일자 중 고객번호와 고객등급은 = 조건, 거래일자는 BETWEEN 조건이다.

그리고 거래유형과 상품번호는 항상 사용하는 조건이 아니다.

IDX : 필수(고객등급 + 고객번호 + 거래일자) + 옵션( 거래유형 + 상품번호)

여기서 고객등급과 고객번호 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 전혀 영항을 주지 않는다. 거래일자 까지 세 컬럼이 액세스 조건이므로 인덱스 스캔 범위는 똑같다.

거래유형과 상푼번호 간에도 어떤 컬럼이 앞으로 오든 인덱스 스캔효율에 영향을 주지 않는다. 인덱스 스캔 범위가 고객등급, 고객번호, 거래일자에 의해 결정되므로 둘 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 차이가 없다. 심지어 이들 컬럼에 어떤 연산자를 사용해도 상관없다.

고객등급, 고객번호 둘 다 필수 = 조건이면 어떤 컬럼이 앞으로 오든 상관없지만, 둘 중 하나 이상이 조건절에서 누락되거나 범위검색 조건일 수 있다면 애기가 복잡해진다.

고객번호는 필수인데 고객등급이 조건절에서 누락되거나 범위검색 조건일 수 있는 경우만 설명하면 고객등급을 앞에 두는 것이 유리하다.

INDEX SKIP SCAN이나 IN-LIST 조건을 활용할 수 있기 때문이다. 인덱스를 압축할 경우, 고객등급을 앞쪽에 두면 압출률이 더 좋은 측면도 있다.

결론적으로, 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이다.

---

# 3.4.7 중복 인덱스 제거

아래 세 인덱스는 중복이다. X02 인덱스 선두 컬럼이 X01 인덱스 전체를 완전 포함하고, X03 인덱스 선두 컬럼이 X01과 X02 인덱스 전체를 완전히 포함하기 때문이다.
완전중복의 경우 X03 을 제외하고 X01,X02는 삭제해도 된다

\- X01 : 계약ID + 청약일자
\- X02 : 계약ID + 청약일자 + 보험개시일자
\- X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

아래 네 개 인덱스는 얼핏 보기엔 중복이 아니다. 선투 컬럼은 같지만 두 번째 컬럼이 모두 다르기 때문이다.

\- X01 : 계약ID + 청약일자
\- X02 : 계약ID + 보험개시일자
\- X03 : 계약ID + 보험종료일자
\- X04 : 계약ID + 데이터생성일시

하지만 계약 ID 의 평균 카디널리티가 매우 낮다면 사실상 중복이다. 예를 들어 계약ID 평균 카디널리티가 5라고 가정하면 계약 ID를 = 조건으로 조회하면 평균 다섯 건이 조회된다는 뜻이다.
그렇다면 이렇게 인덱스를 4개 씩 만들 이유가 없다.

\- X01 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시

## 중복제거실습 1

\- PK : 거래일자 + 관리지점번호 + 일련번호
\- N1 : 게좌번호 + 거래일자
\- N2 : 결제일자 + 관리지점번호
\- N3 : 거래일자 + 종목코드
\- N4 : 거래일자 + 계좌번호

거래일자, 결제일자는 항상 BETWEEN 또는 부등호 조건으로 조회한다.

```sql
-- 다음은 각 컬럼의 데이터 분포이다. NDV는 컬럼에 입력된 값의 종류 개수를 의미한다

-- 컬럼명         NDV
-- 거래일자       2356
-- 관리지점번호    127
-- 일련번호       1850
-- 계좌번호       5956
-- 종목코드       1715
-- 결제일자       2356
```

거래일자가 항상 BETWEEN 또는 부등호 조건이면 N3,N4 의 인덱스는 둘 다 거래일자가 인덱스 액세스 조건이다. 그렇다면 인덱스를 두 개나 만들 필요가 없다.
아래와 같이 N4 인덱스를 제거하고, N3 인덱스 뒤쪽에 계좌번호를 추가한다.

\- PK : 거래일자 + 관리지점번호 + 일련번호
\- N1 : 게좌번호 + 거래일자
\- N2 : 결제일자 + 관리지점번호
\- N3 : 거래일자 + 종목코드 + 계좌번호

두 번째 방안으로 N3 인덱스 변경 없이 그냥 N4 인덱스를 제거해도 된다. 계좌번호와 거래일자로 조회하거나 계좌번호 단독으로 조회할 때는 N1 인덱스를 사용하고, 거래일자만으로 조회할 때는 N3 인덱스를 사용하면 되기 때문이다.

```sql
-- 조건절                       인덱스
-- 계좌번호 =                    N1
-- 계좌번호 =, 거래일자 =          N1
-- 계좌번호 =, 거래일자 between    N1
-- 거래일자 =                    N3
-- 거래일자 BETWEN               N3
```

최종적으로 아래와 같이 설계하면 어떨까?

\- PK : 관리지점번호 + 거래일자 + 일련번호
\- N1 : 게좌번호 + 거래일자
\- N2 : 결제일자 + 관리지점번호
\- N3 : 거래일자 + 종목코드 + 계좌번호

기존에 관리지점번호가 선두인 인덱스가 없었으므로 관리지점번호 단독으로 조회하는 경우는 없었다. 그렇다고 PK 를 그대로 두면 (관리자번호 =, 거래일자 BETWEEN) 을 조건으로 조회할 때 비효율적이다.

최종안으로 설계하면 관리지점번호 와 거래일자로 조회할 때 PK 인덱스를 사용하고, 거래일자만으로 조회할 때는 n3인덱스를 사용하면 된다.

```sql
-- 조건절                             인덱스
-- 관리지점번호 = , 거래일자 =            PK
-- 관리지점번호 = , 거래일자 BETWEEN      PK
-- 거래일자 =                    N3
-- 거래일자 BETWEN               N3
```

# 중복제거 실습 2

인덱스 설계는 조건절 분석 과정이 필수지만, 조건절 없이도 중복인덱스를 찾아내는 경우가 있다. 아래의 중복 인덱스를 찾아 재설계해보자

\- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
\- N1 : 상태구분코드 + 관리번호
\- N2 : 관리번호
\- N3 : 주소ID + 관리번호

```sql
-- 다음은 각 컬럼의 데이터 분포이다. NDV는 컬럼에 입력된 값의 종류 개수를 의미한다

-- 컬럼명         NDV
-- 주소ID       736000
-- 건물동번호    175
-- 건물호번호       3052
-- 관리번호       250782
-- 상태구분코드       3
```

상태 구분코드는 NDV가 3이므로 선택도가 매우 높다. 상태구분코드로 조회할때는 N1 인덱스가 사용되지 않는다. N1 인덱스가 사용되려면 상태구분코드와 관리번호를 같이 조회해야 한다.

N2 인덱스는 관리번호로 조회할때만 사용되므로 아래와 같이 N2 인덱스를 제거하고, N1 인덱스를 [관리번호 + 상태구분코드] 순으로 변경해보자. 관리번호로만 조회하든, 상태구분코드까지 같이 조회하든 N1인덱스를
사용하면 된다.

\- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
\- N1 : 관리번호 + 상태구분코드
\- N3 : 주소ID + 관리번호

한 가지 주의할 점은 상태구분코드 NDV가 3이긴 하나, 그중 특정 값은 변별럭이 매우 좋을 수도 있다는 점이다. 만약 그 값으로 조회할 때 사용할 목적으로 N1인덱스를 만들엇다면 구성을 바꾸면 문제가 생길 수 있다.

# 3.4.8 인덱스 설계도 작성

인덱스 설계 시 시스템 전체 효율을 고려해야 한다. 조회를 이룬 건축물을 짓기 위해 설계도가 필수인 것 처럼 인덱스 설계에도 전체를 조망할 수 있는 설계도면이 필요하다.

변경 전 인덱스 구성필드, 변경 후 인덱스 구성 필드가 있다. 전자는 말 그대로 현재의 인덱스 구성을 데이터베이스 딕셔너리에서 읽어 기록한 것이고, 후자는 새로운 구성 전략을 기록한 것이다.

전체를 보면서 전략을 수립하려면 테이블별로 실제 발생하는 액세스 유형을 모두 조사하는 과정이 필요한데, 익세스 경로 항목이 그것ㅇ이다.

설계도 상단에 파티션 구성을 기록하는 필드가 있다. 인덱스 설계 전에 파티션 설계를 먼저 진행하거나 최소한 병행해야 제대로 된 인덱스 전략을 수립할 수 있다.
