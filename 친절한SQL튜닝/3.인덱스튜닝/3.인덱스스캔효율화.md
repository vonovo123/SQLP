IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화하는데 매우 효과적인 저장구조다.

하지만 운영 시스템 환경에서 이를 적용하려면 성능 검증을 위해 많은 테스트를 진행해야 하므로 어려움이 따른다.

시스템 개발 단계에서 물리 설계가 중요한 이유이다.

운영 환경에서 가능한 일반적인 튜닝기법은 인덱스 컬럼 추가 정도다. 테이블 랜덤 액세스 최소화가 SQL 성능에 미치는 영향이 매우 크지만, 튜닝 기법은 의외로 단순하다.

반면 인덱스 스캔 효율화는 튜닝 요소가 매우 다양하다.

인덱스 설계 공식을 이루는 주요 원리도 인덱스 스캔 효율화에서 비롯된다. 인덱스 튜닝에 흥미를 느낄만한 요소가 많고, SQL 작성할 때 주의할 내용을 많이 포함하므로 꼼꼼한 학습이 필요하다.

# 인덱스 탐색

인덱스 스캔 효율화 튜닝을 이해하려면, 인덱스 탐색과정을 좀 더 깊이 있게 다룰 필요가 있다.

루트 블록에 (C1,C2) 컬럼이 (A,3), (B,3), (C,2)인 세 개 레코드가 있다. 각 레코드는 하위 노드를 가리키는 블록 주소를 갖는다.

자신이 가리키는 주소로 찾아간 블록에는 자신의 키 값보다 크거나 같은 값을 갖는 레코드가 저장되어있다.

예를 들어 (B,3) 레코드가 가리키는 주소로 찾아간 블록에는 C1 = 'B' 이고 C2 = 3 인 레코드보다 값이 크거나 같은 레코드( 두 컬럼 모두 한 자릿수라고 할 때, C1 || C2 >= 'B3'인 레코드) 가 저장돼 있다.

루트 블록에는 키 값을 갖지 않는 레코드가 있는데 가장 왼쪽에 있는 LMC 레코드다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

LMC가 가리키는 주소로 찾아간 블록에는 상위블록의 키 값을 가진 첫 번째 레코드 보다 작거나 같은 값을 갖는 레코드가 저장돼 있다.

이 인덱스에서 아래의 여섯개 조건절을 철할 때, 리프 블록 어느 지점에서 스캔을 시작하고 어느 지점에서 멈추는지 확인해보자.

```sql
-- 조건절 1
-- C1 = B인 첫 번째 레코드를 찾는다
-- 스캔 시작점을 찾기 위해 C1 = B인 루트블록의 레코드가 가리키는 하위 노드로 내려가는것이 아닌 C1 = A 인 레코드가 가리키는 하위블록으로 내려간다.
WHERE C1 = 'B'
-- 조건절 2
-- C1 = B C2 = 3인 레코드를 찾는다.
-- 스캔 시적점을 찾기위해 C1 = B 이고 C2 = 3인 레코드가 가리키는 하위 노드로 내려가는 것이 아닌 C1 = A인 레코드의 하위블록으로 내려간다.
-- C1, C2 조건 모두 인덱스 스캔량을 줄이는데 기여했다.
WHERE C1 = 'B'
AND C2 = 3
-- 조건절 3
-- C1 = B, C2 >= 3인 레코드를 찾는다.
-- 스캔 시적점을 찾기위해 C1 = B 이고 C2 = 3인 레코드가 가리키는 하위 노드로 내려간다.
-- C2 조건은 인덱스 수평스캔 시작점을 당기는게 기여했다.
-- C1, C2 조건 모두 인덱스 스캔량을 줄이는데 기여했다.
WHERE C1 = 'B'
AND C2 >= 3
-- 조건절 4
-- C1 = B, C2 <>= 3인 레코드를 찾는다.
-- 스캔 시적점을 찾기위해 C1 = B 이고 C2 = 3인 레코드가 가리키는 하위 노드로 내려가는 것이 아닌 C1 = A인 레코드의 하위블록으로 내려간다.
-- C2 조건은 인덱스 수평스캔을 멈추는데 기여한다.
-- C1, C2 조건 모두 인덱스 스캔량을 줄이는데 기여했다.
WHERE C1 = 'B'
AND C2 <= 3
-- 조건절 5
-- 수직적 탐색을 통해 C1='B'이고 C2>=2 인 시작점을 찾고 C2 > 3인 지점에서 스캔을 멈춘다.
-- C1, C2 조건절 모두 스캔 시작과 끝 지점을 결정하는데 중요한 역할을 했다.
-- 즉, 스캔량을 줄이는 역할을 했다.
WHERE C1 = 'B'
AND C2 BETWEEN 2 AND 3

-- 조건절 6
-- C1조건은 스캔시작과 끝 지점을 결정하는데 중요한 역할을 했지만, C2는 그렇지 못하다.
WHERE C1 = BETWEEN 'A' AND 'C'
AND C2 BETWEEN 2 AND 3
```

조건절 1은 수직적 탐색을 통해 C1 = 'B' 인 첫 번째 레코드를 찾고, 'C' 를 만나는 순간 스캔을 멈춘다.
루트 블록 스캔 과정에서 C1 = 'B' 인 레코드를 찾았을 때 그것이 가리키는 리프 블록 3 으로 가면 안된다.
그 직전 레코드 (C1 = 'A') 가 가리키는 리프 블록 2로 내려가야 한다.
C1 = 'B' 인 레코드가 가리키는 리프블록 3으로 내려가도 조건을 만족하는 데이터를 만날 수 있지만, 거기가 스캔 시작점이 아니다.
하위 블록에 저장된 값들을보면 그 사실을 알 수 있다. 수직적 탐색은 스캔 시작점을 찾는 과정이다.

조건절 2는 수직적 탐색을 통해 C1 = 'B' 이고 C2 = 3 인 첫 번째 레코드를 찾고, C1='B'인 레코드 중에 C2 = 4 인 레코드를 만나는 순간 스캔을 멈춘다.

C1과 C2 조건절 모두 스캔 시작과 끝 지점을 결정하는데 중요한 역할을 했다. 즉, 스캔량을 줄이는 데 역할을 했다.
여기서도 C1='B' 이고 C2 = 3인 레코드를 찾았다고 하위 노드인 블록 3으로 내려가면 안된다.
그 직전 레코드가 가리키는 리프 블록 2로 내려왔다.

조건절 3은 수직적 탐색을 통해 C1='B' 이고 C2 >= 3인 첫 번째 레코드를 찾고 C1='C'인 레코드를 만날때 까지 스캔하다가 멈춘다.
3 <= C2 조건절은 스캔을 멈추는 데는 역할을 전혀 못 했지만, 이 조건절로 인해 조건절 1과 스캔 시작점이 달라졌다.
부등호 조건이지만 수직적 탐색 과정에 사용됨으로써 스캔 시작점을 결정하는데 중요한 역할을 했다.
즉, 스캔량을 줄이는데 역할을 했다.

조건절 4는 수직적 탐색을 통해 C1 = 'B'인 첫번째 레코드를 찾고 거기서부터 스캔하다가 C2 > 3 인 첫 번째 레코드를 만나는 순간 스캔을 멈춘다.
C2 <=3 조건절은 수직적 탐색 과정에 전혀 쓰이질 않았다.
스캔 시작점을 결정하는 데 전혀 역할을 못했지만, 스캔을 멈추는데 중요한 역할을 했다.
즉, 스캔량을 줄이는 역할을 했다.

조건절 5는 수직적 탐색을 통해 C1='B'이고 C2>=2 인 시작점을 찾고 C2 > 3인 지점에서 스캔을 멈춘다.
C1, C2 조건절 모두 스캔 시작과 끝 지점을 결정하는데 중요한 역할을 했다. 즉, 스캔량을 줄이는 역할을 했다.

조건절 6은 수직적 탐색을 통해 C1 >= 'A' 이고 C2 >= 2 인 첫 번째 레코드에서 스캔을 시작하고,
C1 = 'C'이고 C2 = 3 인 레코드보다 값이 큰 레코드를 만나는 순간 스캔을 멈춘다.
C1조건은 스캔시작과 끝 지점을 결정하는데 중요한 역할을 했지만, C2는 그렇지 못하다.
맨 앞 C1 = 'A'인 구간과 맨뒤 C1= 'C' 구간에서는 어느 정도 역할을 했지만, 중간 C1= 'B' 구간에서는 전혀 역할을 못했다.
즉 C2는 스캔량을 줄이는 데 거의 역할을 못했다.

---

# 3.3.2 인덱스 스캔 효율성

인덱스 스캔을 통해 얻은 결과 건수는 똑같은데 왜 인덱스 리프 블록에서 스캔하는 레코드 개수에 차이가 생기는 걸까?
왜 효율성에 차이가 나는 걸까? 인덱스 선행 컬럼이 조건절에 없기 때문이다.
인덱스 선행 컬럼이 조건절에 없거나 = 조건이 아니면 인데스 스캔 과정에서 비효율이 발생한다.

## 인덱스 스캔 효율성 측정

인덱스 효율이 좋은지 나쁜지는 어떻게 알 수 있을까?
조건절 데이터를 일일이 조회해 보는 방법도 있지만 SQL 트레이스를 통해 쉽게 알 수 있다.

```sql
-- 10 TABLE ACCESS BY INDEX ROWID BIG_TABLE (CR=7471 PR=1466 PW=0 TIME=22167 US)
 --     INDEX RANGE SCAN BIG_TABLE_IDX(CR=7463 PR=1466 PW=0 TIME=22328 US)
```

위 트레이스를 분석해 보면, 인덱스를 스캔하고 얻은 레코드가 열 개인데, 그 과정에서 7463개의 블록(cr=7463) 을 읽었다는 사실을 알 수 있다.
인덱스 리프 블록에는 테이블 블록보다 훨씬 더 많은 레코드가 담긴다. 한 블록당 평균 500개의 레코드가 담긴다고 가정하면 7463 \* 500 개의 데이터를 읽은 셈이다.
결과적으로 10개의 데이터를 읽었다면 큰 비효율이 있다

---

# 3.3.3 액세스 조건과 필터조건

인덱스 스캔 효율을 설명하기 앞서 반드시 이해해야할 용어가 있다. '엑세스 조건(driving)' 과 '필터 조건(check)' 이다.

인덱스를 스캔하는 단계에 처리하는 조건절은 액세스 조건과 필터 조건으로 나뉜다.

인덱스 엑세스 조건은 인덱스 스캔 범위를 결정하는 조건이다. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미치는 조건절이다.

인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건이다.

인덱스를 이용하든, 테이블을 full scan 하든, 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건이다. 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정한다.

---

# 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다. 같은 값을 찾을 때 = 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락없이 = 연산자로 조회하면 조건절을 만족하는 레코드는 모두 모여 있다.

어느 하나를 누락하거나 = 조건이 아닌 연산자로 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.

```sql
-- 인덱스 구성 컬럼을 모두 = 조건으로 빅할 때는 조건을 만족하는 레코드들이 모두 연속해서 모여있다.
where C1 = 1
AND C2 = 'A'
AND C3 = '나'
AND C4 = 'a'

-- 선행 컬럼은 모두 = 이고 맨 마지막 칼럼만 범위검색 조건(부등호, between, like)일 때도 조건을 만족하는 레코드가 서로 모인다.
where C1 = 1
AND C2 = 'A'
AND C3 = '나'
AND C4 >= 'a'



-- 맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 때는 범위 조건까지의 데이터는 모두 모여있지만 이후 조건까지 만족하는 데이터는 흩어지게 된다.
where C1 = 1
AND C2 = 'A'
AND C3 between '가' and '다'
AND C4 = 'a'

-- 조건절 4
where C1 = 1
AND C2 <= 'B'
AND C3 = '나'
AND C4 between 'a' and 'b'

-- 조건절 5
where C1 Between 1 and 3
AND C2 = 'A'
AND C3 = '나'
AND C4 = 'a'

```

여기서 한 가지 규칙을 발견할 수 있다.

선행 컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있지만,

그 이하 조건까지 만족하는 레코드는 비교연산자 종류에 상관없이 모두 흩어진다.

인덱스 스캔 범위를 결정하는 조건절이 인덱스 액세스 조건절이라는 상기하자. 선행 칼럼 모두 = 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 걸졍한다.

가장 선두 컬럼이 범위검색 조건이면, 그 조건이 스캔 범위를 결정한다. 따라서 이들 조건이 인덱스 엑세스 조건이다.

나머지 인덱스 컬럼 조건은 모두 인데스 필터 조건이다.

## 범위검색 조건 맨 처음과 마지막 구간에서의 액세스 조건

사실 조건절 5에서 c2,c3,c4 도 인덱스 스캔량을 줄이는 데 어느 정도 역할을 한다.

c1 = 1 인 구간과 c1 = 3 인 구간에서 그렇다. 아래 조건을 만족하는 첫 번째 레코드를 찾아 수직적 탐색하므로 C1 = 1 구간에서 스캔 범위를 줄이는 역할을 한다.

where C1 >= 1 and C2 = 'A' AND C3 = '나' and C4 = 'a'

아래 조건보다 큰 값을 만나는 순간 멈추므로 C1 = 3 구간에서도 스캔 범위를 줄이는 역할을 한다.

WHERE C1 <= 3 AND c2 = 'A' and C3 = '나' and C4 ='A'

마찬가지로, 조건절 3과 4의 필터 조건도 범위검색 조건 맨 처음과 마지막 구간에서는 스캔량을 줄이는데 역할을 한다. 하지만 대개 무시할만한 수준이다.

오라클실행계획 하단에 아래와 같이 엑세스 조건과 필터 조건을 정리해서 보여주는데, 조건절 5를 테스트해 보면 c2,C3,C4 컬럼이 액세스 조건에 포함되는 이유가 바로 여기있다.

결국, 아래 몇 가지 케이스를 제외하면, 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시된다.

첫 번째 나타나는 범위 검색 조건 이후 조건절 컬럼은 스캔 범위를 줄이는데 큰 역할을 못함에도 그렇다.

\- 좌변 컬럼을 가공한 조건절

\- 왼쪽 '%' 또는 양쪽 '%' 기호를 사용한 like 조건절

\- 같은 컬럼에 대한 조건절이 두 개 이상 일때, 인덱스 액세스 조건으로 선택되지 못한 조건절

\- OR EXPANSION 또는 INLIST ITERATOR 로 선택되지 못한 or 또는 in 조건절

액세스 조건과 필터 조건을 실행계획에 표시된 대로 이해하면 사실 이 둘을 구분할 이유가 없어진다.

따라서 실행 계획에 위와 같이 표시되더라도 복잡하게 생각말고, 첫 번째 나타나는 범위 조건까지가 인덱스 액세스 조건이고, 나머지는 필터 조건이라고 이해할 수 있다.

---

# 인덱스 선행 컬럼이 등치 조건이 아닐 때 생기는 비효율

인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 가장 좋다.

리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지므로 인덱스 스캔 단계에서의 비효율이 전혀 없다.

인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.

인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷 매물] 순으로 구성했을 때 조건절이 아래와 같은 경우를 말한다.
아래 조건절은 모두 인덱스 액세스 조건으로 사용된다.

```sql
WHERE 아파트시세코드 = :a
WHERE 아파트시세코드 = :a and 평형 = :b
WHERE 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c
WHERE 아파트시세코드 = :a and 평형 = :b and 평형타입 between :c and :d
```

반면, 인덱스 선행 컬럼이 조건절에 없거나 부등호, between, like 같은 범위검색 조건이면 인덱스를 스캔하는 단계에서 비효율이 발생한다.

예를 들어, 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 구성한 상황에서 아래의 SQL을 수행하는 경우를 살펴보자.

```sql
SELECT 층, 평당가, 입력일, 도, 매물구분, 일수, 업소코드
FROM 매물아파트매매
WHERE  아파트시세코드 = 'A010...'
AND 평형 = '59'
AND 평형타입 = 'A'
AND 인터넷매물 BETWEEN '1' AND '3'
ORDER BY 입력일 DESC
```

인터넷매물이 BETWEEN 조건이지만 선두 컬럼들이 모두 = 조건이기 때문에 전혀 비효율 없이 조건을 만족하는 세 건을 빠르게 찾았다.

비효율이 없다는 것은 세 건을 찾기 위해 단 네건만 스캔했음을 의미한다.

맨 마지막 스캔은 조건을 만족하는 레코드가 더 없음을 확인하기 위한 one-plus 스캔이므로 불가피하다.

인덱스 선행 컬럼이 모두 = 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은 조건을 만족하는 레코트가 모두 한데 모여 있기 때문이다.

인덱스를 [인터넷매물 + 아파트시세코드 + 평형 + 평형타입 ] 순으로 바꾸고 SQL을 수행하면 인덱스 스캔 범위가 넓어진다.

인덱스 선두 컬럼 인터넷매물에 BETWEEN 연산자를 사용하면 나머지 조건을 만족하는 레코드들이 인터넷 매물 값 별로 뿔뿔이 흩어져 있게 된다. 따라서 조건을 만족하지 않는 레코드까지 스캔하고서 버리는 비효율이 생긴다.

다행스러운 것은 인터넷매물 BETWEEN 조건절 시작 값이 1인 구간에서는 전체를 다 읽지 않고 후행 조건을 만족하는 레코드들 부터 읽기 시작한다.

인터넷매물 BETWEEN 조건절 시작 값이 3인 구간에서도 전체를 다 읽지 않고 후행조건보다 큰 값을 만나는 순간 스캔을 멈춘다.

하지만 BETWEEN 조건절 중간에 걸친 2 구간에서는 전체 레코드를 다 읽어야만 한다.

# BETWEEN을 IN-LIST로 전환

범위검색 컬럼이 맨 뒤로 가도록 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷 매물] 순으로 변경하면 좋겠지만 운영 시스템에서

인덱스 구성을 바꾸기는 쉽지 않다. 이럴 때 BETWEEN 조건을 in-list로 바꿔주면 큰 효과를 얻는 경우가 있다.

```sql
SELECT 층, 평당가, 입력일, 도, 매물구분, 일수, 업소코드
FROM 매물아파트매매
WHERE 인터넷매물 in ('1', '2', '3')
AND 평형 = '59'
AND 평형타입 = 'A'
AND 아파트시세코드 = 'A010...'
ORDER BY 입력일 DESC
```

IN-LIST로 변경하면 인덱스 수직적 탐색이 세 번 발생한다.

이때의 실행계획은 아래와 같다.

```sql
SELECT STATEMENT
  INLIST ITERATOR
    TABLE ACCESS BY INDEX ROWID
      INDEX RANGE SCAN
```

dbmd_xplan, display_cursor 함수를 이용해 ROW SOURCE 별 수행 통계를 출력해 보면 아래와 같이 INDEX RANGE SCAN 단계의 STARTS 항목이 3으로 나타난다. 이를 통해 인덱스를 세 번 탐색한다는 사실을 알 수 있다.

인덱스를 세 번 탐색한다는 것은 SQL을 아래와 같이 작성한 것과 같다. 모든 컬럼이 = 조건이다.

```sql
SELECT 층, 평당가, 입력일, 도, 매물구분, 일수, 업소코드
FROM 매물아파트매매
WHERE 인터넷매물 = '1'
AND 평형 = '59'
AND 평형타입 = 'A'
AND 아파트시세코드 = 'A010...'
union all
SELECT 층, 평당가, 입력일, 도, 매물구분, 일수, 업소코드
FROM 매물아파트매매
WHERE 인터넷매물 = '2'
AND 평형 = '59'
AND 평형타입 = 'A'
AND 아파트시세코드 = 'A010...'
union all
SELECT 층, 평당가, 입력일, 도, 매물구분, 일수, 업소코드
FROM 매물아파트매매
WHERE 인터넷매물 = '3'
AND 평형 = '59'
AND 평형타입 = 'A'
AND 아파트시세코드 = 'A010...'
ORDER BY 입력일 DESC
```

IN-LIST 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 = 조건으로 검색하므로 앞서 선두 컬럼에서 BETWEEN을 사용할때의 비효율(인덱스 스캔범위가 넓어짐으로 인해 발생하는 비효율)이 사라진다.

INDEX SKIP SCAN 방식으로 유도해도 비슷한 효과를 얻을 수 있다.

IN-LIST 항목 개수가 늘어나 IN-LIST 방식으로 전환하기 곤란하다면 아래처럼 NL 방식의 조인문이나 서브쿼리로 구현하면 된다.

물론 IN-LIST 값들을 코드 테이블로 관리하고 있을 때 가능한 방식이다.

```sql
select /*+ordered use_nl(b)*/ b.해당층, b.평당가, b.입력일
, b.해당동 , b.매물구분 , b.연사용일수 , b.중개업소코드
from 통합코드 a, 매물아파트매매 b
where a.코드구분 = 'cd064' -- 인터넷 매물 구분
and a.코드 between '1' and '3'
and b.인터넷매물 = a.코드
and b.아파트시세코드 = 'A01011350900056'
and b.평형 = '59'
and b.평형타입 = 'A'
order by b.입력일 desc
```

## BETWEEN 조건을 IN-LIST로 전환할때 주의 사항

IN-LIST 개수가 많지 않아야 한다. IN-LIST 개수가 많으면 수직적 탐색이 많이 발생한다.

그러면 BETWEEN 조건 때문에 리프블록이 많이 스캔하는 비효율보다 IN-LIST 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 크다.

루트에서 브렌치 블록까지 DEPTH가 깊을 때 특히 그렇다.

또한 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.

아래 조건절을 보면 [고객등급 + 고객번호] 순으로 구성한 인덱스에서 고객번호 = 123 조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때만 BETWEEN 조건을 IN-LIST로 전환하는 기법이 유용하다.

레코드간의 거리가 가까울때 IN-LIST로 변환하면 효과가 전혀 없거나 수직적 탐색 때문에 오히려 블록 I/O가 더 많이 발생한다.

고객등급의 DISTINCT가 높으면 후행 조건을 IN-LIST로 변환해도 큰 효과가 없다.

정리하면, BETWEEN 조건 때문에 인덱스를 비효율적으로 스캔하더라도 블록 I/O측면 에서는 대개 소량에 그치는 경우가 많다.

인덱스 리프 블록에는 테이블 블록과 달리 매우 많은 레코드가 담기기 때문이다.

게다가 IN-LIST 개수가 많으면 수직적 탐색과정에서 이미 많은 블록을 읽게 된다. 데이터 분포나 수직적 탐색 비용을 따져봐야한다.

---

# 3.3.7 INDEX SKIP SCAN 활용

BETWEEN 조건을 In-list 조건으로 변환하면 도움이 되는 상황에서 굳이 조건절을 바꾸지 않고도 같은 효과를 낼 방법이 있다.
INDEX SKIP SCAN을 활용하는 것이다.

```sql
-- 2018 1월 부터 12월 까지 월별로 10만 개 (총 120만 개) 판매데이터 입력
-- 판매 구분 별로는 'A'가 10만 개, 'B'가 110만 개.
create table
as
select rownum
        , '2018' || lpad(ceil(rownum/100000), 2, '0') 판매월
        , decode(mod(rownum, 12), 1, 'A', 'B') 판매구분
        , round(dbms_random.value(1000, 100000), -2) 판매금액
from dual
connect by level <= 1200000;

-- 테이블을 이용해 아래와 같은 COUNT 쿼리 수행
SELECT COUNT(*)
FROM 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '201801' and '201812'
```

위의 쿼리를 최적으로 수행하려면 '=' 조건인 판매구분이 선두컬럼에 위치하도록 아래와 같이 인덱스를 구성해야 한다.

```sql
create index 월별고객별판매집계_IDX1 on 월별고객별판매집계(판매구분, 판매월);

-- 인덱스를 사용할때의 트래이스 결과로, 281개의 블록 I/O가 발생하고 테이블 액세스는 발생하지 않는다.
-- SORT AGGREGATE (CR=281 pr = 0 pw = 0)
-- INDEX RANGE SCAN 월별고객별판매집계_IDX1(cr=281)

```

이번에는 BETWEEN 조건의 판매월 컬림이 선두인 아래의 인덱스를 사용하는 경우를 보자
판매구분 A인 레코드는 각 판매월별 앞쪽에 위치하며, 전체에서 차지하는 비중이 8.3% 에 불과하므로 서로 멀리 떨어지게 된다.

```sql
create index 월별고객별판매집계_IDX2 on 월별고객별판매집계(판매월, 판매구분);

-- 인덱스를 사용할때의 트래이스 결과로, 3090개의 블록I/O가 발생하고 테이블 액세스는 발생하지 않는다.
-- SORT AGGREGATE (CR=3090 pr = 0 pw = 0)
-- INDEX RANGE SCAN 월별고객별판매집계_IDX2(cr=3090)

```

테이블을 전혀 방문하지 않았는데도 I/O가 많이 발생한 이유는, 인덱스 선두 컬럼이 BETWEEN 조건이어서 판매구분이 'B' 인 레코드까지 모두 스캔하고서 버렸기 때문이다.

앞서 설명한 튜닝 방식을 적용해 BETWEEN 조건을 IN-LIST로 전환하고 다시 실행해보자.

```sql
select /*+index( t 월별고객판매집계_IDX2)*/
count(*)
FROM 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 in ('201801','201802' ... '201812')
-- 인덱스를 사용할때의 트래이스 결과로, 281개의 블록I/O가 발생하고 테이블 액세스는 발생하지 않는다.
-- SORT AGGREGATE (CR=314 pr = 0 pw = 0)
-- INLIST ITERATOR (CR=314 pr = 0 pw = 0)
-- INDEX RANGE SCAN 월별고객별판매집계_IDX2(cr=314)

```

3090개 이던 블록 I/O 개수가 314개로 감소하였다. 인덱스 브랜치 블록을 열두 번 반복 탐색했지만, 리프블록을 스캔할 때 비효율을 제거함으로써 성능이 열 배 좋아졌다.

마지막으로 INDEX SKIP SCAN 으로 유도해 보자

```sql
select /*+index_ss( t 월별고객판매집계_IDX2)*/
count(*)
FROM 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '201801' and '201812'

-- SORT AGGREGATE (CR=300 pr = 0 pw = 0)
-- INDEX SKIP SCAN 월별고객별판매집계_IDX2(cr=300)

```

인덱스 선두 칼럼이 BETWEEN 조건인데도 큰 비효율 없이 단 300 블록만 읽고 일을 마쳤다.

선두 컬럼이 BETWEEN 이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, INDEX SKIP SCAN의 위력이 나타난다.

---

# 3.3.8 IN 조건은 = 인가

SQL 튜닝 입문자에게서 흔히 볼 수 있는 현상은 IN 조건을 = 조건과 동등시한다는 점이다.

아래 SQL에 대한 인덱스를 [상품ID + 고객번호] 로 설계할 때와 [고객번호 + 상품ID] 로 설계할 때 차이가 있는지 보면 쉽게 알 수 있다.

흔히 차이가 없다고 생각하지만 IN 조건은 '=' 가 아니다. 따라서 어떻게 인덱스를 구성하느냐에 따라 성능도 달라질 수 있다.

```sql
-- Index : [상품id + 고객번호]
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
and 상품 ID in ('nh0037', 'nh0041', 'nh0050')
```

고객별가입상품테이블에서 고객번호의 평균 카디널리티는 3이라고 가정하자. 즉 고객별로 평균 세건의 상품을 가입한다.

인덱스를 [상품id + 고객번호] 순으로 생성하면, 상품 id는 고객번호 순으로 정렬된 상태로 하나(또는 연속된 두 개)의 리프블록에 저장된다.

반면 고객번호는 상품ID에 따라 뿔뿔이 흩어진 상태가 된다. 인덱스가 이렇게 구성돼 있다면, 상품ID 조건절이 IN-LIST ITERATOR 방식으로 풀리는 것이 효과적이다.

고객번호 조건을 만족하는 레코드가 서로 멀리 떨어져 있기 때문이다. 상품 ID 조건절이 IN-LIST ITERATOR 방식으로 풀린다는 것은 SQL 이 아래와 같은 방식으로 실행된다는 의미다.

IN 조건이 = 조건이 됐다.

```sql
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :Cust_no
AND 상품ID = 'nh00037'
union all
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :Cust_no
AND 상품ID = 'nh00041'
union all
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :Cust_no
AND 상품ID = 'nh00050'
```

상품 ID 조건절을 이처럼 IN-LIST ITERATOR 방식으로 풀면 고객번호와 상품ID 둘 다 인덱스 엑세스 조건으로 사용된다. 인덱스를 수직으로 세번 탐색하며, 그 과정에서 아홉 개 블록을 읽는다.

지금과 같은 인덱스 구성에서는 상품ID 조건절이 IN-LIST ITERATOR 방식으로 불려야 효과적일 뿐만 아니라 반드시 그렇게 풀려야만 한다. 인덱스를 정상적으로 사용하려면 수직적 탐색을 통해 스캔 시작점을 찾아야한다.

상품 ID가 인덱스 선두 컬럼인 상황에서 IN LIST ITERATOR 방식으로 풀지 않으면, 상품 ID는 필터 조건이므로 테이블 전체 또는 인덱스 전체를 스캔하면서 필터링해야한다.

이번에는 인덱스를 [고객번호 + 상품ID] 순으로 생성해 보자. 그러면 같은 고객은 상품 ID 순으로 정렬된 상태로 같은 리프블록에 저장된다.

여기서도 상품 ID 조건절을 IN-LIST ITERATOR 방식으로 풀면, 인덱스를 수직적으로 세 번 탐색하는 과정에서 아홉개 블록을 읽는다.

상품 ID 조건절을 풀지않으면 상품 ID 조건절은 필터로 처리한다. 그러면 고객번호만 엑세스 조건이므로 특정 고객번호 레코드를 모두 스캔한다. 같은 고객은 한 블록에 모여있으므로 블록 I/O는 수직적 탐색 과정을 포함해 총 세 개 만 발생한다.

요컨대, IN 조건은 = 이 아니다. IN 조건이 = 이 되려면 IN-LIST ITERATOR 방식으로 풀려야만 한다. 그렇지 않으면 IN 조건은 필터 조건이다.

그러데 과연 IN 조건을 = 조건으로 만들기 위해, 즉 액세스 조건으로 만들기 위해 IN-LIST ITERATOR 방식으로 푸는 것이 항상 효과적인가?

방금 본 사례에서 상품ID가 엑세스 조건으로 의미있는 역할을 하려면, 고객번호 별 상품ID 데이터가 아주 많아야 한다. 그렇지 않은 상황에서는 필터 방식으로 처리되는게 오히려 낫다.

더 쉬운 예로 상품 테이블 인덱스가 아래와 같이 구성돼 있다.

상품\_PK : 상품\_ID

상품\_X01: 상품\_ID + 상품구분코드

아래는 조회한 상품(상품\_ID = :PROD_ID)의 상품구분코드가 GX 또는 KR이면 데이터를 출력하는 쿼리문이다.
상품구분코드 조건은 X01 인덱스에 대한 필터 조건으로 사용되고 있다.

```sql
select * from 상품
where 상품ID = :PROD_ID
and 상품구분코드 in ('gx', 'kr')

-- execution plan
-- select statement
--  table access (by index rowid) of '상품'(table)
--    index (range scan) of '상품_x01'

-- predicate information
-- access('상품_id' = : prod_id)
-- filter("상품구분코드" = 'gk' or '상품구분코드' = 'kr')
```

지금 같은 상황에서 X01 인덱스 스캔을 IN-LIST ITERATOR 방식으로 유도하면 성능향상에 도움이 될까?
아니면 인덱스를 상품구분코드 + 상품ID 로 변경하면 성능향상에 도움이 될까?

그렇지 않다. 상품ID가 UNIQUE 하다는데 힌트가 있다.

## NUM-INDEX-KEYS 힌트 활용

다음 주제로 넘어가기 전에 IN-LIST를 액세스 조건 또는 필터 조건으로 유도하는 방법을 살펴보자.
인덱스가 [고객번호 + 상품ID] 순으로 구성된 상황에서 고객번호만 인덱스 엑세스 조건으로 사용하려면 아래와 같이 힌트를 사용하면 된다.
num_index_keys 힌트의 세 번째 인자 1은 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미다.

```sql
SELECT /*+NUM-INDEX-KEYS(a 고객별가입상품_x1 1)*/ *
FROM 고객별가입상품 a
WHERE 고객번호 = :cust_no
and 상품 ID in ('Nh0037', 'nh0041', 'nh0050')

-- execution plan
-- select statement
  -- table access (by index rowid) of '상품'(table)
    -- index (range scan) of '상품_x01'

-- predicate information
-- access('고객번호' = TO_NUMBER(:CUST_NO))
-- filter("상품ID" = 'nh00037' or "상품ID" = 'nh00041' or "상품ID" = 'nh00050')
```

힌트를 사용하지 않고 인덱스 컬럼을 가공하는 방법도 있다.

```sql
SELECT
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
and RTRIM(상품ID) in ('Nh0037', 'nh0041', 'nh0050')

SELECT
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
and 상품ID || '' in ('Nh0037', 'nh0041', 'nh0050')
```

상품 ID 까지 인덱스 엑세스 조건으로 사용하려면, 아래와 같이 힌트를 사용하면 된다.
실행 계획을 보면 상품ID가 IN-LIST ITERATOR 방식으로 풀리면서 인덱스 액세스 조건으로 사용된다.

```sql
SELECT /*+num_index_keys(a 고객별가입상품_x1 2)*/ *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
and 상품 ID in ('Nh0037', 'nh0041', 'nh0050')

-- execution plan
-- select statement
  -- INLIST ITERATOR
    -- table access (by index rowid BATCHED) of '고객별가입상품'(table)
      -- index (range scan) of '고객별가입상품_x01'

-- predicate information
-- access('고객번호' = : TO_NUMBER(:CUST_NO))
-- AND ("상품ID" = 'nh00037' or "상품ID" = 'nh00041' or "상품ID" = 'nh00050')
```

---

# BETWEEN & LIKE 스캔 범위 비교

월별로 집계된 테이블에서 2019년 1월부터 12월 데이터를 조회하고자 할 때, 흔히 아래와 같이 LIKE 연산자를 사용한다.

```sql
select * from 월별고객판매집계
where 판매월 like '2019%'
```

BETWEEN 이 더 정확한 표현식인데도 LIKE를 선호하는 이유는 LIKE로 코딩하는 것이 더 편리하기 때문이다.

```sql
select * from 월별고객판매집계
where 판매월 between '201901' and '201912'
```

LIKE 와 BETWEEN 은 둘 다 범위 검색 조건으로, 사용할때의 비효율 원리가 똑같이 적용된다.

하지만 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있다.

결론부터 말하면, LIKE 보다 BETWEEN을 사용하는 것이 낫다.

인덱스를 [판매월 + 판매구분] 순으로 구성했다. 판매구분으로는 A 와 B 두개의 값이 존재하고, 각각 90%와 10%의 비중을 차지하는 상황에서 아래 두 조건절에 대한 인덱스 스캔량을 비교해보자

```sql
-- 조건절 1
WHERE 판매월 BETWEEN '201901' AND '201912'
AND 판매구분 = 'B'

-- 조건절 2
WHERE 판매월 LIKE '2019%'
AND 판매구분 = 'B'
```

조건절 1은 판매월 = '201901' 이고 판매구분 = 'B' 인 첫 번째 레코드에서 스캔을 시작한다.
반면 조건절 2는 판매월 = '201901' 인 첫 번째 레코드에서 스캔을 시작한다. 혹시라도 '201900' 이 저장돼 있다면 그 값도 읽어야 하므로 판매구분 = 'B' 인 지점으로 바로 내려갈 수 없다.

이번에는 판매구분 'A' 와 'B' 두 값이 각각 10%와 90% 비중을 차지한다고 가정하고, 아래 두 조건절에 대해 인덱스 스캔량을 비교해 보자.

```sql
-- 조건절 3
WHERE 판매월 BETWEEN '201901' AND '201902'
AND 판매구분 = 'A'

-- 조건절 4
WHERE 판매월 LIKE '2019%'
AND 판매구분 = 'A'
```

조건절 3은 판매월 '201902' 이고 판매구분 = 'B' 인 레코드를 만나는 순간 스캔을 멈춘다. 반면 조건절 4는 판매월 = '201912' 인 레코드를 모두 스캔하고나서야 멈춘다, 혹시라도 '201913' 이 저장돼 있다면 그 값도 읽어야 하므로 중간에 멈출 수 없다.

---

# 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

사용자 입력과 선택에 따라 조건절이 다양하게 바뀔 때 SQL을 간편하게 작성하려고 조건절을 모두 LIKE로 구사하는 경우가 있는데 해당 컬럼이 인덱스 구성 칼럼일 때는 주의가 필요하다.

예를 들어, 회사코드, 지역코드, 상품명 등을 입력함으로써 '가입상품' 테이블에서 데이터를 조회하는 프로그램이 있다고 하자.
조회 화면에서 회사코드를 반드시 입력하지만 지역코드는 입력하지 않을 수도 있다.

그리고 상품명은 단어중 일부만 입력할 수 있다. 따라서 이 프로그램은 내부에서 아래 두 쿼리 중 하나를 선택적으로 사용할 것이다.

```sql
-- 쿼리 1 : 회사코드, 지역코드, 상품명을 모두 입력할 때
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 = :com
AND 지역코드 = :reg -- 선택조건
AND 상품명 LIKE :prod || '%'

-- 쿼리 2 : 회사코드, 상품명만 입력할 때
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 = :com
AND 상품명 LIKE :prod || '%'
```

인덱스를 [회사코드 + 지역코드 + 상품명] 순으로 구성했다고 하자.
사용자가 회사코드, 지역코드, 상품명에 각각 'C70', '02', '보급'을 입력하고 조회했을 때의 인덱스 스캔 범위와 지역코드를 입력하지 않고 조회했을 때의 스캔 범위를 비교해보자.

인덱스 중간컬럼(지역코드) 에 대한 조건이 없을 때는 어쩔 수 없이 넓은 범위를 스캔하지만 중간컬럼이 있을 때는 세 컬럼 모두 엑세스 조건이므로 아주 적은 범위만 스캔하고 빠르게 결과를 출력한다.

그런데 이 두 가지 상황에 대한 SQL을 하나로 처리하려고 아래와 같이 지역코드 컬럼 조건절에 LIKE 연산자를 사용했다면, 조회 성능에 어떤 영향을 미칠까?

```sql
SELECT 고객ID, 상품명, 지역코드, ...
FROM 가입상품
WHERE 회사코드 = :com
AND 지역코드 LIKE :reg || '%'
AND 상품명 LIKE :prod || '%'
```

지역 코드를 입력 하지 않은 경우 위의 쿼리 2와 스캔범위가 같지만, 지역 코드를 입력한 경우 쿼리1의 스캔범위에 비해 인덱스 스캔 범위가 늘어난 것을 볼 수 있다. 앞서 액세스 조건이던 상품명이 필터 조건으로 바뀌면서 생긴 변화다.

또 다른 예로, 아래와 같이 모든 조건절을 BETWEEN 으로 처리하는 쿼리가 있다. 이 역시 옵션 조건을 처리하기 위해 고안한 방법이다.

```SQL
WHERE 거래일자 BETWEEN :시작일자 AND :종료일자                -- 필수
AND 종목코드 BETWEEN :종목1 AND :종목2                      -- 옵션
AND 투자자유형코드 BETWEEN :투자자유형1 AND :투자자유형2         -- 옵션
AND 주문매체구분코드 BETWEEN :주문매채구분코드1 AND :주문매채구분2  -- 옵션
```

예를 들어, 종목코드에 최대 6자리까지 입력 가능하다고 할 때, 종목코드를 입력하면 양쪽 변수에 같은 값을 입력한다. 종목코드를 입력하지 않으면 왼쪽변수에는 '**\_\_**', 오른쪽변수에는 'ZZZZZZ'를 입력한다. 이렇게 입력하면 모든 종목코드가 조회된다.

옵션 조건이 3개이므로 나올 수 있는 모든 경우의 수만큼 총 여덟 개의 SQL을 작성해야 하는데, 이 방식을 사용하면 SQL 하나로 모든 경우를 다 처리할 수 있다. 개발 생산성에서 보면 좋은 아이디어라고 생각할 수 있지만, 인덱스 스캔 효율을 고려한다면 사용을 자제해야하다.

코딩을 쉽게 하려고 이처럼 인덱스 컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율이 생긴다. 인덱스 스캔 비효율이 성능에 미치는 영향이 적을 수도 있지만, 대량 테이블을 넓은 범위로 검색할 때 그 영향이 매우 클 수도 있다. 데이터 분포에 따라 인덱스 커럼에 대한 비교 연산자를 신중하게 선택해야한다.

---

# 다양한 옵션 조건 처리 방식의 장단점 비교

방금 살펴본 두 가지 외에도 옵션 조건에 개발자들이 다양한 방식을 사용하는데, 각각의 장단점을 비교해 보자.

## OR 조건 활용

옵션 조건 처리에 아래와 같이 OR 조건을 사용할 수 있다.

```sql
select * from 거래
where (:cust_id is null or 고객ID = :cust_id)
and 거래일자 between :dt1 and :dt2

-- EXECUTION PLAN
SELECT STATEMENT
  TABLE ACCESS (FULL) OF '거래' (TABLE)
```

개발자들이 흔히 사용하는 이 방식의 가장 큰 문제점은 (옵티마이저에 의한 OR EXPANSION 쿼리 변환이 기본적으로 작동하지 않으므로) 옵션 조건 컬럼을 선두에 두고 [고객 ID + 거래일자] 순으로 인덱스를 구성해도 인덱스를 사용할 수 없다는데 있다.

따라서 인덱스 선두 칼럼에 대한 옵션 조건에 OR 조건을 사용해선 안된다.

[거래일자 + 고객ID] 순으로 구성한 인덱스는 사용할 수 있다. 하지만 고객 ID를 필터 조건으로 사용한다는 문제가 있다. 인덱스 스캔 단계에서 필터링해도 비효율적인데, 심지어 아래와 같은 테이블 액세스 단계에서 필터링한다.

거래일자 BETWEEN 조건을 찾기위해 인덱스에서 100만 건을 스캔한다면, 그만큼 테이블을 랜덤 액세스한 후에 고객ID를 필터링한다는 뜻이다. 그렇다면 OR 옵션조건으로 처리한 고객ID를 인덱스에 포함할 필요조차 없다.
(인덱스에 NOT NULL 컬럼이 포함된 경우, 즉 모든 테이블 레코드가 인덱스에 저장돼 있음이 보장되는 경우 18C 버전부터 OR 조건도 인덱스 필터로 처리되기 시작했다.)

```sql
 -- EXECUTION PLAN
 -- SELECT STATEMENT
 --  FILTER
 --   TABLE ACCESS (BY INDEX ROWID) OF '거래' (TABLE)
 --      INDEX (RANGE SCAN) OF '거래_IDX3' (INDEX)

-- predicate information
-- filter (To_date(:DT1) <= TO_DATE(:DT2))
-- filter(:cust_id is null or '고객ID' = TO_NUMBER(:CUST_ID))
-- ACCESS ("거래일자" >= :DT1 AND '거래일자' <= :DT2)

```

인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 어차피 테이블에서 필터링할 수 밖에 없으므로 그럴 때는 OR 조건을 사용해도 무방하다. OR 조건을 활용한 옵션 조건 처리를 정리하면 다음과 같다.

\- 인덱스 엑세스 조건으로 사용 불가

\- 인덱스 필터 조건으로도 사용 불가

\- 테이블 필터 조건으로만 사용 가능

\- 단, 인덱스 구성 컬럼 중 하나 이상이 NOT NULL 칼럼이면, 18C 부터 인덱스 필터 조건으로 사용가능

이러 특성을 고려한다면, OR 조건을 이용한 옵션 조건 처리는 가급적 사용하지 않아야 한다. 이런 방식의 유일한 장점은 옵션 조건 컬림이 NULL 허옹 컬럼이더라도 결과집합을 보장한다는 것 뿐이다.

참고로 아래와 같은 형태의 OR조건절은 OR-EXPANSION을 통해 인덱스 사용이 가능하다.

```sql
select * from 거래
WHERE 고객ID = :cust_id
AND
(:dt_type = 'A' AND 거래일자 between :dt1 and :dt2)
OR
(:dt_type = 'B' AND 거래일자 between :dt1 and :dt2)

-- EXECUTION PLAN
-- SELECT STATEMENT
--  CONCATENATION
--    FILTER
--      TABLE ACCESS ( BY LOCAL INDEX ROWID) OF '거래' (TABLE)
--        INDEX (RANGE SCAN) OF '거래_idx1' (INDEX) -- 고객ID + 거래일자
--    FILTER
--      TABLE ACCESS ( BY LOCAL INDEX ROWID) OF '거래' (TABLE)
--        INDEX (RANGE SCAN) OF '거래_idx2' (INDEX) -- 고객ID + 거래일자
```

---

# LIKE/BETWEEN 조건 활용

앞에서 설명한 것 처럼 LIKE/BETWEEN 도 옵션 조건 처리를 위해 많이 사용하는 방식 중 하나다. 아래와 같이 변별력이 좋은 필수 조건이 있는 상황에서 이들 패턴을 사용하는 것은 나쁘지 않다.

필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면 LIKE/BETWEEN 이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있기 때문이다.

```sql
-- 인덱스 : 등록일시 + 상품분류코드
SELECT * FROM  상품
WHERE 등록일시 >= trunc(sysdate) -- 필수 조건 (당일 등록 상품)
and 상품분류코드 like :prd_cls_cd || '%' -- 옵션 조건
```

더구나, 필수 조건이 아래와 같이 = 이면 옵션 조건인 상품분류코드 까지도 인덱스 액세스 조건이므로 최적의 성능을 낼 수 있다.

```sql
-- 인덱스 : 상품명 + 상품분류코드
SELECT * FROM  상품
WHERE 상품명 = :prd_nm -- 필수 조건 (당일 등록 상품)
and 상품분류코드 like :prd_cls_cd || '%' -- 옵션 조건
```

문제는 필수 조건의 변별력이 좋지 않을 때다. 예를 들어 아래 SQL에서 상품대분류코드 만으로 조회할 때는 TABLE FULL SCAN이 유리하다. 그런데 옵티마이저는 상품코드까지 입력할 때를 기준으로 INDEX RANGE SCAN을 선택한다.

다행히 상품코드까지 입력하면 최적의 성능을 내갰지만, 그렇지 않을 때 문제가 생긴다.

```sql
-- 인덱스 : 상품대분류코드 + 상품코드
SELECT * FROM  상품
WHERE 상품대분류코드 = :prd_lcls_cd -- 필수 조건
and 상품코드 like :prd_cd || '%' -- 옵션 조건
```

이 외에도 LIKE/BETWEEN 패턴을 사용하고자 할 때는 아래 네 가지 경우에 속하는지 반드시 점검해야 한다.
(BETWEEN 조건은 1번과 2번 조건에 해당하는지만 점검하면 된다.)

1. 인덱스 선두 컬럼

2. NULL 허용 컬럼

3. 숫자형 컬럼

4. 가변길이컬럼

하나씩 살펴보자. 첫째, 인덱스 선두 컬럼에 대한 옵션 조건을 like/between 연산자로 처리하는 것은 금물이다.

예를 들어 [고객ID + 거래일자] 로 구성한 상황에서 고객 ID에 대한 옵션 조건을 아래와 같이 LIKE로 처리했다고 하자.

```sql
SELECT * FROM 거래
WHERE 고객ID LIKE :CUST_ID || '%' -- 옵션 조건
AND 거래일자 between :dt1 and :dt2
```

사용자가 고객ID 값을 입력하면, 둘 다 범위검색 조건이어서 인덱스 스캔과정에서 약간의 비효율이 있더라도 고객 ID가 변별력이 좋기 때문에 비교적 빠르게 조회한다.

그런데 만약 사용자가 고객ID를 입력하지 않으면 인덱스에서 모든 거래 데이터를 스캔하면서 거래일자 조건을 필터링하는 불상사가 발생하다.

옵션 조건 처리를 위와 같이 LIKE/BETWEEN 으로 사용했다면 인덱스를 [거래일자 + 고객ID] 순으로 구성해야 한다. 이때는 고객ID 값을 입력할 때 생기는 비효율을 감수해야한다.

특정 고객의 거래를 조회하고 싶은데도 거래일자 범위에 속한 모든 거래 데이터를 스캔하면서 고객ID 조건을 필터링 하기 때문이다.

둘째, NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것도 금물이다. 성능을 떠나 결과 집합에 오류가 생기기 때문이다. 위 SQL에서 :cust_id 변수에 NULL을 입력하면 조건절은 아래와 같은 형태가 된다.

```sql
SELECT * FROM 거래
WHERE 고객ID LIKE '%'
AND 거래일자 between :dt1 and :dt2
```

거래일자 조건에 해당하는 모든 고객의 거래를 선택해야하는 상황인데, 고객 ID가 NULL 허용컬럼이고 실제 NULL 값이 입력돼 있다면 그 데이터는 결과집합에서 누락된다. BETWEEN 조건을 사용할 때도 컬럼 값이 NULL 인 데이터는 결과집합에서 누락된다.

셋째, 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해선 안된다.
예를 들어, 인덱스[거래일자 + 고객 ID]순으로 구성한 상황에서 SQL을 아래와 같이 작성하면 :cust_id에 값을 입력했을때 두 컬럼 모두 인덱스 액세스 조건으로 사용된다.

```sql
SELECT * FROM 거래
WHERE 거래일자 = :trd_dt
AND 고객_ID like :cust_id || '%
```

그런데 만약 고객 ID가 숫자형 컬럼이면, 아래와 같이 자동 형변환이 일어나므로 고객ID가 필터 조건으로 사용된다.
특히 특정 고객의 하루 치 거래를 조회하고 싶은데 하루 치 거래가 모두 스캔되면서 고객 ID 조건을 필터링 한다는 뜻이다.

```sql
SELECT * FROM 거래
WHERE 거래일자 = :trd_dt
AND TO_CHAR(고객_ID) like :cust_id || '%
```

[고객ID + 거래일자] 순으로 구성된 인덱스는 아예 사용할 수 없다.

넷째, LIKE 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다. 예를 들어 고객명 컬럼에 길이가 다른 값이 입력될 수 있다. 그런데 고객명에 대한 옵션조건을 아래와 같이 lIKE 패턴으로 처리하면 '김훈' 고객을 찾기 위해 :cust_nm 변수에 김훈을 입력했을때 김훈남도 같이 검색된다.

```sql
where 고객명 like :cust_nm || '%' -- :cust_nm = '김훈'
```

따라서 칼럼 값 길이가 가변적일 때는 변수 길이가 같은 레코드만 조회되도록 아래와 같은 조건절을 추가해야한다.

```sql
where 고객명 like :cust_nm || '%' -- :cust_nm = '김훈'
and length(고객명) = length(nvl(:cust_nm, 고객명))
```

또는

```sql
where 고객명 like :cust_nm
```

'%' 없는 LIKE 조건이므로 '=' 조건처럼 :cust_nm에 입력한 값과 정확히 일치하는 고객명만 출력한다.
단, 사용자가 고객명을 입력하지 않으면 어떤 고객도 출력되지않는다.

## UNION ALL 활용

아래와 같이 UNION ALL을 활용하는 방법도 있다. :cust_id 변수에 값을 입력했는지에 따라 위 아래 중 하나만 실행되게 하는 방식이다.

```sql
-- cust_id :선택조건
SELECT * FROM 거래
WHERE :cust_id is null
AND 거래일자 between :dt1 and :dt2
union all
SELECT * FROM 거래
WHERE :cust_id is not null
AND 거래일자 between :dt1 and :dt2
```

아래는 위 SQL에 대한 실행계획인데 :cust_id 변수에 값을 입력하지 않으면 위쪽 브랜치에서 거래일자가 선두인 인덱스를 이용하고,
변수에 값을 입력하면 아래쪽 브랜치에서 고객ID + 거래일자 인덱스를 사용하고 있다.

```sql
-- EXECUTION PLAN
SELECT STATEMENT
  UNION ALL
    FILTER
      TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래'
        INDEX(RANGE SCAN) OF '거래_IDX1' (INDEX) -- 거래일자
     FILTER
      TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래'
        INDEX(RANGE SCAN) OF '거래_IDX2' (INDEX) -- 고객id + 거래일자
```

이 패턴을 사용하면 :cust_id 변수에 값을 입력하든 안 하든, 인덱스를 가장 최적으로 사용한다.

위쪽 브랜치에서는 거래일자, 아래쪽 브랜치에서는 고객ID와 거래일자 모두 액세스 조건으로 사용하기 때문이다.

-- LIKE 패턴도 인덱스 사용은 가능하지만 필수조건인 거래일자가 BETWEEN 이면 옵션 조건 컬럼을 필터조건으로 사용한다.

반면 UNION ALL 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 매우 중요하다.

고객 ID 가 NULL 허용 컬럼이더라도 사용하는데 전혀 문제가 없다. 유일한 단점은 코딩량이 길어진다는 점이다.

## NVL/DECODE 함수활용

```sql
SELECT * FROM 거래
WHERE 고객ID = NVL(:CUST_ID, 고객ID)
AND 거래일자 between :dt1 and :dt2

또는

SELECT * FROM 거래
WHERE 고객ID = decode(:CUST_ID, null, 고객ID, :CUST_ID)
AND 거래일자 between :dt1 and :dt2
```

위 SQL에 대한 실행계획이다. :cust_id 변수에 값을 입력하지 않으면 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고,
변수에 값을 입력하면 아래쪽 브랜치에서 [고객ID + 거래일자] 인덱스를 사용한다는 것을 표현하고 있다. NVL, DECODE 둘 중 어느 것을 사용하든 실행계획은 똑같다.

```sql
-- EXECUTION PLAN
-- SELECT STATEMENT
--  CONCATENATION
--    FILTER -- :CUST_ID IS NULL
--      TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래'
--        INDEX(RANGE SCAN) OF '거래_IDX1' (INDEX) -- 거래일자
--     FILTER -- :CUST_ID IS NOT NULL
--      TABLE ACCESS (BY LOCAL INDEX ROWID) OF '거래'
--        INDEX(RANGE SCAN) OF '거래_IDX2' (INDEX) -- 고객id + 거래일자
```

고객ID 컬럼을 함수 인자로 사용했는데도 인덱스를 사옹할 수 있는 이유는 'OR EXPANSION' 이 일어나기 때문이다.
앞서 살펴본 UNION ALL 방식으로 옵티마이저가 쿼리를 변환한 것이다.

만약 이 기능이 작동하지 않으면 NVL, DECODE 함수를 사용하는 패턴도 인덱스 액세스 조건으로 사용이 불가능하다.
:cust_id에 값을 입력하지 않으면 (고객 ID가 null 이면) 조건절이 '고객ID = 고객ID' 형태가 되므로 인덱스에서 이 조건을 만족하는 어느 한 시작점을 찾을 수 없기 때문이다.

이 방식의 가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는 점이다. 즉, UNION ALL 보다 단순하면서도 UNION ALL 같은 성능을 낸다.

단점은 앞서말한 LIKE 패턴처럼 NULL 허용 컬럼에 사용할 수 없다는 데 있다. 조건절 변수에 NULL을 입력하면 값이 NULL인 레코드가 결과집합에서 누락되기 때문이다.

옵션 조건 처리용 NVL/DECODE 함수를 여러 개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR EXPANSION 이 일어난다는 사실도 기억해야한다.

따라서 OR EXPANSION 기준으로 선택되지 않으면 인덱스 구성 컬럼이어도 모두 필터 조건으로 처리된다.

NVL/DECODE 함수의 장점에도 불구하고 모든 옵션 조건을 이 방식으로 처리할 수 없는 이유가 여기 있다.

옵션 처리 조건은 성능 컨설팅을 수행하면서 가장 어려운 주제이다.

지금까지 설명한 여러 방식의 장단점을 이해함으로써 상황에 따라 선택할 수 밖에 없다.

### DYNAMIC SQL

DYNAMIC SQL을 이용해 조건절을 동적으로 구성할 수 있는 시스템에서는 옵션 조건에 = 연산자를 사용할 수 있다.

DYNAMIC SQL을 이용해 옵션 조건에 = 연산자를 사용할 경우, 변별력 있는 컬럼을 액세스 조건으로 사용할 수 있게 인덱스만 잘 구성해주면 된다.

그런데 DYNAMIC SQL을 허용하지 않는 시스템도 있고 허용하더라도 힌트로 액세스 경로를 고정하려고 할때 옵션 조건 튜닝 기법을 적절히 활용해야 한다.

DYNAMIC SQL에 옵티마이저 힌트를 명시하면 동적으로 구성된 조건절과 서로 상충함으로 인해 오히려 성능 문제를 야기할 수 있다.

DYNAMIC SQL를 이용하더라도 하드 파싱에 의한 성능 문제가 발생하지 않도록 바인드 변수를 잘 사용해야한다. 조건절을 동적으로 구성한다고 해서 입력 값 까지 동적으로 변경할 이유는 없다.

---

# 3.3.12 함수호출부하 해소를 위한 인덱스 구성

## PL/SQL 함수의 성능적 특성

PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 매우 느리다. 예를 들어, 아래처럼 한두 번 호출할 때는 함수를 사용하지 않았을 때와 비교해 성능 차이를 느끼기 힘들다.

```sql
select 회원번호,..., encryption(전화번호)
from 회원
where 회원번호 = :member_no -- 단 건 조회

select 회원번호,..., encryption(전화번호)
from 회원
where 생월일 like '01%' -- 수십 ~ 수백 만 건 조회
```

PL/SQL 사용자 정의 함수가 느린 데는 아래 3가지 이유가 있다

\- 가상머신 상에서 실행되는 인터프리터 언어

\- 호출 시마다 컨텍스트 스위칭 발생

\- 내장 SQL에 대한 RECURSIVE CALL 발생

오라클에서 PL/SQL 로 작성한 함수와 프로시저를 컴파일하면 JAVA 언어처럼 바이트코드를 생성해서 데이터 딕셔너리에 저장하며, 이를 해석할 수 있는 PL/SQL 엔진 만 있으면 어디서든 실행할 수 있다.

PL/SQL 엔진은 바이트코드를 런타임 시 해석하면서 실행한다.

PL/SQL 은 JAVA 처러 인터프리터 언어이기 때문에 NATIVE코드로 완전 컴파일된 내장 함수에 비해 많이 느리다

PL/SQL 함수는 실행 시 매번 SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 일어난다. 일반 프로그래밍 언어에서는 함수를 이용해 모듈화, 공용화하는 것을 권장하지만 PL/SQL 함수를 그런 식으로 활용하면 안되는 이유가 여기 있다.

PL/SQL 사용자 정의 함수의 성능을 떨어뜨리는 가장 결정적인 요소는 RECURSIVE CALL 이다.
아래 SQL에서 조건을 만족하는 회원이 100만 명이면 GET_ADDR도 100만번 실행되는데 만약 함수에 SQL이 내장돼 있으면 그 SQL도 100만번 실행된다.

대개 PL/SQL 함수에는 SQL이 내장되있으므로 부하가 가장 크다

```sql
select 회원번호,..., GET_ADDR(우편번호)
from 회원
where 생월일 like '01%' -- 수십 ~ 수백 만 건 조회
```

위 SQL에 PL/SQL 함수를 쓰지않고 아래와 같이 조인문으로 처리하면 성능 차이가 매우 크다.

```sql
select a.회원번호, ... , (
  select b.시도 || ' ' || b.군구 || ' ' || b.읍면동
  from 기본주소 b
  where b.우편번호 = a.우편번호
  and b.순번 = 1
) 기본주소
from 회원 a
where 생월일 like '01%' -- 수십 ~ 수백 만 건 조회

select a.회원번호, ... , b.시도 || ' ' || b.군구 || ' ' || b.읍면동 as 기본주소
from 회원 a , 기본주소 b
where a.생월일 like '01%' -- 수십 ~ 수백 만 건 조회\
and b.우편번호(+) = a.우편번호
and b.순번(+) = 1

```

PL/SQL 함수 내부 로직이 너무 복잡하면 그대로 쓸 수 밖에 없는데 그럴 때 함수 호출 횟수를 줄이는 방법은 액세스 조건을 고려한 인덱스 구성이다.

## 효과적인 인덱스 구성을 통한 함수호출 최소화

조건절에 아래와 같이 PL/SQL 함수를 사용했을때, 회원 테이블을 FULL SCAN 방식으로 읽으면 함수는 테이블 건수만큼 수행된다.

```SQL
SELECT /*+full(A)*/ 회원번호, ... , 등록일자
from 회원 a
where 암호화된_전화번호 = encrypion(:phone_no)
```

아래와 같은 다른 조건절이 있으면 함수는 그 조건절에 해당하는 만큼만 수행된다.

```SQL
SELECT /*+full(A)*/ 회원번호, ... , 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encrypion(:phone_no)
```

아래와 같이 인덱스 세 개를 생성한다.

```sql
create index 회원_x01 on 회원(생년);
create index 회원_x02 on 회원(생년, 생월일, 암호회된_전화번호);
create index 회원_x03 on 회원(생년, 암호회된_전화번호);
```

아래와 같이 생년 단일컬럼으로 구성된 인덱스를 사용하면, '암호화된\_전화번호' 조건절을 테이블 엑세스 단계에서 필터링 한다.
따라서 encryption 함수는 테이블 액세스 횟수 즉, 생년 = '1987' 조건을 만족하는 건수만 수행된다.

```sql
select /*+index(a 회원_x01)*/ 회원번호, ... , 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encrypion(:phone_no)

-- execution plan
select statement
  table access by index rowid batched of '회원'
    index range scan of '회원_x01'

-- predicate information
filter(암호화된_전화번호 = encrypion(:phone_no))
access ("생년" = '1987')
```

아래와 같이 [생년 + 생월일 + 암호화된_전화번호] 순으로 구성된 인덱스에서는 암호화된\_전화번호는 선행 컬럼인 생월일에 대한 = 조건이 없으므로 인덱스 필터 조건이다.

따라서 encrypion 함수는 인덱스 스캔 횟수 즉 생년 = '1987' 조건을 만족하는 건수 만큼 수행된다.

```sql
select /*+index(a 회원_x02)*/ 회원번호, ... , 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encrypion(:phone_no)

-- execution plan
select statement
  table access by index rowid batched of '회원'
    index range scan of '회원_x02'

-- predicate information
access ("생년" = '1987' AND 암호화된_전화번호 = encrypion(:phone_no))
FILTER (암호화된_전화번호 = encrypion(:phone_no))
```

마지막으로 [ 생년 + 암호화된_전화번호 ] 로 구성된 인덱스에서는
암호화된\_전화번호도 생년과 함께 인덱스 액세스 조건으로 사용 된다 따라서 encryption 함수는 단 한 번 수행된다

```sql
select /*+index(a 회원_x03)*/ 회원번호, ... , 등록일자
from 회원 a
where 생년 = '1987'
and 암호화된_전화번호 = encrypion(:phone_no)

-- execution plan
select statement
  table access by index rowid batched of '회원'
    index range scan of '회원_x03'

-- predicate information
access ("생년" = '1987' AND 암호화된_전화번호 = encrypion(:phone_no))
```
