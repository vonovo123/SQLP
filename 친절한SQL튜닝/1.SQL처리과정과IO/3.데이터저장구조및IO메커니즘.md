SQL 튜닝의 원리를 제대로 이해하려면 I/O에 대한 이해가 중요하다.
데이터 저장 구조, 디스크 및 메모리에서 데이터를 읽는 메커니즘을 차례로 살펴보자.

# 1.3.1 SQL이 느린 이유

SQL이 느린 이유는 디스크 I/O 때문이다.

I/O는 SLEEP 이다. OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다. 프로세스가 일을 하지 않고 잠을 자는 이유는 여러 가지가 있지만, I/O 가 가장 대표적이고 절대적인 비중을 차지한다.(여기서 I/O 는 디스크 I/O) 를 말한다.

프로세스는 '실행 중인 프로그램'이며, 생명주기를 갖는다. 즉, 생성 이후 종료 전까지 준비와 실행과 대기 상태를 반복한다. 프로세스는 interrupt에 의해 수시로 실행 준비 상태로 전환했다가 다시 실행 상태로 전환한다. 여러 프로세스가 하나의 CPU 를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이러 메커니즘이 필요하다.

INTERRUPT 없이 열심히 일하던 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 SLEEP 상태서 I/O가 완료되길 기다린다. 정해진 OS 함수(I/O CALL)를 호출하고 CPU를 반환한 채 알람을 설정하고 대기 큐에서 잠을 자는 것이다. 열심히 일해야할 프로세스가 잠을 자고 있으니 I/O가 많으면 성능이 느릴 수 밖에 없다.네

I/O CALL의 속도는 SINGLE BLOCK I/O를 기준으로 평균 10ms 정도다. 초당 100 블록쯤 읽는 셈이다. 큰 캐시를 가진 SAN 스토리지는 4~8ms 정도롤 초당 125~250 블록 쯤 읽는다.

SSD 까지 활용하는 최근 스토리지는 1~2ms로 초당 500~1000 블록을 읽는다.

스토리지의 성능이 빨라지고 있지만 여전히 우리 기대에는 못 미친다. 어떤 SQL이 SINGLE BLOCK I/O로 1만 블록을 읽는다면, 가장 최신 스토리지에서도 10초 이상 기다려야한다.
전반적으로 I/O 튜닝이 안 된 시스템이라면, 수 많은 프로세스에 의해 동시다발적으로 발생하는 I/O CALL 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어난다.
결과적으로 디스크 I/O 가 SQL의 성능을 좌우한다.

---

# 1.3.2 데이터베이스 저장 구조

데이터를 저장하려면 먼저 테이블스페이스를 생성해햐 한다. 테이블스페이스는 세그먼트를 담는 콘테이너로서, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성된다.

테이블스페이스를 생성하고나면 세그먼트를 생성한다. 세그먼트는 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트다. 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에 저장할지를 지정한다.

세그먼트는 여러 익스텐트로 구성된다. 파티션 구조가 아니라면 테이블도 하나의 세그먼트이고 인덱스도 하나의 세그먼트이다. 테이블 또는 인덱스가 파티션 구조라면, 각 파티션이 하나의 세그먼트가 된다.

LOB 칼럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.

익스텐트는 공간을 확장하는 단위다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족하면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 익스텐트는 연결된 블록들의 집합이기도 하다.

익스텐트 단위로 공간을 확장하지만, 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이다. 한 블록은 하나의 테이블이 독점한다. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블의 레코드이다.

한 익스텐트도 하나의 테이블이 독점한다. 즉, 하 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.

테이블스페이스, 세그먼트, 익스텐트, 블록 간 관계뿐만 아닌라, 이들과 데이터 파일 간의 관계도 알아둘 필요가 있다.

세그먼트 공간이 부족하면 테이블스페이스로부터 익스텐트를 추가로 할당받는다고 했는데, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있다. 서로 다른 데이터파일에 위치할 가능성이 더 높다.

하나의 테이블스페이스를 여러 데이터파일로 구성하면, 파일의 경합을 줄이기 위해 DMBS가 데이터를 가능한 한 여러 데이터파일로 분산해서 저장하기 때문이다.

익스텐트 내 블록은 서로 인접한 연속한 공간이지만, 익스텐트끼리는 연속된 공간이 아니다. 오라클에서 세그먼트에 할당된 익스텐트 목록을 조회하는 방법은 다음과 같다.

```SQL
SELECT SEGMENT_TYPE, TABLESPACE_NAME, EXTENT_ID, FILE_ID, BLOCK_ID, BLOCKS
FROM dba_extents
WHERE owner = USER
AND SEGMENT_NAME = 'MY_SEGMENT'
ORDER BY EXTENT_ID;

```

이 세그먼트에 할당된 2번 익스텐트는 2번 데이터 파일 1번 블록으로부터 연속된 네 개 블록으로 이루어져있다. 바로 뒤에 할당된 3번 익스텐트는 그래서 5번 블록부터 시작한다. 다른 익스텐트들은 직전 익스텐트와 인접하지 않는다.

\* DATA BLOCK ADDRESS (DBA)

모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유한 주소값을 갖는다. 이 주소 값을 DBA라고 부른다. 데이터를 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 DBA 부터 확인해야 한다.

인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 이용한다. ROWID는 DBA + ROWID NUMBER(블록 내 순번) 로 구성되므로 이를 분해하면 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.

테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다. 익스텐트 맵을 통해 각 익스텐트의 첫 번째 블록 DBA를 알 수 있다. 익스텐트는 연속된 블록 집합이므로 테이블을 스캔할 때는 첫 번째 블록 뒤에 연속해서 저장된 블록을 읽으면 된다.

테이블 스페이스를 구성하는 요소들을 간단히 정의하면 다음과 같다.

\- 블록 : 데이터를 읽고 쓰는 단위

\- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합

\- 세그먼트 : 데이터 저장공간이 필요한 오브젝트 (테이블, 인덱스, 파티션, LOB 등)

\- 테이블스페이스 : 세그먼트를 담는 콘테이너

\- 데이터 파일 : 디스크 상의 물리적인 OS 파일

---

# 1.3.3 블록단위 I/O

블록은 DBMS가 데이터를 읽고 쓰는 단위다. 데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 블록을 통째로 읽는다.

예를들어 테이블에 네 개 블록이 할당됏는데, 4번째 블록 에는 현재 데이터가 하나도 입력되지 않은 상태다.

오라클은 기본적으로 8KB 크기의 블록을 사용하므로 1Byte를 읽기 위해 8KB를 읽는 셈이다.

```sql
-- 오라클 데이터베이스의 블록 사이즈를 확인하는 방법이다.
show parameter block_size

-- V$PARAMETER 뷰를 직접 조회할 수도 있다.
select value from v$parameter where name = 'db_block_size';
```

테이블뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다.

---

# 시퀀셜 엑세스 vs. 랜덤 액세스

테이블 또는 인덱스 블록을 엑세스하는 방식으로는 시퀀셜 액세스와 랜덤 액세스 두 가지가 있다.

첫째, 시퀀셜 액세스는 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 인덱스 리프 블록은 앞뒤를 가리키는 주소갚을 통해 논리적으로 서로 연결돼 있다. 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 엑세스다.

데이터 블록간에는 서로 논리적인 연결고리를 갖고 있지 않다. 그럼, 테이블은 어떻게 시퀀셜 방식으로 엑세스 할까?

오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다. 익스텐트 맵은 각 익스텐트의 첫 번째 블록 주소 값을 갖는다. 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 TABLE FULL SCAN이다.

둘째, 랜덤 엑세스는 논리적, 물리적이 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

---

# 논리적 I/O VS. 물리적 I/O

## DB 버퍼캐시

SQL을 수행하는 과정에 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것은 매우 비효율 적이다. 모든 DBMS에 데이터 캐싱 메커니즘이 필수인 이유이다.

2절에서 공유메모리 SGA 구성요소로서 '라이브러리 캐시'를 살펴봤는데, 데이터를 캐싱하는 'DB 버퍼캐시' 도 SGA의 중요한 구성요소 중 하나다.

라이브러리 캐시가 SGL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 '코드 캐시'라고 한다면, DB 버퍼캐시는 '데이터 캐시'라고 할 수 있다.

디스크에서 어렵게 읽은 데이터 블록을 캐싱함으로써 같은 블록에 대한 반복적인 I/O CALL을 줄이는 데 목적이 있다.

서버 프로세스와 데이터파일 사이에 버퍼캐시가 존재하므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다.

운 좋게 캐시에서 블록을 찾는다면 프로세스가 SLEEP 상태에 빠지지 않는다. 버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다.

```sql
-- 버퍼캐시 사이즈를 확인하는 방법이다.
show sga
```

## 논리적 I/O vs. 물리적 I/O

논리적 블록 I/O 는 SQL문을 처리하는 과정에 메모리 버퍼캐시가 발생한 총 블록 I/O를 말한다. DIRECT PATH I/O 가 작동하는 경우가 있어 논리적 I/O 와 메모리 I/O 가 정확히 같은 의미는 아니지만, 일반적으로 같다고 생각할 수 있다.

물리적 블록 I/O 는 디스크에서 발생한 총 블록 I/O 를 말한다. SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O 한다.

메모리 I/O는 전기적 신호인 데 반해, 디스크 I/O는 엑세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다. 보통 10,000배 쯤 느리다. 디스크 경합이 심할 때는 더 느리다.

## 왜 논리적 I/O 인가?

SQL을 수행하려면 데이터가 담긴 블록을 읽어야 한다. SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서 조건절에 같은 변수 값을 입력하면, 아무리 여러 번 실행해도 매번 읽는 블록 수는 같다. SQL을 수행하면서 읽은 총 블록 I/O 가 논리적 I/O 이다.

DIRECT PATH READ 방식으로 읽는 경우를 제외하면 모든 블록은 DB 버퍼캐시를 경유해서 읽는다. 따라서 논리적 I/O 횟수는 DB 버퍼캐시에서 블록을 읽은 횟수와 일치한다. 논리적 I/O 가 메모리 I/O 와 같은 개념은 아니지만, 결과적으로 수치는 같다.

DB 버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O 가 물리적 I/O 다. 데이터 입력이나 삭제가 없어도 물리적 I/O 는 SQL을 실행할 때마다 다르다. 첫 번째 실행할 때보다 두 번째 실행할 때가 줄어들고, 세 번째 실행할 땐 더 줄어든다.

연속해서 실행하면 DB 버퍼캐시에서 해당 테이블 블록의 점유율이 점점 높아지기 때문이다. 한참 후에 다시 실행하면 반대로 물리적 I/O가 늘어난다. DB 버퍼캐시가 다른 테이블 블록으로 채워지기 때문이다.

## 버퍼캐시 히트율

버퍼캐시 효율을 측정하는데 전통적으로 가장 많이 사용해 온 지표는 버퍼캐시 히트율이다. 구하는 공식은 다음과 같다.

```
BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100 = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100 = (1 -( 물리적 I/O )/ ( 논리적 I/O )) * 100

```

공식에서 알 수 있듯 BCHR은 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 나타낸다.

애플리케이션 특성에 따라 다르지만 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99%의 히트율을 달성해야 한다. 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로 열심히 튜닝하면 99&는 결코 달성하기 어려운 수치가 아니다.

BHCR 공식에서 우리는 중요한 성능 원리를 발견할 수 있다. 물리적 I/O 가 성능을 결졍하지만, 실제 SQL 성능을 향상하려면 물리적 I/O 가 아닌 논리적 I/O 를 줄여야 한다는 사실이다.

```
// BCHR 공식을 아래와 같이 변형하면, 쉽게 알 수 있다.

물리적 I/O = 논리적 I/O * (100 - BCHR)
```

논리적 I/O 는 일정하므로 물리적 I/O 는 BCHR에 의해 결정된다. BCHR은 시스템 상황에 따라 달라지므로 물리적 I/O는 결국 시스템 상황에 의해 결정되는 통제 불가능한 외생변수이다.

SQL 성능을 높이기 위해서 할 수 있는 일은 논리적 I/O를 줄이는 일 뿐이다. 예를 들어, 시스템 레밸 BCHR 이 평균 70%라고 할때, 특정 SQL 의 논리적 I/O가 10,000개면 물리적 I/O는 대략 3,000 개쯤 발생할 것으로 예상할 수 있다.

논리적 I/O를 1,000개로 줄이면 물리적 I/O 도 300으로 감소하고, 성능도 10배 향상된다.

그럼, 논리적 I/O 는 어떻게 줄일 수 있을까? SQL을 튜닝해서 읽는 총 블록 개수를 줄이면 된다. 논리적 I/O 는 항상 일정하게 발생하지만, SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생변수이다.

논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다.

요약하면, BCHR 공식을 이루는 물리적 I/O는 통제 불가능한 외생변수이다. 메모리 증설을 통해 버퍼캐시의 크기를 늘리는 방법 외에 이것을 직접 줄일 방법은 없다. 반면, 논리적 I/O 는 통제 가능한 내생변수이다. SQL을 튜닝해서 논리적 I/O 를 줄이면 물리적 I/O 도 줄고 그만큼 성능도 향상된다.

논리적 I/O를 줄이는 구체적인 방법을 이 책 전반에서 다룬다.

BCHR을 실제로 계산해보자. SQL 트레이스를 통해 수집한 정보에서 QURERY 와 CURRENT 항목을 더한 값이 DB 버퍼캐시에서 읽은 총 블록 개수다. DISk 항목은 디스크에서 물리적으로 읽은 블록 개수다.

우선 논리적 I/O 를 구할때, 디스크에서 601,458 개, 메모리에서 1,364,044( = 1,351,677 + 12,367) 블록을 읽었으므로 논리적 I/O는 총 1,965,502개라고 잘못 해석할 수 있다.

하지만 블록을 읽을 때는 해당 블록을 먼저 버퍼캐시에서 찾아보고 없을 때만 디스크에서 읽는다. 이때도 디스크에서 곧바로 읽는 것이 아니라 먼저 버퍼캐시에 적재하고 읽는다.

따라서 DB 버퍼케시에서 읽은 1,364,044개 블록에는 디스크에서 읽은 601,458개 블록이 이미 포함되어 있따.

결과적으로 버퍼캐시에서 읽은 1,364,044개 블록 I/O가 논리적으로 BCHR은 아래와 같이 계산한다.

```
BCHR = ( 1 - ( DISK / (QUERY + CURRENT))) * 100
= (1 - (601,457) / (1,351,6777 + 12,367)) * 100
= 55.9%
```

BCHR에는 주의해야할 함정이 있다. BCHR이 SQL 성능을 좌우하지만, BCHR이 높다고 해서 효율적인 SQL을 의미하지는 않는다는 사실이다.

같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다.

## SINGLE BLOCK I/O vs. MULTIBLOCK I/O

매모리 캐시가 클수록 좋지만, 데이터를 모두 캐시에 적재할 수 없다. 비용적인 한계, 기술적인 한계 때문에 전체 데이터 중 일부만 캐시에 적재해서 읽을 수 있다.
캐시에서 찾지 못한 데이터 블록은 I/O CALL을 통해 디스크에서 DB 버퍼캐시로 적재하고 읽는다.
I/O call 할 때, 한 번에 한 블록씩 요청하기도 하고, 여러 블록씩 요청하기도 한다. 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 'single block i/o' 라고 한다.
한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식을 MULTIBLOCK I/O 라고 한다.

익덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 SINGLE BLOCK I/O 방식을 사용한다. 구체적으로 아래 목록이 SINGLE BLOCK I/O 대상 오퍼레이션다. 인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다.

\- 인덱스 루트 블록을 읽을 때
\- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
\- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
\- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

반대로, 많은 데이터 블록을 읽을 때는 MULTIBLOCK I/O 방식이 효율적이다. 그래서 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다. 테이블이 클수록 MULTOBLOCK I/O 단위도 크면 좋다. 프로세스가 잠자는 횟수를 줄여준다.

읽고자 하는 블록을 DB 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O CALL을 한다. 그 동안 프로세스는 데기 큐에서 잠을 잔다. 대용량 테이블이면 수 많은 블록을 디스크에서 읽는 동안 여러 차례 잠을 잘 텐데, 한번에 많은 양을 요청해야 잠자는 횟수가 줄어들어 성능이 높아진다.

정리하면, MULTIBLOCK I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O CALL 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이. DBMS 블록 사이즈가 얼마건 간에 OS 단에서는 보통 1MB 단위로 I/O를 수행한다.

오라클에서 한 번에 읽는 블록을 수는 DB_FILE_MULTIBLOCK_READ_COUNT 파라미터로 정한다.

```sql
show parameter db_file_multiblock_read_count

alter session set db_file_multiblock_read_count = 128;
```

일반적으로 OS 레벨 I/O 단위가 1MB, 오라클 레벨 단위가 8KB 이므로 이 파라미터를 128로 설정하면 담을 수 있는 만큼 최대한 담게된다 (8KB \* 128 = 약 1MB). 그 이상은 담을 수 없으므로 그 이상의 값으로 설정해도 소용이 없다.

인접한 블록이란 같은 익스텐트에 속한 블록을 의미한다. MULTIBLOCK I/O 방식으로 읽더라도 익스텐트 경게를 넘지 못한다. 예를 들어 한 익스텐트에 20개 블록이 담겨 있고 MULTIBLOCK I/O 단위가 8이라고 할 때, 세 번째 I/O call 에는 4개 블록만 얻게 된다.

나머지 4개를 더 읽기 위해 다음 익스텐트까지 읽지 않는다.

### TABLE FULL SCAN VS. INDEX RANGE SCAN

테이블에 저장된 데이터를 읽는 방식은 두가지다. 테이블 전체를 스캔해서 읽는 방식과 인덱스르 이용해서 읽는 방식이다. 전자를 TABLE FULL SCAN 이라하고 후자는 INDEX RANGE SCAN, 보통 인덱스를 이용한 테이블 엑세스라고 표현한다.

TABLE FULL SCAN 은 말 그대로 테이블에 속한 블록 '전체'를 읽어서 사용자가 원하는 데이터를 찾는 방식이다. 인덱스를 이용한 테이블 엑세스는 인덱스에서 '일정량'을 스캔하면서 얻은 ROWID로 데이블 레코드를 찾아가는 방식이다.

ROWID는 테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 위치 정보이다.

토드, 오렌지를 포함한 쿼리 툴이 TABLE FULL SCAN을 빨간색으로 표시해준다. 위험경고인 셈이다. 그래서 개발자들이 실행계획을 분석할 때 TABLE FULL SCAN이 나타나는지 주로 확인한다.

TABLE FULL SCAN 찾아내기 식 실행계획 분석은 실제로 SQL 성능을 향상하는데 큰 도움이 되지 않는다. 인덱스를 사용해야 하는 상황인데 TABLE FULL SCAN 하는 경우도 있으므로 전혀 의미가 없다고 할 수는 없지만 TABLE FULL SCAN 를 피해야 한다는 인식과 달리 인덱스가 SQL 의 성능을 떨어뜨리는 경우도 많다.

한 번에 많은 데이터를 처리하는 집계용 SQL과 배치 프로그램들이 특히 그렇다. 이들 프로그램에서 사용하는 SQL은 온라인 SQL 보다 튜닝하기가 쉽다. 상당수가 TABLE FULL SCAN 으로 유도하면 성능이 빨라진다. 조인을 포함한 SQL이면 조인 메소드로 해시 조인을 선택해주면 된다.

인덱스를 이용한 스캔인데 왜 성능이 더 느릴까?

TABLE FULL SCAN 은 시퀀셜 엑세스와 MULTIBLOCK I/O 방식으로 디스크 블록을 읽는다. 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고, 케시에서 못 찾으면 한번의 I/O CALL을 통해 인접한 수십~수백 개 블록을 한꺼번에 I/O 하는 메커니즘이다. 이 방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 스캔성능도 좋아진다.

시퀀셜 엑세스와 MULTIBLOCK I/O가 아무리 좋아도 수십~수백 건의 소량 데이터를 찾을 때 수백~수천만 건 데이터를 스캔하는 것은 비효율적이다.

큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 한다.

INDEX RANGE SCAN을 통한 테이블 엑세스는 랜덤 엑세스와 SINGLE BLOCK I/O 방식으로 디스크 블록을 읽는다.

캐시에서 블록을 못 찾으면 레코드 하나를 읽기 위해 매번 잠을자는 식의 메커니즘이다. 따라서 많은 데이터를 읽을 때는 TABLE FULL SCAN 보다 불리하다.

이 방식을 사용한 SQL은 스토리지 스캔 성능이 수십 배 좋아져도 성능 향상이 미미하다.

게다가 이 방식은 읽었던 블록을 반복해서 읽는 비효율이 있다. 많은 데이터를 읽을 때 물리적인 블록 I/O 뿐만 아니라 논리적인 블록 I/O 측면에서도 불리하다는 애기다.

한 블록에 평균 500 개의 레코드가 있으면 같은 블록을 최대 500번 읽는다. 만약 인덱스를 이용해 전체 레코드를 엑세스 해야한다면 모든 블록을 평균 500번씩 읽게 되는 셈이다. 각 블록을 단 한 번 읽는 TABLE FULL SCAN 보다 불리하다.

데이터베이스를 효과적으로 이용하는데있어 인덱스의 중요성은 아무리 강조해도 지나치치 않다. 하지만 인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾기 위한 도구일 뿐이므로 모든 성능 문제를 인덱스로 해결하려 해선 안된다. 읽은 데이터가 일정량을 넘으면 인덱스 보다 TABLE FULL SCAN이 유리하다.

## 캐시 탐색 메커니즘

DIRRECT PATH I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다. 구체적으로, 아래 오퍼레이션은 모두 버퍼캐시 탐색 과정을 거친다.

\- 인덱스 루트 블록을 읽을 때
\- 인덱스 루트 블록에서 얻은 정보로 브랜치 블록을 읽을 때
\- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
\- 인덱스 리프블록에서 얻은 주소 정보로 테이블 블록을 읽을때
\- 테이블 블록을 FULL SCAN 할 때

버퍼캐시 탐색 매커니즘을 설명하기에 앞서 버퍼캐시 구조부터 살펴보자. DBMS는 버퍼캐시를 해시 구조로 관리한다.

캐시 탐색 메커니즘이 5로 나누었을 때 나머지 값을 반환하는 모듈러 함수를 해시 함수로 사용한다고 가정하자.

예를 들어, 버퍼캐시에서 20번 블록을 찾고자 한다. 블록 번호를 5로 나누면 나머지가 0이다. 이 블록이 캐싱돼 있다면 버퍼 헤더가 첫 번째 해시 체인(해시 값 0)에 연결돼 있을 것이므로 찾을 때 항상 첫 번째 해시 체인만 탐색하면 된다.

다른 예로 27번 블록은 블록 번호를 5로 나누면 나머지가 2이다. 만약 이 블록이 캐싱돼 있다면 버퍼 헤더가 세번째 해시 체인(해시 값 2)에 있을 것이다. 만약 세 번째 체인에 없다면 다른 해시 체인을 탐색할 필요가 없다.

디스크로 부터 읽어서 세 번째 체인에 연결해서 읽으면 된다.

정리하면 버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.

해시 구조의 특징을 요약하면, 다음과 같다.

\- 같은 입력 값은 항상 동일한 해시 체인에 연결된다.

\- 다른 입력 값이 동일한 해시 체인에 연결될 수 있다.(해시함수의 알고리즘에 따라)

\- 해시 체인 내에서는 정렬이 보장되지 않는다.

## 메모리 공유자원에 대한 액세스 직렬화

버퍼캐시는 SGA 구성요소이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이다. 공유자원은 말 그대로 모두에게 권한이 있기 때문에 누구나 접근할 수 있다. 문제는 하나의 버퍼블록을 두 개 이상 프로세스가 동시에 접근하려고 할 때 발생한다.

동시에 접근하면 블록 정합성에 문제가 생길 수 있기 때문이다.

따라서 자원을 공유하는것 처럼 보여도 내부에선 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위해 직렬화 메커니즘이 필요하다. 직렬화를 이해하기 쉽게 표현하면 줄 세우기 다.

공유캐시의 특정 자원을 두 개 이상 프로세스가 같이 사용할 수 없다. 같이 사용하는 것 처럼 보이더라도, 특정 순간에는 한 프로세스만 사용할 수 있다. 그 순간 다른 프로세스는 줄을 서서 기다려야 한다. 이런 줄서기가 가능하도록 지원하는 메커니즘이 래치이다.

SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하는데, 버퍼캐시에는 캐시버퍼 체인래치, 캐시버퍼 LRU 체인 래치 등이 작동한다. 빠른 데이터베이스를 구현하려면 버퍼캐시 히트율이 높아야 하지만 캐시 I/O 도 생각만큼 빠르지 않을 수 있다. 래치에 의한 경합이 생길 수 있기 때문이다.

캐시버퍼 체인뿐만 아니라 버퍼블록 자체에도 직렬화 메커니즘이 존재한다. 바로 버퍼 lock 이다. 직렬화 메커니즘에 의한 캐시 경합을 줄이려면, SQL 튜닝을 통해 쿼리의 일량 자체를 줄여야 한다.
