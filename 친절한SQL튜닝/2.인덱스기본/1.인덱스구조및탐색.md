인덱스 구조와 탐색 원리는 기본적인 내용이지만 중요하다. 인덱스에 대한 명확한 그림이 없는 상태에서 인덱스를 설계하고 SQL을 개발하면 성능이 좋을리가 없다.

가장 중요한 내용은 인덱스 탐색과정이 수직적 탐색과 수평적 탐색, 단 두 개로 이루어진다 이것을 이해하고 나면 막연하게 생각했던 인덱스 구조에 대한 그림이 명확해진다. 그런 후에야 인덱스 사용법과 튜닝도 제대로 이해할 수 있다.

# 2.1.1 미리 보는 인덱스 튜닝

## 데이터를 찾는 두 가지 방법

어떤 초등학교를 방문해 '홍길동' 학생을 찾는 방법은 두 가지다. 첫째는, 1학년 1반부터 6학년 맨 끝반까지 찾는 방법과 교무실에서 학생명부를 조회해 홍길동 학생이 있는 교실만 찾아가는 것이다.
홍길동 학생이 많다면 전자가 빠르고, 몇 안 되면 후자가 빠르다.

이름으로 학생을 찾는 방문객이 많다면, 학생명부를 아예 이름순으로 정렬해두면 편리하다. 이것이 바로 인덱스이다. '학년-반-번호' 칼럼이 인덱스의 ROWID에 해당한다.

데이터베이스 테이블에서 데이터를 찾는 방법도 아래 두 가지다.

\- 테이블 전체를 스캔한다.

\- 인덱스를 이용한다.

앞의 예에서 모든 교실을 돌며 학생을 찾는 경우가 전자에 속하고, 이름순으로 정렬한 학생명부를 이용하는 경우가 후자에 속한다. 테이블 전체 스캔과 관련해서는 튜닝 요소가 많지 않지만 인덱스와 관련해서는 튜닝 요소가 매우 많고 기법도 다양하다.

그래서 인덱스는 SQL 튜닝을 공부할 때 가장 먼저 다루어야 할 주제다.

## 인덱스 튜닝의 두 가지 핵심요소

인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 온라인 트랙잭션 처리(ONLINE TRANSACTION PROCESSING 이하 'OLTP') 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다.

세부적인 인덱스 튜닝 방법에는 여러 가지가 있지만, 핵심요소는 크게 두 가지로 나뉜다.

첫 번째는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다. 즉, '인덱스 스캔 효율화 튜닝' 이다.

학생 명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 예로 들어보자. 학생 명부를 이름과 시력 순으로 정렬해 두었다면 (홍길동, 1.0, 2학년 6반 24번) 칼럼부터 (홍길동, 1.5, 5학년 1반 16번) 칼럼까지 소량만 스캔하면 된다.

반면, 학생명부를 시력과 이름순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 (1.0, 홍길동, 5학년 1반 16번) ~ (1.5, 홍길동, 1학년 5반 15번) 사이의 시력이 1.0 이상 1.5 이하이고 다른 이름과 반을 가진 학생들에 해당하는 많은 컬럼을 스캔해야 한다. 이는 시력보다 이름의 구분도가 작기 때문이다. 이름이 홍길동인 사람보다 시력이 1.0인 사람이 훨씬 많다.

익덱스 튜닝의 두 번째 핵심요소는 테이블 액세스 횟수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 '랜덤 액세스 최소화 튜닝' 이라고 한다.

학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 다시 생각해 보자. 시력이 1.0~1.5 사이인 학생은 50명이고, 이름이 '홍길동' 인 학생은 다섯 명이다. 시력이 1.0~1.5 사이면서 이름이 홍길동 인 학생은 두 명이다.

이름과 시력순으로 정렬한 학생명부가 있으면 가장 좋지만, 이름으로만 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 둘 중에 어느 쪽을 사용해야 더 효과적일까?

당연히 이름순으로 정렬된 학생명부이다. 교실에 찾아가는 횟수를 줄일 수 있기 때문이다. 다섯 번만 찾아가면 되는 반면 시력순으로 정렬한 학생명부를 사용하면, 교실을 50번 찾아가야 한다.

시력이 1.0~1.5 사이면서 이름이 홍길동 인 학생은 두 명이지만 어떤 학생명부를 사용하느냐에 따라 교실 방문횟수는 다르다.

인덱스 스캔효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만, 더 중요한 하나를 고른다면 랜덤 액세스 최소화 튜닝이다. 성능에 미치는 영향이 더 크기 때문이다.

초등학교에서 홍길동 학생을 찾는 예만 보더라도 랜덤 엑세스 튜닝이 더 중요한 이유를 쉽게 알 수 있다. 학생명부를 뒤지는 (스캔) 과정에도 비효율이 있지만, 학생명부에 없는 나머지 정보(시력순으로 정렬한 학생명부를 사용할 때 학생 이름이 여기에 해당)를 얻기 위해 직접 교실을 찾아가는 것이 훨씬 큰 비용이 든다.

## SQL 튜닝은 랜덤 I/O와의 전쟁

데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O 가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

성능을 위해 DBMS가 제공하는 많은 기능이 느린 램덤 I/O 를 극복하기 위해 개발됐다.

조인 메서드중 가장 일반적으로 사용하는 NL조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다. 그래서 소트머지 조인과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위함이다.

## 인덱스 구조

인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스 하기 위해 사용하는 오브젝트다. 모든 책 뒤쪽에 있는 색인과 같은 역할을 한다.

데이터베이스에서도 인덱스 없이 데이터를 검색하려고하면, 테이블을 처음부터 끝까지 모두 읽어야 한다.

반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉 범위 스캔(RANGE SCAN)이 가능하다.

범위스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.

DBMS는 일반적으로 B*TREE 인덱스를 사용한다. B*TREE 인덱스 구조는 나무를 거꾸로 뒤집은 모양이어서 뿌리가 위에 있고, 가지를 거쳐 맨 아래 잎사귀가 있다.

루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소 값을 갖는다. 레코드의 키 값은 하위 블록에 저장된 키값의 범위를 나타낸다. 예를 들어 루트블록의 '서' 레코드가 가리키는 하위 블록에는 '서'보다 크거나 같은 레코드가 저장돼 있다는 뜻이다.
예를 하나 더 들면 오른쪽 브랜치 블록 '이재룡'이 가리키는 하위블록은 '이재룡' 보다 크거나 같은 레코드가 저장돼 있다는 뜻이다.

루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. 가장 왼쪽 첫 번째 레코드다. 이를 'LMC(Leftmost Child)'라고 한다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드 보다 작거나 같은 레코드가 저장돼 있다.

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐 아니라 테이블 레코드를 가리키는 주소값 즉, ROWID를 갖는다.

인덱스 키값이 같으면 ROWID 순으로 정렬된다. 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위함이다.

ROWID는 아래와 같이 데이터 블록주소와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.

\- ROWID = 데이터블록주소(DBA) + 로우 번호
\- 데이터 블록 주소 = 데이터 오브젝트 번호(6) + 데이터 파일번호 + 블록 번호
\- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
\- 로우 번호 : 블록 내 순번

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.

\- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
\- 수평적 탐색 : 데이터를 찾는 과정

인덱스 탐색 과정을 알고 나면 인덱스 구조를 더 잘 이해할 수 있다.

## 2.1.3 인덱스 수직적 탐색

정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, 인덱스 스캔의 시작점을 찾는 과정이다.

인덱스 수직적 탐색은 루트 블록에서부터 시작한다. 루트를 포함해 브랜치 블록에 저장된 각 인덱스는 레코드는 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해 리프블록까지 수직적 탐색이 가능한 이유다.

수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다. 예를 들어 '이재희' 라는 값을 찾는다고 하자.

루트블록의 값은 '서'로 이재희 보다 크거나 같은 값은 없다. 그럴 때는 맨 마지막 '서' 값을 갖는 레코드가 가리키는 하위블록으로 이동하면 된다. 브랜치 블록에서는 이재희 보다 큰 '정재우'를 찾았다. 바로 전 레코드('이재룡')가 가리키는 하위 블록으로 이동하면 된다. 이제 리프 블록에 도달했고 거기서 조건을 만족하는 (고객명='이재희') 첫 번째 레코드를 찾았다.

이번에는 '강덕승'을 찾아보자. 루트 블록에 '강덕승' 보다 큰 값('서')이 있으므로 직전 레코드(LMC)가 가리키는 하위 블록으로 이동한다. 이동한 브랜치 블록에는 찾고자하는 값과 정확히 일치하는 레코드가 있다. 그렇다고 그 레코드가 가리키는 하위블록으로 이동하면 안된다. 바로 직전 레코드(LMC)가 가리키는 하위 블록으로 이동해야 첫 번째 리프 블록 맨 마지막에 저장된 강덕승 레코드를 빠뜨리지 않는다.

수직적 탐색은 '조건을 만족하는 레코드'를 찾는 과정이 아니라 '조건을 만족하는 첫 번째 레코드' 를 찾는 과정이다.

인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산 푯말 같은 역할을 한다. '조건을 만족하는 첫 번째 레코드' 가 목표 지점이다. 푯말을 만날 때마다 어느쪽으로 가면 목표 레코드를 만날 수 있는지 확인하면서 이동한다. 푯말이 알려주는 대로 따라가다 보면 '조건을 만족하는 첫 번째 레코드'를 만날 수 있다.

## 2.1.4 인덱스 수평적 탐색

수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 데이터를 찾는 과정이다. 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결리스트 구조다. 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유다.

인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고 둘째, ROWID를 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 엑세스 한다. 이때 ROWID가 필요하다.

## 2.1.5 결합 인덱스 구조와 탐색

두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. 고객테이블에 성별과 고객명 기준으로 만든 인덱스 구조가 있다. 인덱스에서 '남자 이재희' 고객을 찾는다.

루트 블록을 스캔하다보면 찾고자 하는 값보다 큰 첫 번째 레코드를 만나게 된다. 성별이 '남' 이면서 '최'씨성을 가진 레코드다. 그 레코드가 가리키는 하위 블록으로 내려가면 '이' 씨성을 가진 레코드를 만날 수 없으므로 바로 직전 LMC 레코드가 가리키는 하위 블록, 즉 왼쪽 브랜치 블록으로 이동한다.
왼쪽 브랜치 블록을 스캔하다 보면 찾고자 하는 값보다 큰 첫 번째 레코드를 만나게 된다. 성별이 '남'이면서 '정재우'로 시작하는 이름을 가진 레코드이다('남'&'정재우')다. 이 레코드의 하위 블록으로 내려가면 '이재희' 고객을 만날 수 없으므로 바로 직전 레코드('남'&'이재룡') 레코드가 가리키는 하위 블록으로 이동한다.

이제 리프 블록에 도달했고, 거기서 부터 '남자 이재희' 고객을 찾으면 된다. 리프 블록은 인덱스 키값으로 정렬돼 있으므로 스캔하다가 '남'&'이재희' 보다 큰 값을 만나면 거기서 멈춘다. 수직적 탐색을 거쳐서 찾은 인덱스 스캔 시점이 성별 = '남' 인 첫 번째 레코드가 아니라 성별이 '남' 이면서 고객명 = '이재희' 인 레코드라는 사실을 기억해야 한다.

인덱스 스캔 시작점을 찾는 원리는 알고 있어야 인덱스 기본 사용법과 확장기능 사용법을 정확히 이해할 수 있다.

인덱스룰 고객명 & 성별 순으로 바꿔도 스캔하는 방법은 똑같다.

루트 블록을 스켄하다보면 찾고자 하는 '이' 보다 큰 값은 없다. 그럴 때는 맨마지막 '서'&'남' 값을 갖는 레코드가 가리키는 하위블록으로 이동한다. 브랜치 블록을 스캔하다보면 찾고자 하는 값보다 큰 4번째 레코드(정제우 & 남) 레코드를 만나게 된다. 그 레코드가 가리키는 하위 블록으로 내려가면 '이' 씨 성을 가진 레코드를 만날 수 없으므로 바로직전 (이재룡 & 남) 값을 갖는 레코드의 하위 블록으로 내려간다.

이제 리프블록에 도달했고, 거기서부터 이름이 이재희이고 성이 남인 고객을 찾으면 된다. 리프 블록은 인덱스 키값으로 정렬돼 있으므로 스캔하다가 이재희 & 남 보다 큰 값을 만나면 거기서 멈춘다.

주목할 것은 인덱스를 [고객명 + 성별] 로 구성하든, [성별 + 고객명] 으로 구성하든 읽는 인덱스 블록 개수가 똑같다는 사실이다. 인덱스 구성칼럼을 모두 '=' 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 똑같으므로 성능도 똑같다.

DBMS가 사용하는 B\*TREE 인덱스는 엑셀처럼 평면 구조가 아니다. 다단계 구조이다.

루트에서 브랜치를 거쳐 리프 블록까지 탐색하면서 '여자' 이면서 '유관순' 인 첫 번째 레코드를 찾아간다. 거기서 부터 두 건을 스캔한다. 정확히 말하면, 유관순이 아닌 레코드를 만날때 까치 총 세건을 스캔한다.

인덱스를 [이름 + 성별] 순으로 구성해도 마찬가지다. 따라서 어느 칼럼을 앞에 두든 일량에는 차이가 없다.

\* B\*TREE 에서 B 는 BALANCED 의 약자로 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음을 의미한다. 즉, 루트로부터 모든 리프 블록까지의 높이는 항상 같다.
