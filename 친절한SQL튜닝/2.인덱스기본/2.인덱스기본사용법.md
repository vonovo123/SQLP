인덱스 기본 사용법은 인덱스를 RANGE SCAN 하는 방법을 의미한다. 인덱스를 RANGE SCAN 할 수 없게 되는 이유를 알고나면, 인덱스 RANGE SCAN 하는 방법도 자연스럽게 터득할 수 있다. 인덱스 확장기능은 INDEX RANGE SCAN 이외의 다양한 스캔 방식을 말한다.

# 2.2.1 인덱스를 사용한다는 것

색인에서 특정한 단어를 찾을때 우리의 눈은 순간적으로 우리가 찾는 단어가 위치한 시작지점으로 찾아간다. 그 과정이 수직적 탐색에 해당한다.
이러한 알고리즘이 동작할 수 있는 이유는 색인이 가나다 순으로 정렬돼있기 때문이다. 즉, 우리가 찾고자 하는 단어들이 서로 모여있기 때문이다.

스캔하다가 조건을 만족하지 않는 단어를 만나는 순간 멈출 수 있는 이유도 같다. 색인이 정렬돼 있더라도 가공한 값이나 중간값으로는 스캔의 시작점을 찾을 수 없다. 스캔하다가 중간에 멈출 수도 없다. 찾고자하는 단어들이 흩어져있기 때문이다.

그렇다고 색인을 아예 사용할 수 없는 것은 아니다. 시작점을 찾을 수 없고 멈출 수 없을 뿐이다. 즉, 가공한 값이나 중간값을 찾을 때도 색인을 사용할 수 있지만 색인 전체를 스캔해야 한다.

데이터베이스 세계에서도 마찬가지다. 인덱스 칼럼을 가공하지 않아야 인덱스를 정상으로 사용할 수 있다. '인덱스를 정상적으로 사용한다' 는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.
즉, 리프 블록 일부만 스캔하는 INDEX RANGE SCAN을 의미한다.

인덱스 칼럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다.
즉, 일부가 아닌 전체를 스캔하는 INDEX FULL SCAN 방식으로 작동한다.

# 2.2.2 인덱스를 RANGE SCAN 할 수 없는 이유

"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(RANGE SCAN) 할 수 없다".

모든 SQL 튜닝 책이 공통으로 다루는 내용이다. 기본 중에서도 기본에 해당한다. 튜닝을 공부한 이들 중 이 사실을 모르는 사람은 없다. 그런데 그 정확한 이유는 무엇일까?

인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 나눠서 설명하는 것은 매우 중요하다. 그래야 인덱스를 RANGE SCAN 할 수 없는 이유를 명확히 설명할 수 있기 때문이다.

인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다. INDEX RANGE SCAN에서 RANGE는 범위를 의미한다.

즉, 인덱스에서 일정 범위를 스캔한다는 뜻이다. 일정 범위를 스캔하려면 시작지점과 끝지점이 있어야 한다.

시작점을 찾는 과정이 인덱스로 말하면 수직적 탐색에 해당한다. 데이터베이스에서 아래의 조건절을 처리할 때도 똑같은 과정을 거친다

```sql
-- 2007년 1월에 태어난 학생을 찾는 조건

WHERE 생년월일 BETWEEN '20070101' AND '20070131'
```

만약, 연도와 상관없이 5월에 태어난 학생을 찾는다고 해보자. 스캔 지점은 어디일까? 스캔하다가 어디서 멈춰야할까?

스캔 시작지점과 종료지점을 알 수 없다. 전교생을 다 스캔해야만 한다.

데이터베이스에서 아래 조건절을 처리할 때도 같은 문제에 직면한다. 인덱스에는 가공되지 않은 값이 저장돼 있는데, 가공된 값을 기준으로 검색하면 어디서 스캔을 시작해야 할까?

스캔 시작점을 찾을 수 없다. 스캔 끝지점도 찾을 수 없다. 어디서 스캔을 멈춰야 할지 모른다.

```sql

-- 년도에 상관없이 5월에 태어난 학생을 찾는 조건
WHERE substr(생년월일, 5, 2) = '05'

```

아래 조건절도 마찬가지다. 가공하지 않은 주문수량을 인덱스로 만들었는데, 값이 NULL이면 0으로 치환한 값 기준으로 100 보다 작은 레코드를 찾아 달라고 쿼리를 작성하면 인덱스 스캔 시작점을 찾을 수 없다.
즉, 인덱스를 RANGE SCAN 할 수 없다.

```sql
-- 년도에 상관없이 5월에 태어난 학생을 찾는 조건
WHERE nvl(주문수량, 0) < 100
```

아래와 같이 LIKE 로 중간 값을 검색할 때도 마찬가지다. '대한' 으로 시작하는 값은 특정 구간에 모여 있으므로 RANGE SCAN이 가능하지만 '대한'을 중간값으로 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 RANGE SCAN이 불가능하다.

```sql

-- 중간에 '대한' 을 포함하는 업체명을 찾는 조건
WHERE 업체명 like '%대한%'

```

OR 조건으로 검색하는 경우를 보자. 아래와 같이 OR 조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01012345678 이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없다'.
따라서 OR 조건의 경우 인덱스를 어떤 방식으로 구성해도 RANGE SCAN 을 할 수 없다.

```sql

-- 특정 전화번호 이거나 특정 이름인 고객을 찾는 조건
WHERE (전화번호 = :tel_no OR 고객명 = :cust_nm)

```

---

## OR EXPANSION

아래와 같이 쿼리하면 고객명, 전화번호 인덱스 각각에 대해 INDEX RANGE SCAN이 가능하다.

```sql
SELECT *
FROM 고객
WHERE 고객명 = :cust_nm -- 고객명이 선두 칼럼인 인덱스 RANGE SCAN
UNION ALL
SELECT *
FROM 고객
WHERE 전화번호 = :tel_no -- 전화번호가 선두 컬럼인 인덱스 RANGE SCAN
AND (고객명 <> :cust_nm OR 고객명 IS NULL)
```

OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 'OR EXPANSION' 이라고 한다. 아래 USE_CONCAT 힌트를 이용해 OR EXPANSION 을 유도했을 때의 실행계획이다.

```sql

SELECT /*+ USE_CONCAT */ * FROM 고객
WHERE (전화번호 = :tel_no OR 고객명 = :cust_nm)

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0     CONCATENATION
-- 2  1       TABLE ACCESS (BY INDEX ROWID) OF '고객'(TABLE)
-- 3  2         INDEX (RANGE SCAN) OF '고객_고객명_IDX'(INDEX)
-- 5  4         INDEX (RANGE SCAN) OF '고객_전화번호_IDX'(INDEX)
-- 4  1       TABLE ACCESS (BY INDEX ROWID) OF '고객'(TABLE)
```

위와 같이 옵티마이저의 쿼리 변환이 이뤄지지 않는다면 OR 조건식에는 INDEX RANGE SCAN이 불가능하다.

아래와 같은 IN 조건절은 어떨까? 수직적 탐색을 통해 전화번호가 '01012345678' 이거나 '01098765432' 인 어느 한 지점을 바로 찾을 수 있을까?

```sql
where 전화번호 in (:tel_no1, :tel_no2)
```

불가능하다. IN 조건은 OR 조건을 표현하는 다른 방식일 뿐이다.
다행히 SQL을 아래와 같이 UNION ALL 방식으로 작성하면, 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 RANGE SCAN이 가능하다.

```sql
SELECT *
FROM  고객
WHERE 전화번호 = :tel_no1
UNION ALL
SELECT *
FROM  고객
WHERE 전화번호 = :tel_no2
```

그래서 IN 조건절에 대해 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 INDEX RANGE SCAN을 반복하는 것이다.\
이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다.

```sql

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0     INLIST ITERATOR
-- 2  1       TABLE ACCESS (BY INDEX ROWID) OF '고객'(TABLE)
-- 3  2         INDEX (RANGE SCAN) OF '고객_고객명_IDX'(INDEX)

-- Predicate information
-- 3 - access ("전화번호" =: TEL_NO1 OR "전화번호" =: TEL_NO2 )
```

정리해 보자. '인덱스를 정상으로 사용한다'는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다.
인덱스 컬럼을 변환한 조건절에는 인덱스를 정상적으로 사용할 수 없다. 기본적으로 INDEX RANGE SCAN 이 불가능하다.
단, OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 INDEX RANGE SCAN으로 처리되기도 한다.

# 2.2.3 더 중요한 인덱스 사용 조건

조건절에서 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 그런데 인덱스를 정상적으로 사용하는데 있어 더 중요한 선행조건이 있다.
인덱스를 [소속팀 + 사원명 + 연령] 순으로 구성했다. 아래 조건절에 대해 인덱스를 정상적으로 RANGE SCAN 할 수 있을까?

```sql
SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
FROM 사원
WHERE 사원명 = '홍길동'
```

인덱스를 [소속팀 + 사원명 + 연령] 순으로 구성한다는 의미는 "데이터를 소속팀 순으로 정렬하고 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령순으로 정렬한다" 라는 의미이다.

이는 이름이 같은 사원이더라도 소속팀이 다르면 서로 멀리 떨어지게 된다는 의미이다. 예를 들어, 사원명 = '홍길동' 이라는 조건을 만족하는 데이터는 리프 블록 전 구간에 흩어진다.

이 조건으로 검색하면, 인덱스 스캔 시작점을 찾을 수 없고, 어디서 멈춰야 할지도 알 수 없다. 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야 한다.

인덱스를 RANGE SCAN 하기 위한 가장 첫 번째 조건은 '인덱스 선두 칼럼이 가공되지 않은 상태로 조건절에 있어야 한다' 는 사실이다.

```sql

-- TXA1234_IX02 INDEX : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

SELECT * FROM TXA1234
WHERE 기준연도 = :STDR_YEAR
AND SUBSTR(과세구분코드, 1, 4) = :TXTN_DCD
AND 보고회차 = :RPT_TMRD
AND 실명확인번호 = :RNM_CNFM_NO

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0       TABLE ACCESS (BY INDEX ROWID) OF 'TXA1234'(TABLE)
-- 2  1         INDEX (RANGE SCAN) OF 'TAX1234_IDX02'(INDEX)
```

다시 말하지만, 인덱스를 RANGE SCAN 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절이 있어야 한다. 반대로 말해, 인덱스 선두 칼럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 RANGE SCAN은 무조건 가능하다.

위 사례로 말하면, 인덱스 선두 컬럼인 '기준연도'를 조건절에서 가공하지 않았으므로 인덱스 RANGE SCAN이 가능하다. 문제는 인덱스를 RANGE SCAN 한다고 해서 항상 성능이 좋은 것은 아니다.

인덱스를 활용하면, 즉 인덱스를 RANGE SCAN 하면 항상 성능에 문제가 없을까?

예를 들어 주문상품\_N1 인덱스는 [주문일자 + 상품번호] 순으로 구성돼있다. 주문상품 테이블에 쌓이는 데이터량은 하루 평균 100만 건이라고 가정하자.

아래 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 RANGE SCAN 하는데 문제가 없다. 스캔 시작점을 찾아 스캔하다가 중간에 멈출 수 있다.

그런 의미에서 인덱스를 잘 탄다고 할 수 있다. 그런데 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 잘 따져봐야한다.

```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND 상품번호 LIKE '%PING%';

SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND SUBSTR(상품번호, 1, 4) = 'PING';
```

위 SQL에서 상품번호는 스캔의 범위를 줄이는데 전혀 역할을 하지 못한다. 첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다.

이를 두고 인덱스를 잘 탄다고 하기는 어렵다.

---

## 2.2.4 인덱스를 이용한 소트 연산 생략

다시 말하지만, 인덱스를 RANGE SCAN 할 수 있는 이유는 데이터가 정렬돼 있기 때문이다. 찾고자 하는 데이터가 정렬된 상태로 서로 모여있기 때문에 전체가 아닌 일정 부분만 읽다가 멈출 수 있다.

인덱스 컬럼을 가공해도 인덱스를 사용할 순 있지만, 찾고자 하는 데이터가 전체 구간(테이블 전체 레코드 또는 가공하지 않은 인덱스 선두 컬럼에 의해 선택된 전체 레코드)에 흩어져 있기 때문에 RANGE SCAN이 불가능하거나 비효율이 발생한다

인덱스가 정렬돼 있기 때문에 RANGE SCAN이 가능하고 소트 연산 생략의 효과도 부수적으로 얻게 된다.

PK를 [장비번호 + 변경일자 + 변경순번] 순으로 구성한 상태변경이력 테이블이 있다고 가정하자.

PK 인데스는 장비번호 > 변경일자 > 변경순번 순으로 정렬돼있다. 아래와 같이 장비번호와 변경일자를 모두 = 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다.

```sql
SELECT *
FROM  상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력'(TABLE)
-- 2  1         INDEX (RANGE SCAN) OF '상태변경이력_PK'(INDEX(UNIQUE))
```

옵티마이저는 이런 속성을 활용해 아래와 같이 SQL에 ORDER BY 가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.

아래의 실행계획에는 SORT ORDER BY 연산이 없다. 위 SQL 실행계획과 100% 같은 방식으로 실행하고 있다.

```sql
SELECT *
FROM  상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
ORDER BY 변경순번

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력'(TABLE)
-- 2  1         INDEX (RANGE SCAN) OF '상태변경이력_PK'(INDEX(UNIQUE))
```

만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, 아래와 같이 SORT ORDER BY 연산 단계가 추가된다.

```sql
-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0      SORT (ORDER BY)
-- 2  1       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력'(TABLE)
-- 3  2         INDEX (RANGE SCAN) OF '상태변경이력_PK'(INDEX(UNIQUE))
```

내림차순 정렬에도 인덱스를 활용할 수 있다. 인덱스 리프 블록은 양방향 연결 리스트 구조이다. 오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾기위해 좌측으로 수직적 탐색을 한 후 우측으로 수평적 탐색을 한다.

내림차순 정렬 일때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.

아래의 SQL은 ORDER BY 절에서 내림차순 정렬을 요구하고 있다. 실행계획에 SORT ORDER BY 연산이 없고 INDEX RANGE SCAN 단계에 DESCENDING 이라고 표시된다.

```sql
SELECT *
FROM  상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
ORDER BY 변경순번 DESC

-- EXECUTION PLAN
-- 0      SELECT STATMENT OPTIMIZER=ALL_ROWS
-- 1  0       TABLE ACCESS (BY INDEX ROWID) OF '상태변경이력'(TABLE)
-- 2  1         INDEX (RANGE SCAN DESCENDING) OF '상태변경이력_PK'(INDEX(UNIQUE))
```

---

# 2.2.5 ORDER BY 절에서 컬럼 가공

모든 SQL 튜닝 책이 다루는 명제 '인덱스 칼럼을 가공하면 인덱스를 정상적으로 사용할 수 없다' 에서 말하는 '인덱스 칼럼'은 대개 조건절에 사용한 컬럼을 말한다.

그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 칼럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종있다.

PK를 [장비번호 + 변경일자 + 변경순번] 순으로 구성한 상태변경이럭 테이블이 있다고 가정하자. 아래 SQL도 정렬 연산을 생략할 수 있다.

수직적 탐색을 통해 장비번호가 C인 첫 번째 레코드를 찾아 인덱스 리프 블록을 스캔하면 자동으로 변경일자 + 변경 순번 순으로 정렬되기 때문이다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```

그런데 만약 개발자가 SQL을 아래와 같이 작성했다면 정렬 연산을 생략할 수 있을까? 당연히 생략할 수 없다. 인덱스에서 가공하지 않은 상태로 값을 저장했는데 가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```

주문\_PK 인덱스는 [주문일자 + 주문번호] 순으로 구성돼 있다. 아래 SQL에 주문\_PK 인덱스를 사용하면 선두 컬럼인 주문일자가 = 조건이므로 데이터가 주문번호 순으로 출력된다.
ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다. 그런데도 아래 실행계획에 SORT ORDER BY 연산이 나타난 이유는 무엇일까?

```sql
SELECT *
FROM (
  SELECT TO_CHAR(A.주문번호, 'FM00000') AS 주문번호, A.업체번호, A.주문금액
  FROM 주문 A
  WHERE A.주문일자 = :dt
  AND A.주문번호 > NVL(:next_ord_no, 0)
  ORDER BY 주문번호
)
WHERE ROWNUM <= 30

-- SELECT STATEMENT
--  COUNT STOPKEY
--    VIEW
--      SORT ORDER BY STOPKEY
--        TABLE ACCESS BY INDEX ROWID 주문
--          INDEX RANGE SCAN          주문_PK
```

그 이유는 ORDER BY 절에 기술한 '주문번호'는 순수한 주문번호가 아니라 TO_CHAR(A.주문번호, 'FM0000') 으로 가공한 주문번호를 가리키기 때문이다. 참고로 TO_CHAR 함수에 'FM000000' 옵션을 사용하면, 첫 번째 인자에 입력한 숫자 값을 0으로 시작하는 여섯 자리 문자 값으로 변환해 준다.
예를 들어 1234를 입력하면 문자 '001234'로 변환해 준다.
해결방법은 간단하다. 아래와 같이 ORDER BY 절 주문번호에 A를 붙여 순수한 주문번호로 정렬하도록하면 된다.

```sql
SELECT *
FROM (
  SELECT TO_CHAR(A.주문번호, 'FM00000') AS 주문번호, A.업체번호, A.주문금액
  FROM 주문 A
  WHERE A.주문일자 = :dt
  AND A.주문번호 > NVL(:next_ord_no, 0)
  ORDER BY A.주문번호
)
WHERE ROWNUM <= 30

--SELECT STATEMENT
--  COUNT STOPKEY
--    VIEW
--        TABLE ACCESS BY INDEX ROWID 주문
--          INDEX RANGE SCAN          주문_PK
```

# 2.2.6 SELECT-LIST 에서 컬럼 가공

인덱스를 [장비번호 + 변경일자 + 변경순번] 순으로 구성하면, 아래와 같이 변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 수행하지 않는다. 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최소값이기 때문이다.

```sql
SELECT MIN(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```

변경순번 최대값을 구할때도 마찬가지이다. 정렬 연산을 수행하지 않는다. 최소값을 찾아 수직적 탐색을 할때 왼쪽으로 내려갔다면, 최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다. 수직적 탐색을 통해 조건을 만족하는 가장 오른쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최댓값이다.

```sql
SELECT MAX(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```

인덱스를 이용해 이처럼 정렬 연산 없이 최소 또는 최대값을 빠르게 찾을 때 아래와 같은 실행계획이 나타난다. 실행방식은 실행계획에 표현돼 있는 그대로다. 인덱스 리프 블록의 왼쪽 또는 오른쪽에서 레코드 하나만 읽고 멈춘다.

```sql
-- SELECT STATEMENT
--  SORT AGGREGATE
--        FIRST ROW
--          INDEX RANGE SCAN(MIN/MAX)     상태변경이력_PK
```

그런데 만약 SQL을 아래와 같이 작성하면 어떻게 될까? 정렬 연산을 생략할 수 없다. 인덱스에는 문자열 기준으로 정렬돼 있는데, 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.

```sql
SELECT NVL(MAX(TO_NUMBER(변경순번)),0)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
-- SELECT STATEMENT
--  SORT AGGREGATE
--    INDEX RANGE SCAN     상태변경이력_PK
```

SQL을 아래와 같이 바꾸면 정렬 연산 없이 최종 변경순번을 쉽게 찾을 수 있다. 물론 이렇게 변환하려면 변경순번 값이 고정너비로 입력돼 있어야한다. 애초에 변경순번 데이터 타입을 숫자형으로 설계했으면 튜닝할 일도 안생긴다.

```sql
SELECT NVL(TO_NUMBER(MAX(변경순번)),0)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
-- SELECT STATEMENT
--  SORT AGGREGATE
--    FIRST ROW
--      INDEX RANGE SCAN(MIN/MAX)   상태변경이력_PK
```

또다른 예를 살펴보면 아래 SQL은 장비구분코드 = 'A001'에 해당하는 장비들의 최종 변경일자를 스칼라 서브쿼리를 이용해 상태변경이력 테이블에서 조회하고 있다.
정렬 연산없이 MIN/MAX, FIRST ROW 방식으로 실행하고 있음을 실행계획에서 확인할 수 있다.

```sql
SELECT 장비번호, 장비명, 상태코드
,(SELECT MAX(변경일자)
  FROM 상태변경이력
  WHERE 장비번호 = P.장비번호
) 최종변경일자
FROM 장비 P
WHERE 장비구분코드 = 'A001'

-- SORT AGGREGATE
--  FIRST ROW
--    INDEX RANGE SCAN (MIN/MAX) 상태변경이력_PK
-- TABLE ACCESS BY INDEX ROWID 장비
--  INDEX RANGE SCAN 장비_N1
```

최종 변경일자에 더해 최종 변경순번까지 출력하려면 SQL을 어떻게 작성해야 할까?
아래와 같이 작성할 수 있지만, 상태변경이력 테이블을 여러 번 읽어야 하므로 비효율적이다. PK 컬럼이 더 많아지면 SQL 문도 훨씬 더 복잡해지므로 성능도 나빠진다.

```sql
SELECT 장비번호, 장비명, 상태코드
,(SELECT MAX(변경일자)
  FROM 상태변경이력
  WHERE 장비번호 = P.장비번호
  ) 최종변경일자
,(
  SELECT MAX(변경순번)
  FROM 상태변경이력
  WHERE 장비번호 = P.장비번호
  AND 변경일자 = (
    SELECT MAX(변경일자)
    FROM 상태변경이력
    WHERE 장비번호 = P.장비번호
  )
) 최종변경순번
FROM 장비 P
WHERE 장비구분코드 = 'A001'

```

아래와 같이 작성하면 PK 컬럼이 많아져도 덜 복잡하다. 그래서 이렇게 많이들 코딩한다. 그런데 성능은 어떨까?

```sql
SELECT 장비번호, 장비명, 상태코드, SUBSTR(최종이력, 1, 8) 최종변경일자, SUBSTR(최종이력, 1, 9) 최종변경순번
FROM (
  SELECT 장비번호, 장비명, 상태코드
  ,(
    SELECT MAX(변경일자 || 변경순번)
    FROM 상태변경이력
    WHERE 장비번호 = P.장비번호
  ) 최종이력
  FROM 장비 P
  WHERE 장비구분코드 = 'A001'
)

```

각 장비당 이력이 많지 않으면 크게 상관없지만, 이력이 많다면 성능에 문제가 될 수있는 패턴이다. 인덱스 칼럼을 가공했기 때문이다.

각 장비에 속한 과거 이력 데이터를 모두 읽어야 하므로 장비당 이력 레코드가 많다면 바로 직전에 본 복잡한 SQL 보다 성능이 더 안좋을 수 있다.

아래는 장비당 이력 레코드가 많은 상태에서 수집한 트레이스 결과다. 상태변경이력\_PK 인덱스에서 1,825,000 개 레코드를 읽으면서 6,380개 블록을 읽었다.

메인쿼리 장비 테이블에서 읽은 최종 데이터는 10건 밖에 안된다.

## 자동 형변환

고객 테이블에 생년월일이 선두 컬럼인 인덱스가 있다고 하자. 아래 SQL은 생년월일 컬럼 조건절에서 가공하지 않았는데도 옵티마이저는 테이블 전체 스캔을 택했다. 실행계획 아래쪽 조건절 정보를 보면 그 이유를 알 수 있다.

```sql
SELECT * FROM 고객
WHERE 생년월일 = 19821225

-- EXECUTION PLAN
--      SELECT STATEMENT
--  * 1  TABLE ACCESS (FULL) OF '고객' (TABLE)

-- predicate information
-- 1.filter(TO_NUMBER("생년월일") = 19821225)
```

옵티마이저가 SQL을 아래와 같이 변환했고, 결과적으로 인덱스 칼럼이 가공됐기 때문에 인덱스를 RANGE SCAN 할 수 없게 됐다.

```SQL
SELECT * FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```

이는 고객 테이블 생년월일 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현했기 때문에 나타난 현상이다.
각 조건절에서 양쪽 값이 타입이 다르면 값을 비교할 수 없다. 그럴 때 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS가 있는가 하면, 자동으로 형변환 처리해주는 DBMS도 있다. 오라클은 후자에 속한다.

오라클에서 숫자형과 문자형이 만나면 숫자형이 이긴다. 숫자형 컬럼 기준으로 문자형 컬럼을 숫자형으로 변환한다는 뜻이다.

아래와 같이 날짜형과 문자형이 만나면 날짜형이 이긴다. 이 경우엔 좌변 칼럼 기준으로 우변을 반환하므로 인덱스 사용에 문제가 없다.

```SQL
SELECT * FROM 고객
WHERE 가입일자 = '01-JAN-2018'
```

하지만 성능에 문제가 없더라도 이렇게 코딩해서 안된다. NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과 집합이 틀려질 수 있다. 아래와 같이 날짜 포맷을 정확히 지정해주는 코딩 습관이 필요하다.

```SQL
SELECT * FROM 고객
WHERE 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY')
```

숫자형과 문자형이 만나면 숫자형이 이긴다고 했지만, 연산자가 LIKE일 때는 다르다. LIKE 자체가 문자열 비교 연산자이므로 이때는 문자형 기준으로 숫자형 컬럼이 변환된다.

```sql
SELECT * FROM 고객
WHERE 고객번호 LIKE '9410%'

-- EXECUTION PLAN
-- SELECT STATEMENT
--  TABLE ACCESS (FULL) OF '고객' (TABLE)

-- predicate information
-- filter(TO_CHAR("고객번호") LIKE '9410%')
```

자동 형변환 성능과 관련해 주의할 사항이 있다. 인덱스 스캔 효율에 대한 내용인데 자동 형변환과 관련이 있다.

LIKE 조건을 옵션 조건 처리 목적으로 사용하는 경우가 종종 있다. 예를 들어 거래 데이터 조회시 계좌번호는 선택 조건인데 이를 처리하려면 다음과 같이 두 개의 SQL이 필요하다.

```sql

-- SQL1 : 사용자가 계좌번호를 입력할 경우

SELECT * FROM 거래
WHERE 계좌번호 = :acnt_no
AND 거래일자 between :trd_dt1 and :trd_dt2

-- SQL2 : 사용자가 계좌번호를 입력하지 않을 경우

SELECT * FROM 거래
AND 거래일자 between :trd_dt1 and :trd_dt2
```

이를 하나의 SQL로 처리하기 위해 다양한 방식을 사용하는데, 아래와 같이 LIKE 조건을 사용하는 방식이 그 중 하나다.
조회 할 때 사용자가 계좌번호를 입력하지 않으면 ':acnt_no' 변수에 NULL 값을 입력함으로써 모든 계좌변호가 조회되도록 하는 것이다.

```sql
SELECT * FROM 거래
WHERE 계좌번호 LIKE :acnt_no || '%'
AND 거래일자 between :trd_dt1 and :trd_dt2
```

이 방식을 사용하면 LIKE, BETWEEN 조건을 같이 사용했으므로 인덱스 스캔 효율이 안좋다. 계좌번호 컬럼이 숫자형일 때 특히 주의가 필요하다.
숫자형 컬럼을 LIKE 조건으로 검색하면 자동 형변환이 발생해 계좌번호가 아예 인덱스 엑세스 조건으로 사용되지 못하기 때문이다.

계좌번호가 형변환 되면 [계좌번호 + 거래일자] 순으로 구성된 인덱스를 RANGE SCAN 할 수 없다.

[거래일자 + 계좌번호] 순으로 구성된 인덱스는 RANGE SCAN 할 수 있지만, 인덱스 스캔 효율은 매우 안좋아진다. 거래일자 조회 범위에 속한 거래 데이터를 모두 읽으면서 계좌 번호를 필터링하기 때문이다.

## 자동 형변환 주의

자동 형변환은 편하지만 성능과 품질에 문제를 일으킨다.

예를 들어 아래와 같이 숫자형 컬럼과 문자형 컬럼(v_col)을 비교하면 문자형 컬림이 숫자형으로 변환되는데 만약 문자형 컬럼에 숫자로 변환할 수 없는 문자열이 입력되면 쿼리 수행 도중 에러가 발생한다.

실행 에러가 아니라 결과 오류가 생기는 사례도 있다.

```SQL
SELECT ROUND(AVG(SAL)) AVG_SAL
, MIN(SAL) MIN_SAL
, MAX(SAL) MAX_SAL
, MAX(DECODE(JOB, 'PRESIDENT', NULL, SAL)) MAX_SAL2
FROM EMP;
```

가장 적게 받는 직원 급여가 800이고 ,갖아 많이 받는 직원 급여는 5000 이다. 가장 많이 받는 직원은 당연히 PRESIDENT일 것으로 예상되어 이를 제외하고 가장 많이 받는 직원의 급여(max_sal) 도 함께 조회했다.
그런데 값이 평균에도 못미치는 950으로 출력된다.

실제 레코드 단위로 확인해보니 두 번째로 많이 받는 급여는 3000 이다.

결과 오류가 발생한 이유는 무엇일까? 오라클이 decode 함수를 처리할 때 내부에서 사용하는 자동 형변환 규칙 때문이다.

DECODE(A,B,C,D) 를 처리할 때 'a=b' 이면 C를 반환하고, 아니면 D를 반환한다. 이때 반환값의 데이터 타입은 세 번째 인자 C에 의해 결정된다.

따라서 c가 문자형이고 d가 숫자형이면 D는 문자형이 된다.

decode 함수가 가진 또 하나의 내부 규측은 세 번째 인자가 Null 이면 varchar2로 취급한다는 사실이다.

쿼리에서 세 번째 인자가 null 이므로 네 번째 인자 sal을 문자열로 변환하고 문자열 기준으로 가장 큰 950을 출력한 것이다.

아래와 같이 데이터 타입을 명시적으로 일치시켜주면 위와 같은 오류를 피할 수 있다. to_number(null) 대신 0을 써도 된다.

자동 형변환에 대한 결론은 명확하다. 이 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대 편 컬럼또는 값을 정확히 형변환해주어야한다.

SQL 성능 원리를 잘 모르는 개발자는 TO_CHAR, TO_DATE, TO_NUMBER 같은 형변환 함수를 의도적으로 생략한다. 연산횟수가 줄어 성능이 개선될거라는 기대 때문이다.

하지만 SQL 성능은 그런 데서 결정되는게 아니라 블록 I/O를 줄일수 있느냐 없느냐에서 결정된다.
