조인 컬럼에 인덱스가 없을 때 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트머지 조인이나 다음 절에서 설명할 해시 조인을 선택한다.
해시 조인의 등장으로 소트 머지 조인의 쓰임새가 예전만 못하지만 해시 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할 때 여전히 유용하다.

# 1. SGA VS. PGA

공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다. 여러 프로세스가 공유할 수 있지만, 동시에 액세스할 수는 없다.
동시에 액세스하려는 프로세스 간 액세스를 직렬화 하기위한 LOCK 메커니즘으로 LATCH 가 존재한다. 데이터 블록과 인덱스 블록을 캐싱하는 DB 버퍼캐시는 SGA의 가장 핵심적인 구성요소이며, 여기서 블록을 읽으려면 버퍼 lock 도 얻어야 한다.

오라클 서버 프로세스는 SGA 에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유한 메모리 영역을 갖는다. 각 서버 프로세스에 할당된 메모리 영역을 PGA(PRIVATE GLOBAL AREA) 라고 부르며, 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다.

할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 TEMP 테이블스페이스를 이용한다.

PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 레치 메커니즘이 불필요하다. 따라서 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때 보다 훨씬 빠르다.

---

# 2. 기본 메커니즘

소트머지조인은 이름이 의미하는 것처럼 아래 두 단계로 진행한다.

1. 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.

2. 머지 단계: 정렬한 양쪽 집합을 서로 머지 한다.

NL 조인에서 사용했던 아래 SQL로 소트 머지 조인 과정을 설명해 보자. 소트 머지 조인은 use_merge 힌트로 유도한다.

아래 SQL에 사용한 힌트는 사원 테이블 기준으로 고객 테이블과 조인할 때 소트머지조인방식을 사용하라고 지시하고 있다.

```sql
select /*+ordered use_merge(c)*/
e.사원번호, e.사원명, e.입사일자,
c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 --- 1
and  e.입사번호 >= '19960101' --- 2
and e.부서코드 = 'Z123' --- 3
and c.최종주문금액 >= 20000 --- 4
```

위 SQL의 수행 과정을 풀어서 설명하면 아래와 같다.

1. 아래 조건에 해당하는 사원 데이터를 읽어 조인컬럼인 사원번호 순으로 정렬한다. 정렬한 결과집합은 PGA 영역에 할당된 SORT AREA에 저장한다.
   정렬한 결과집합이 PGA에 담을 수 없을 정도로 크면, TEMP 테이블스페이스에 저장한다.

```sql
select 사원번호, 사원명, 입사일자
from 사원
where 입사일자 >= '19960101'
and 부서코드 = 'Z123'
order by 사원번호
```

2. 아래 조건에 해당하는 고객 데이터를 읽어 조인컬럼인 관리사원버노 순으로 정렬한다. 정렬한 결과집합은 PGA 영역에 할당된 SORT AREA에 저장한다. 정렬한 결과집합이 PGA에 담을 수 없을 정도로 크면, TEMP 테이블스페이스에 저장한다.

```sql
select
고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
from 고객 c
where  최종주문금액 >= 20000
order by 관리사원번호
```

3. PGA 또는 TEMP 테이블스페이스에 저장한 사원 데이터를 스캔하면서 PGA 또는 TEMP 테이블스페이스에 저장한 고객 데이터와 조인한다. 조인하는 과정을 PL/SQL 코드로 표현하면 아래와 같다.

```
begin
  for outer in (select * from PGA_SORTED_사원)
  loop -- outer 루프
    for inner in (
      select * from PGA_SORTED_고객
      where 관리사원번호 = outer.사원번호
    )
    loop -- inner 루프
      dbms_output.put_line(...);
    end loop;
  end loop;
end
```

1번과 2번이 소트 단계, 3번이 머지 단계다. 실제 조인 오퍼레이션을 수행하는 3번 머지단계는 NL 조인과 다르지 않음을 확인할 수 있다.

주목할 점은 사원 데이터를 기준으로 고객 데이터를 매번 FULL SCAN 하지 않는다는 사실이다.

고객 데이터가 정렬돼 있으므로 조인 대상 레코드가 시작되는 지점을 쉽게 찾을 수 있고, 조인에 실패하는 레코드를 만나는 순간 바로 멈출 수 있다.

SORT AREA 에 저장한 데이터 자체가 인덱스 역할을 하므로 소트 머지 조인은 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식이다.

조인 컬럼에 인덱스가 있어도 nL 조인은 대량 데이터 조인할 때 불리하므로 소트머지 조인을 사용할 수 있다.

---

# 3. 소트머지 조인이 빠른 이유

NL조인은 모두 DBMS 가 공통적으로 제공하는 가장 전통적인 조인 방식이다. 그런 NL 조인의 치명적인 단점은 대량 데이터를 조인할 때 성능이 매우 느리다는데 있다. 소트 머지 조인과 해시 조인이 개발된 이유다.

소트 머지 조인은 SORT AREA에 미리 정렬해 둔 자료구조를 이용한다는 점만 다를 뿐 조인 프로세싱 자체는 nl 조인과 같다. 그렇다면 성능 차이는 어디에서 나타날까?

즉, 대량 데이터 조인할 때 소트 머지 조인이 빠른 이유가 무엇일까?

NL 조인은 단적으로 말해 인덱스를 이용한 조인 방식이다. 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 건건이 DB 버퍼캐시를 경유해서 읽는다.
즉, 인덱스는 테이블이든, 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거친다.

버퍼캐시에서 찾지 못한 블록은 건건이 디스크에서 읽어 들인다. 인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러낸다.

반면, 소트머지조인은 양쪽 테이블로부터 조인 대상집합(조인조건 이외 필터를 만족하는 집합)을 일괄적으로 읽어 PGA에 저장한 후 조인한다. PGA는 플세스만을 위한 독립적 메모리 획득 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다. 소트 머지 조인이 대량 데이터 조인에 유리한 이유다.

조인 전에 양쪽 집합에 대한 소트 연산을 추가로 수행하므로 NL조인보다 더 느리지 않을까 싶지만, 이것이 오히려 소트 머지 조인을 대량 데이터 조인에 유리하게 만든 핵심 요인인 셈이다.

소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경우한다.

이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색비용과 랜덤 액세스 부하는 소트 머지 조인도 피할 수 없다.

---

# 4. 소트머지조인의 주 용도

렌덤 액세스 위주의 NL 조인이 대량 데이터 처리에 한계를 보일 때 소트 머지 조인이 해결사로서 인기를 누리던 시절이 있었다. 하지만 해시 조인의 등장으로 이제 소트 머지 조인의 쓰임새는 예전만 못하다. 대부분 해시조인이 더 빠르기 때문이다.

하지만 해시 조인은 조인 조건식이 등치(=) 조건이 아닐 때 사용할 수 없다는 단점이 있다. 그래서 소트 머지 조인은 아래와 같은 상황에 주로 사용된다.

\- 조인 조건식이 등치 조건이 아닌 대량 데이터

\- 조인 조건식이 아예 없는 조인(CROSS JOIN, 카테시안 곱)

--

# 5. 소트 머지 조인 제어하기

아래는 소트머지조인 실행 계획이다. '양쪽 테이블을 각각 소트후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지 조인한다'고 해석하면 된다.
(소트할 대상을 찾기 위해 각 테이블을 액세스할 때 인덱스를 이용한다는 사실도 확인할 수 있다. 물론 인덱스를 이용하지 않고 TABLE FULL SCAN으로 처리할 수도 있다.)

```sql
-- EXECUTION PLAN

SELECT STATEMENT
  MERGE JON
    SORT(JOIN)
      TABLE ACCESS BY INDEX ROWID OF '사원'
        INDEX RANGE SCAN OF '사원_X1'
    SORT(JOIN)
      TABLE ACCESS BY INDEX ROWID OF '고객'
        INDEX RANGE SCAN OF '고객_X1'
```

소트 머지 조인 실행계획을 제어할 때 아래와 같이 use_merge 힌트를 사용한다.

```sql
select /*+ordered use_merge(c)*/
e.사원번호, e.사원명, e.입사일자,
c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and  e.입사번호 >= '19960101'
and e.부서코드 = 'Z123'
and c.최종주문금액 >= 20000
```

ordered는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에게 지시하는 힌트다. ordered 대신 leading(e) 힌트를 사용해도 된다.
use_merge 는 소트머지 방식으로 조인하라고 지시하는 힌트다. 위에서는 둘을 같이 사용했으므로 양쪽 테이블을 조인 컬럼 순으로 정렬한후 '정렬된 사원' 을 기준으로 정렬된 고객과 조인하라는 뜻이다.

---

# 6. 소트 머지 조인 특징

소트 머지 조인은 조인 위해 실시간으로 인덱스를 생성하는 것이나 다름없다. 양쪽 집합을 정렬한 다음 NL 조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다.
따라서 소트 부하만 감수한다면, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.

NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다. 양쪽 집합을 개별적으로 읽고 나서 조인을 시작한다는 특징도 있다.
따라서 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을 때 아주 유리하다.

스캔 위주의 액세스 방식을 사용한다는 점도 중요한 특징이다. 하지만 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수 있고 그때는 랜덤 엑세스가 일어난다. 이는 해시 조인도 마찬가지다.
