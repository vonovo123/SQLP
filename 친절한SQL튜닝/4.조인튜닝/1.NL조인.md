조인의 기본은 NL 조인이다. 지금까지 설명한 인덱스 원리를 어느 정도 이해했다면 NL조인은 절대 어렵지 않다. NL조인은 인덱스를 이용한 조인이기 때문이다. 튜닝 원리도 그대로 적용할 수 있다.
또한, NL조인을 정확히 이해하고 나면 다른 조인 방식도 쉽게 이용할 수 있다. 소트 머지 조인, 해시 조인도 프로세싱 과정은 NL조인과 다르지 않기 때문이다. 조인할 때 어떤 자료구조를 이용하느냐의 차이일 뿐이다.

# 1. 메커니즘

1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램을 작성해 보자.

아래 SQL문을 사용하면 원하는 결과집합을 쉽게 추출할 수 있지만, SQL이 탄생하기 전에는 두 테이블을 조인하는 프로그램을 직접 작성해야 했다.

```sql
select e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사번호 >= '19960101'
and c.관리사원번호 = e.사원번호
```

가장 쉽게 생각할 수 있는 방식은, 사원 테이블로부터 1996년 1월 1일 이후 입사한 사원을 찾아 '건건이' 고객 테이블에서 사원번호가 일치하는 레코드를 찾는 것이다. 이것이 NESTED LOOP 조인이 사용하는 알고리즘이다.
중첩 루프문(NESTED LOOP)의 수행 구조로 이루어진다.

```java
for(int j = 0; j < 100; j ++){ // outer loop
  for(int i = 0; i < 100; i ++){ // inner loop
    // do anything
  }
}
```

```sql
for outer in 1..100 loop
  for inner in 1..100 loop
    dmbs_output.put_line(outer || ':' || inner);
  end loop;
end loop;
```

NL 조인은 위 중첩 루프문과 같은 수행 구조를 사용한다. 중첩 루프문을 사용하는 아래 PL/SQL 코드는 NL 조인이 어떤 순서로 데이터를 액세스하는지 잘 설명해 준다.

```sql
begin
  for outer  in ( select 사원번호, 사원명 from 사원 where 입사일자 >= '19960101')
  loop -- outer loop
    for inner in (select 고객명, 전화번호 from 고객 where 관리사원번호 = outer.사원번호)
    loop -- inner loop
      dmbs_output.put_line(outer.사원명 || ':' || inner.고객명 || ':' || inner.전화번호);
    end loop;
  end loop;
end
```

일반적으로 NL 조인은 outer 와 inner 양쪽 테이블 모두 인덱스를 이용한다. OUTER 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다. TABLE FULL SCAN 하더라도 그것은 한 번에 그치기 때문이다.
반면 INNER 쪽 테이블은 인덱스를 사용해야 한다.

위의 예로 INNER 루프에서 관리사원번호로 고객 데이터를 검색할 때 인덱스를 이용하지 않으면 OUTER 루프에서 읽은 건수 만큼 TABLE FULL SCAN을 반복하기 때문이다.

결국 NL 조인은 '인덱스를 이용한 조인 방식' 이라고 할 수 있다.

1. 사원\_x1 인덱스에서 입사일자 >= '19960101' 인 첫 번째 레코드를 찾는다.
2. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾는다.
3. 사원 테이블에서 읽은 사원번호 '0006' 으로 고객\_x1 인덱스를 검색한다.
4. 고객\_x1 인덱스에서 읽은 ROWID 로 고객 테이블 레코드를 찾아간다.
5. 고객\_x1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0006' 임을 확인한다.
6. 고객\_x1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.
   (고객\_x1 인덱스에서 한 건 더 스캔하고 관리사원번호가 0006보다 크므로 거기서 인덱스 스캔을 멈춘다.)
7. 사원\_X1 인덱스에서 한 건 더 스캔해서 입사일자가 '19960712' 인 레코드를 읽는다.
8. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾는다.
9. 사원 테이블에서 읽은 사원번호 '0003' 으로 고객\_x1 인덱스를 검색한다.
10. 고객\_x1 인덱스에서 읽은 ROWID 로 고객 테이블 레코드를 찾아간다.
11. 고객\_x1 인덱스에서 한 건 더 스캔하고 관리사원번호가 '0003' 임을 확인한다.
12. 고객\_x1 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾아간다.
    (고객\_x1 인덱스에서 한 건 더 스캔하고 관리사원번호가 0003보다 크므로 거기서 인덱스 스캔을 멈춘다.)

사원\_x1 인덱스에서 입사일자 >= '19960101'인 모든 레코드에 대해 같은 과정을 반복한다.
사실 뒤에서 설명하는 소트 머지 조인과 해시 조인도 각각 SORT AREA 와 HASH AREA에 가공해 둔 데이터를 이용한다는 점만 다를 뿐, 기본적인 조인 프로세싱은 다르지 않다.

---

# 2. NL 조인 실행계획 제어

위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 NL 조인한다'고 해석하면 된다.

각 테이블을 액세스할 때 인덱스를 이용한다는 사실도 실행계획에서 확인할 수 있다.

```SQL
-- EXCUTION PLAN
-------------------
0     SELECT STATEMENT
1 0     NESTED LOOPS
2 1       TABLE ACESS (BY INDEX ROWID) OF '사원'(테이블)
3 2         INDEX (RANGE SCAN) OF '사원_x1' (index)
4 1       TABLE ACESS (BY INDEX ROWID) OF '고객'(테이블)
5 4         INDEX (RANGE SCAN) OF '고객_x1' (index)
```

NL 조인을 제어할 때는 아래와 같이 use_nl 힌트를 사용한다.

```sql
select /*+ordered use_nl(c)*/
e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사번호 >= '19960101'
and c.관리사원번호 = e.사원번호
```

'ordered' hint 는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. use_nl 힌트는 nl 방식으로 조인하라고 지시할 때 사용한다.

위에서는 ordered 와 use_nl 힌트를 같이 사용했으므로 사원테이블(DRIVING OR OUTER TABLE) 기준으로 고객 테이블(INNER TABLE)과 NL 방식으로 조인하라는 뜻이다.

세 개 이상 테이블을 조인할 때는 힌트를 아래처럼 사용한다.

```sql
select /*+ordered use_nl(B), use_nl(C) use_hash(B)*/
*
from A, B, C, D
where ....
```

해석해 보면, A-B-C-D 순으로 조인하되, B와 조인할 때 그리고 이어서 C와 조인할 때는 NL 방식으로 조인하고, D와 조인할 때는 해시 방식으로 조인하라는 뜻이다.

ORDERED 대신 아래와 같이 leading 힌트를 사용할 수도 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고 마음껏 숫자를 제어할 수 있어 편리하다.

```sql
select /*+ leading(C, A, D, B), use_nl(A), use_nl(D) use_hash(B)*/
*
from A, B, C, D
where ....
```

아래는 ordered나 leading 힌트를 기술하지 않았다. 네 개 테이블을 조인하되 순서는 옵티마이저가 스스로 정하도록 한다.

```sql
select /*+ use_nl(A, B, C, D)*/
*
from A, B, C, D
where ....
```

---

# 3.NL 조인 수행과정 분석

간단한 조인문을 통해 NL 조인의 기본 알고리즘과 이를 제어하는 힌트 사용법을 알아봤다. 좀 더 자세한 nl 조인 수행 과정을 분석하기 위해 아래와 같이 조건절을 추가해 보자.
조건절에 지시한 대로 수행할 때, 조건절 비교순서는 어떻게 될까? 조건절 우측에 표시한 번호로 순서를 나열해 보자.

```sql
-- 2 3 1 4
select /*+ordered use_nl(c) index(e) index(c)*/
e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 --- 1
and  e.입사번호 >= '19960101' --- 2
and e.부서코드 = 'Z123' --- 3
and c.최종주문금액 >= 20000 --- 4

-- 인덱스 구성은 다음과 같다.
-- 사원_Pk : 사원번호
-- 사원_X1 : 입사일자
-- 고객_Pk : 고객번호
-- 고객_X1 : 관리사원번호
-- 고객_X2 : 최종주문금액
```

두 테이블에 index 힌트를 명시했으므로 둘 다 인덱스를 이용해서 액새스한다. 인덱스 명은 명시하지 않았으므로 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.

힌트에 지시한 대로 SQL 문을 수행했을 때 실행계획은 아래와 같다. 사용되는 인덱스는 사원\_X1과 고객\_X1인 것을 알 수 있다.

```SQL
-- OPERATION
SELECT STATEMENT
  NESTED LOOPS
    TABLE ACCESS BY INDEX ROWID (사원)
      INDEX RANGE SCAN          (사원_X1)
    TABLE ACCESS BY INDEX ROWID (고객)
      INDEX RANGE SCAN          (고객_X1)
```

SQL 조건절 우측에 표시한 번호로 조건절 비교 순서를 나열하면 2 - 3 - 1- 4 순이다.

1. 조건절 비교(2) : 입사일자 >= '19960101' 조건을 만족하는 레코드를 찾으려 사원\_X1 인덱스를 RANGE 스캔한다.
2. 조건절 비교(3) : 사원\_X1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 'Z123' 필터 조건을 만족하는지 확인한다.
3. 조건절 비교(1) : 사원 테이블에서 읽은 사원번호 값으로 조인 조건을 만족하는 고객 쪽 레코드를 찾으려고 고객\_X1 인덱스를 RANGE 스캔한다.
4. 조건절 비교(4) : 고객 X1_INDEX에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다.

여기서 기억할 것은, 각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행한다는 사실이다.

---

# 4. NL 조인 튜닝 포인트

```sql
-- 2 3 1 4
select /*+ordered use_nl(c) index(e) index(c)*/
e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 --- 1
and  e.입사번호 >= '19960101' --- 2
and e.부서코드 = 'Z123' --- 3
and c.최종주문금액 >= 20000 --- 4
```

위 SQL의 첫 번째 튜닝 포인트는 사원\_X1 인덱스를 읽고 나서 사원 테이블을 액세스 하는 부분이다.

여기서는 단일 컬럼 인덱스를 '>=' 조건으로 스캔했으므로 비효율 없이 6건을 읽었고, 그만큼만 테이블 랜덤 액세스가 발생했다.

만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고, 테이블에서 부서코드 = 'Z123' 조건에 의해 필터링되는 비율이 높다면 어떻게 해야 할까?

사원\_X1 인덱스에 부서코드 컬럼을 추가하는 방안을 고려해야 한다.

두 번째 튜닝 포인트는 고객\_X1 인덱스를 탐색하는 부분이다. 고객\_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다.

조인 액세스 횟수는 OUTER 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다.

SQL에서는 부서코드 = 'Z123' 조건을 만족하는 3건에 대한 조인시도가 있었다.
만약 부서코드 조건을 만족하는 레코드가 10만 건이고 고객\_X1 인덱스의 DEPTH 가 3이라면, 인덱스 수직적 탐색 과정에서만 30만개의 블록을 읽어야 하고, 리프 블록을 수평적 스캔하는 과정에서 추가적인 블록 I/O가 더해진다.

세 번째 튜닝 포인트는 고객\_X1 인덱스를 읽고 나서 고객 테이블을 액세스 하는 부분이다.
여기서도 최종주문금액 >= 20000 조건에 의해 필터링되는 비율이 높다면 고객\_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.

마지막으로, 맨 처음 액세스하는 사원\_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다는 사실을 기억해야 한다.

사원\_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스하는 횟수, 고객\_X1 인덱스를 탐색하는 횟수, 고객 테이블로 랜덤 액세스하는 횟수가 전반적으로 많아진다.

## 올바른 조인 메소드 선택

온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 때는 일차적으로 nl 조인부터 고려하는 것이 올바른 순서다.

성능이 느리다면, 방금 설명한 NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악해야한다.

조인 순서를 변경해서 랜덤 액세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.

여러 방안을 검토한 결과 NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단될 때, 소트 머지 조인이나 해시 조인을 검토한다.

---

# 5.NL 조인 특징 요약

NL 조인의 첫 번째 특징은 랜덤 액세스 위주의 조인 방식이라는 점이다. 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다.

인덱스 구성이 아무리 완벽해도 대량 데이터를 조인할 때 NL 조인이 불리한 이유다.

두 번째 특징은 조인을 한 레코드씩 순차적으로 진행한다는 점이다. 첫 번째 특징 때문에 대량 데이터 처리시 매우 치명적인 한계를 드러내지만, 반대로 이 두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 빠른 응답 속도를 낼 수 있다. 부분범위 처리가 가능한 상황에서 그렇다.

```SQL
SELECT /*+ORDERD USE_NL(B) INDEX_DESC(A (게시판구분, 등록일시))*/
A.게시글ID, A.제목, B.작성자명, A.등록일시
FROM 게시판 A, 사용자 B
WHERE A.게시판구분 = 'NEWS' -- 게시판IDX : 게시판구분 + 등록일시
AND B.사용자ID = A.작성자ID -- 사용자 IDX : 사용자ID
ORDER BY A. 등록일시 DESC
```

순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 나타난다.

마지막으로, 다른 조인 방식과 비교할 때 인덱스 구성 전략이 특히 중요하다는 것도 NL 조인의 중요한 특징이다. 조인 컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성됐느냐에 따라 조인 효율이 크게 달라진다.

이런 여러 가지 특징을 종합할 때, NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 온라인 트랜잭션 처리(OLTP) 시스템에 적합한 조인 방식이라고 할 수 있다.

---

# 6.NL 조인 튜닝 실습

```sql
select /*+ordered use_nl(c) index(e) index(c)*/
e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 --- 3
and  e.입사일자 >= '19960101' --- 1
and e.부서코드 = 'Z123' --- 2
and c.최종주문금액 >= 20000 --- 4


--            query
--  parse       0
--  execute     0
--  fetch       9

-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원
--  5         INDEX RANGE SCAN OF 사원_X1
--  5       TABLE ACCESS BY INDEX ORWID OF 고객
--  8         INDEX RANGE SCAN OF 고객_X1
```

블록 I/O가 아홉 개밖에 안 되므로 튜닝할 필요가 없어 보인다.
만약 트레이스 결과 다음과 같으면 어디에 문제가 있을까?

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원
--  2780      INDEX RANGE SCAN OF 사원_X1
--  5       TABLE ACCESS BY INDEX ORWID OF 고객
--  8         INDEX RANGE SCAN OF 고객_X1
```

사원\_X1 인덱스를 스캔하고서 사원 테이블을 액세스한 횟수가 2780 건인데, 테이블에서 부서코드 = 'Z123' 조건을 필터링한 결과는 세 건에 그친다.

불필요한 테이블 액세스를 많이 한 셈이고, 이처럼 테이블 액세스한 후에 필터링되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려할 필요가 있다.

사원\_X1 인덱스에 부서코드 컬럼을 추가하고서 트레이스를 다시 확인해 보니 아래와 같이 불필요한 테이블 인덱스가 사라졌다.

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원
--  3      INDEX RANGE SCAN OF 사원_X1
--  5       TABLE ACCESS BY INDEX ORWID OF 고객
--  8         INDEX RANGE SCAN OF 고객_X1
```

비효율적인 테이블 액세스는 이제 거의 사라졌지만, 테이블을 액세스하기 전 인덱스 스캔 단계에서의 일량은 확인하지 않았으므로 튜닝이 끝났다고 볼 수 없다.

앞서 부서코드 컬럼을 추가했으므로 사원\_X1 인덱스는 현재 [입사일자 + 부서코드] 순이고, 조건절을 보면 입사일자가 부등호 조건이다.

입사일자 >= '19960101' 조건에 해당하는 레코드가 아주 많다면, 그만큼 인덱스 블록을 스캔하면서 부서코드 'Z123' 조건을 필터링했을 것이다.

```sql
-- cr : 논리적인 블록 요청 횟수
-- pr : 디스크에서 읽은 블록 수
-- pw : 디스크에 쓴 블록 수

-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원 (cr=105 pr=32 pw=0)
--  3         INDEX RANGE SCAN OF 사원_X1 (cr=102 pr=31 pw=0)
--  5       TABLE ACCESS BY INDEX ORWID OF 고객 (cr=7 pr=2 pw=0)
--  8         INDEX RANGE SCAN OF 고객_X1 (cr=5 pr=1 pw=0)
```

사원\_X1 인덱스로부터 읽은 블록이 102개 이다. 한 블록에 평균 500개 레코드가 저장돼 있다고 가정하면, 인덱스에서 세 건을 얻기 위해 50,000 여 개 레코드를 읽은 셈이다.

튜닝 방법은 사원\_X1 인덱스 컬럼의 순서를 조정해 [부서코드 + 입사일자] 순으로 구성해 주면 된다.

이번에는 트레이스 결과가 아래와 같았다고 하자. 부하지점이 어디인가?

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  2780     TABLE ACCESS BY INDEX ROWID OF 사원  (cr=166 pr=2 pw=0)
--  2780      INDEX RANGE SCAN OF 사원_X1         (cr=4 pr=0 pw=0)
--  5       TABLE ACCESS BY INDEX ORWID OF 고객   (cr=2566 pr=384 pw=0)
--  8         INDEX RANGE SCAN OF 고객_X1         (cr=2558 pr=383 pw=0)
```

사원 테이블을 읽는 부분에서는 비효율이 없다. 인덱스에서 스캔한 블록이 네 개 뿐이고 테이블을 액세스하고서 필터링되는 레코드도 전혀 없다. 일량은 많지만, 비효율은 없다.

문제는 원 테이블을 읽고 나서 고객 테이블과 조인하는 횟수다. 2780번 조인 시도를 했지만 조인에 성공하고 필터링 까지 마친 최종 결과집합은 다섯 건 뿐이다.

이럴 때는 조인 순서 변경을 고려해 볼 수 있다. 만약 최종주문금액 조건절에 부합하는 레코드가 별로 없다면 튜닝에 성공할 가능성이 있다.

하지만, 그 반대의 결과가 나타날 수도 있다. 위에서 고객과 조인 후에 다섯 건으로 줄어든 이유는 사원으로 넘겨받은 사원번호와 최종주문금액 조건절을 조합했기 때문이다.

만약 조인 순서를 바꿔 최종주문금액 단독으로 조회하면, 데이터량이 훨씬 많을 수도 있다.

조인 순서를 바꿔도 별 소득이 없다면, 소트 머지 조인과 해시 조인을 검토해볼 수 있다.

---

# 7.NL 조인 확장 메커니즘

오라클 버전이 올라가면서 NL 조인 성능을 높이기 위해 테이블 PREFETCH, 배치 I/O 기능이 도입됐다.

테이블 PREFETCH는 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능이다.

배치I/O는 디스크 I/O CALL을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.

두 기능 모두, 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안되었다.

내부 원리까지 자세히 알 필요는 없지만, 튜닝하는 과정에서 이들 기능에 표현한 실행계획을 자주 보게 되므로 표현 방식은 익혀둘 필요가 있다.

1. 전통적인 실행계획

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원
--  3         INDEX RANGE SCAN OF 사원_X1
--  5       TABLE ACCESS BY INDEX ROWID OF 고객
--  8         INDEX RANGE SCAN OF 고객_X1
```

2. 테이블 PREFETCH 실행계획

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     TABLE ACCESS BY INDEX ROWID OF 고객
--  12     NESTED LOOPS
--  3       TABLE ACCESS BY INDEX ROWID OF 사원
--  3         INDEX RANGE SCAN OF 사원_X1
--  8       INDEX RANGE SCAN OF 고객_X1
```

이는 inner(여기서는 고객) 쪽 테이블에 대한 디스크 I/O 과정에 테이블 PREFETCH 기능이 작동할 수 있음을 표시하기 위함이다.

NLJ_PREFETCH, NO_NLJ_PREFETCH 힌트를 이용해 이 실행계획이 나오게 할 수도 , 나오지 않게 할 수도 있다.

3. 배치 I/O 실행계획

오라클 11g 부터 아래와 같은 표현방식도 같이 나타나기 시작했다.

```sql
-- ROWS   ROW SOURCE OPERATION
--  5     NESTED LOOPS
--  8       NESTED LOOPS
--  3         TABLE ACCESS BY INDEX ROWID OF 사원
--  3           INDEX RANGE SCAN OF 사원_X1
--  8         INDEX RANGE SCAN OF 고객_X1
--  5       TABLE ACCESS BY INDEX ROWID OF 고객
```

이는 INNER 쪽 테이블에 대한 디스크 I/O 과정에 배치 I/O 기능이 작동할 수 있음을 표시하기 위함이다.

nlj_batching, no_nlj_batching 힌트를 이용해 이 실행 계획이 나오게 할 수도 있고 안 나오게 할 수도 있다.

오라클 11g에서는 위 세 가지 실행계획이 모두 나타나는데, INNER 쪽 테이블 블록을 모두 버퍼캐시에서 읽는다면 어떤 방식으로 수행되든 성능에 차이가 없다.

데이터 출력 순서도 100% 같다.

다만, 일부를 디스크에서 읽게 되면 성능에 차이가 나타날 수 있고, 배치 I/O 실행계획이 나타날 때는 결과 집합의 정렬 순서도 다를 수 있어 주의가 필요하다.

예를 들어, 아래 쿼리는 안쪽 인라인뷰에서 이미 등록일시 역순으로 정렬했고, 회원 테이블과는 한 건씩 순차적으로 진행하는 NL 방식으로 조인하도록 힌트를 명시했으므로 데이터 정렬 순서를 그대로 유지한다.

따라서 배치 I/O가 작동하지 않는 10g 까지는 맨 바깥쪽 ORDER BY 절이 없어도 상관 업었다.

( 물론, 혹시라도 조인 메소드가 바뀌면 정렬 순서도 흩어지므로 ORDER BY 를 명시하는 것이 좋은 습관이다.)

```sql
(
  SELECT A.*, ROWNUM NO
  FROM
    (
      SELECT 등록일시, 번호, 제목, 작성자번호, 게시판유형, 질문유형
      FROM  게시판
      WHERE 게시판유형 = :TYPE
      ORDER BY 등록일시 DESC -- 인덱스 구성 : 게시판유형 + 등록일시
    ) A
  WHERE ROWNUM <= (:PAGE * 10)
) A, 회원 B
WHERE A.NO >= (:PAGE-1) * 10 + 1
AND B.회원번호 = A.작성자번호
ORDER BY A.등록일시 DESC --> 11G 부터 여기에 ORDER BY 명시해야 정렬 순서 보장
```

하지만, 11g 부터 NL 조인 결과집합이 항상 일정한 순서로 출력되기를 원한다면, 배치 I/O 기능이 작동하지 못하도록 no_nlj_batching(b) 힌트를 추가하거나 아래와 같이 맨 바깥 쪽 ORDER BY 절에 정렬 기준을 명시해야 한다.

주의할 것은, 11g에서 바깥쪽 메인 쿼리에 ORDER BY 를 추가했더라도 안쪽 ORDER BY 를 함부로 제거해선 안된다. 이는 TOP N 쿼리를 구현하기 위함이다.
