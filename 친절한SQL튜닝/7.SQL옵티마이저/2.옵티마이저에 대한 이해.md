# 옵티마이저에 대한 이해

## 옵티마이저의 종류

비용기반 옵티마이저는 사용자 쿼리를 위해 후보군이 될마난 실행계획들을 돛ㄹ하고, 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정하고,
그중 가장 낮은 비용의 실행 계획 하나를 선택하는 옵티마이저다.

비용기반 옵티마이저, 이하 CBO 가 사용하는 통계정보로는 데이터량, 컬럼 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 등이 있다.

과거에는 각 액세스 경로에 대한 우선 순위 규칙에 따라 실행계획을 만드는 옵티마이저를 사용했다. 이를 규칙 기반 옵티마이저 (RBO) 라고 한다.

RBO는 데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 단순한 규칙에만 의존하기 때문에 대량 데이터를 처리하는데 부족하다.

예를들어 고객유형코드에 인덱스가 있으면 RBO는 무조건 인덱스를 사용한다. FULL TABLE SCAN은 INDEX RANGE SCAN보다 순위가 낮기 때문이다.
하지만 특정고객유형코드 조건을 만족하는 고객이 전체에서 90%를 차지한다면 좋은 선택을 했다고 보기는 어렵다.

```sql
SELECT *
FROM 고객
ORDER BY 고객명;
```

RBO는 소팅에 무조건 인덱스를 사용한다. 인덱스 컬럼에 대한 ORDER BY 순위가 FULL TABLE SCAN 순위보다 높기 때문이다.

부분범위 처리가 가능한 상황에서 인덱스를 이용해 소트 연산을 생략한다면 성능을 높이는데 도움이 되지만, 그렇지 못한 상황에서 인덱스로 전체 레코드를 액세스하는 것은 좋은 선택이 아니다.

그래서 CBO는 ALL_ROWS와 FIRST_ROWS 두가지 유형의 옵티아미저 모드를 두고있다.

인덱스 컬럼에 대한 BETWEEN 조건이 부등호 조건보다 우선순위가 높다. 따라서 연령과 연봉 컬럼에 각각 인덱스가 있다면 RBO는 아래 SQL에 대해 무조건 연봉 컬럼 인덱스를 사용한다.

```sql
select *
from 사원
where 연령 >= 60
and 연봉 between 3000 and 6000
```

between은 닫힌 범위 검색 조건이고, 부드오는 열린 범위검색 조건이다. 하지만 데이터의 특성상 연령이 60대 이상인 사라미 연봉이 3000과 6000 사이의 사람보다 적을 수 밖에 없다.
RBO는 이를 고려하지 못한다.

## 옵티마이저 모드

네비게이션에서 목적지를 검색하면, 이동 경로를 보여 주기에 앞서 검색 모드를 선택하게 돼있다.

비용기반 옵티마이저에도 비슷한 기능이 있다. 최적화 목표를설정하는 기능으로 아래 세 가지 옵티마이저 모드 중 하나를 선택하면 된다.

\- ALL_ROWS : 전체 처리속도 최적화
\- FIRST_ROWS : 최초 응답속도 최적화
\- FIRST_ROWS_N : 최초 N건 응답속도 최적화

옵티마이저 모드를 ALL_ROWS로 설정하면 옵티마이저는 쿼리 결과집합 전체를 읽는 것ㅇ르 전제로 시스템 리소스를 가장 적게 사용하는 실행계획을 선택한다.
즉, 전체 처리속도 최적화가 목표다.

FIRST_ROWS로 설정하면 옵티마이저는 전체 결과집합 중 앞쪽 일부만 읽다가 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다.
즉, 최초 응답속도 최적화가 목표다.

ALL_ROWS와 비교하면, TABLE FULL SCAN 보다 인덱스를 더 많이 선택하고, 해시조인, 소트 머지 조인보다 NL 조인을 더 많이 선택하는 경향을 보인다.

예를들어 100만 건의 결과집합 전체를 파일로 저장하려는데, 옵티마이저 모드가 FIRST_ROWS로 설정돼 있으면 인덱스를 이용해 소트 연산을 생략하는 실행계획이 선택된다.

그런데 사용자가 중간에 멈추지 않고 결과집합을 끝까지 읽는다면 fulL SCAN에 비해 오히려 전체 수행 속도가 더 느려진다.

FIRST_ROWS 는 곧 DEPRECATED 될 모드로 FIRST_ROWS_N을 사용해야한다.

FIRST_ROWS_N은 사용자가 앞쪽 N개 로우만 읽고 멈추는 것을 전제로 응답속도가 가장 빠른 실행계획을 선택한다.

alter system or alter session 명령어로 옵티마이저 모드를 설정할 때 N으로 지정할 수 있는 값은 아래와 같이 1, 10, 100, 1000 네 가지다.

```sql
alter session set optimizer_mde = first_row_1;
alter session set optimizer_mde = first_row_10;
alter session set optimizer_mde = first_row_100;
alter session set optimizer_mde = first_row_1000;
```

아래와 같이 FIRST_ROWS 힌트로 설정할 때는 괄호 안에 0 보다 큰 어떤 정수값이라도 입력할 수 있다.

```sql
select /*+first_rows(30)*/ col1, col2, col3 from t where...
```

FIRST_ROWS는 사용자가 데이터를 어느 정도 읽다가 멈출지를 지정하지 않았으므로 정확한 비용을 산정하기 어렵다.
반면 FIRST_ROWS_N은 읽을 데이터 건수를 지정하였으므로 더 정확한 비용 산정이 가능하다. FIRST_ROWS_N이 더 완벽한 CBO 모드로 작동한다.

## 옵티마이저에 영향을 미치는 요소

### SQL 과 연산자 형태

결과가 같더라도 SQL으 어떤 형태로 작성했는지 또는 어떤 연산자를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수도 있고, 궁극적으로 쿼리 성능에 영향을 미친다.

### 인덱, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터

같으 쿼리를 작성해도 인덱스, IOT, 클러스터, 파티션, MV 구성여부, 어떻게 구성했는지에 따라 실행계획과 성능이 크게 달라진다.

### 제약 설정

DBMS에 설정한 PK, FK, CHECK, NOT NULL 같은 제약들은 데이터 무결성을 보장해 줄뿐만 아니라 옵티마이저가 쿼리 성능을 최적화 하는데 매우 중요한 메타 정보로 활용된다

### 통계정보

통계정보는 옵티마이저에 매우 강력한 영향을 미친다. SQL 옵티마이저가 사용하는 통계정보에 문제가 생기면 애플리케이션 성능이 갑자기 느려지고 장애 상황으로 이어지기도 한다.

\- 특정 테이블 통계정보를 갑자기 삭제한다.
\- 대량 데이터를 지웠다가 다시 입력하기 직전, 데이터가 없ㄴㄴ 상황에서 자동ㅇ로 통계정보가 수집된다.
\- 오랫동안 갱신하지 않던 특정 테이블 통계정보를 어느날 갑자기 재수집한다.
\- 통계정보 없이 관리하던 테이블에 인덱스를 재생성한다.
\- 테이블이나 인덱스를 재생성하면서 파티션 단위로만 통계정보를 수집한다.

### 옵티마이저 힌트

옵티마이저에게 가장 절대적인 영향을 미치는 요소는 힌트다. 옵티마이저는 힌트를 명령어로 인식하고 그대로 따른다. 만약 힌트가 잘 작동하지 않는다면, 이유는 다음과 속할 가능성이 높다.

\- 문법적으로 맞지 않게 힌트를 기술
\- 잘못된 참조 사용
\- 의미적으로 맞지 않게 힌트를 기술
\- 논리적으로 불가능한 액세스 경로
\- ㅂ그

### 옵티마이저 관련 파라미터

SQ, 데이터, 통계정보, 하드웨어 등 모든 환경이 같은데도 오라클 버전을 업그레이드하면 옵티마이저가 다르게 작동하는 경험ㅇ르 한다.
옵티마이저의 ㄱ런 행동은 대개 파라미터 추가 또는 기본값 변경에 기인한다.

이미 살펴본 옵티마이저 모드 외에 옵티마이저 행동에 영향을 미치는 파라미터 목록은 아래 쿼리를 통해 얻을 수 있다.

```sql
select name, value, isdefault, default_value
from v$sys_optimizer_env
```

# 옵티마이저의 한계

DBA가 통계정보를 아무리 잘 수집하고, SQL을 아무리 잘 작성해도 실수가 있기 마련이다.

옵티마이저 행동에 가장 큰영향을 미치는 통계정보를 필요한 만큼 충분히 확보하는 것부터가 불가능한 일이다. 정보가 많으면 많을수록 좋지만, 수집과 관리에 큰 비용이 든다.
통계정보를 아무리 완벽하게 수집해도 바인드 변수를 사용한 sql에 컬럼 히스토그램을 활용할 수 없다는 치명적인 단점도 있다.
기본적으로 비용기반으로 작동하지만, 내부적으로 여러 가정과 정해진 규칙을 이용해 기계적인 선택을 한다는 사실도 옵티마이저의 한계중 하나이다.

# 개발자의 역할

기본적으로 옵티마이저에게 많은 일을 맡기는 RDBMS 환경에서 SQL 성능을 높이기 위해 개발자가 할 일은 다음과 같다.

\- 필요한 최소 블록만 읽도록 쿼리 작성
\- 최적의 옵티마이징 팩터 제공
\- 옵티마이징 힌트를사용해 최적의 액세스 경로 유도

## 필요한 최소 블록만 읽도록 쿼리 작성

SQL 작성자 스스로 결과집합을 논리적으로 잘 정의하고, 그 결과집합을 만들기 위해 DB 프로세스가 최소한의 일만 하도록 쿼리를 효율적으로 작성하는 것이 무엇보다 중요하다.
지금까지 계속 강조했듯, 데이터베이스 성능은 I/O효율에 달려있으므로 동이한 레코드를 반복적으로 읽지 않고 최소블록만 읽도록 해야 한다.

```SQL

-- 성능저해요소
-- 모든 조인레코드에 대해 사용자정의함수와 스칼라 서브쿼리를 수행하고 있다.
-- 모든 레코드에 대해 조인할 필요없이 출력 대상을 확정짓고 조인해도 된다.

SELECT *
FROM (
  SELECT ROWNUM NO, 등록일자, 번호, 제목, 회원명, 게시판유형명, 질문유형명, 아이콘, 댓글수
  FROM (
    SELECT A.등록일자, A.번호, A.제목, B.회원명, C.게시판유형명, D.질문유형명, GET_ICON(D.질문유형코드) 아이콘, (select...from ...) 댓글수
    FROM 게시판 A, 회원 B, 게시판유형 C, 질문유형 D
    WHERE A.게시판유형 = :TYPE
    AND B.회원번호 = A.작성자번호
    AND C.게시판유형 = A.게시판유형
    AND D.질문유형 = A.질문유형
    ORDER BY A.등록일자 DESC, A.질문유형, A.번호
  )
  WHERE ROWNUM <= (:PAGE * 10)
)
WHERE NO >= (:PAGE - 1) * 10 + 1

-- 다음과 같이 개선이 가능하다.
(
  SELECT A.*, ROWNUM NO
  FROM
  (
    SELECT 등록일자, 번호, 제목, 회원명, 게시판유형명, 질문유형명
    FROM 게시판
    WHERE A.게시판유형 = :TYPE
    AND 작성자번호 IS NOT NULL
    AND 게시판유형 IS NOT NULL
    AND A.질문유형 IS NOT NULL
    ORDER BY 등록일자 DESC, 질문유형, 번호
  ) A
  WHERE ROWNUM <= (:PAGE * 10)
)A, 회원 B, 게시판유형 C, 질문유형 D
WHERE A.NO >= (:PAGE - 1) * 10 + 1
AND B.회원번호 = A.작성자번호
AND C.게시판유형 = A.게시판유형
AND D.질문유형 = A.질문유형
ORDER BY A.등록일자 DESC, A.질문유형, A.번호
```

## 최적의 옵티마이징 팩터 제공

최적화는 옵티마이저가 수행하지만, 잘 할 수 있도록 적잘한 수단을 제고아는 것은 사용자의 몫이다.

앞서 본 사례처럼 불필요한 일은 하지 않고 필요한 최소 블록만 읽도록 쿼리를 논리적으로 잘 구성해야한다.

하지만 옵티마이저는 주어진 환경에서 가장 빠른 처리경로를 찾아줄 뿐, 없는 길을 스스로 만들지는 못한다.

대표적인 옵티마이징 팩터는 다음과 같다.

\- 전략적 인덱스 구성

전략적 인덱스 구성은 옵티마이저를 돕는 가장 기본적인 옵티마이징 팩터다.
인덱스는 항상 sql 조건절을 기준으로 설계해야하는데 어떤 테이블을 어떤 조건으로 자주 액세스하는지는 개발자가 더 잘 안다.
인덱스와 SQL 수행원리를 개발자가 더 많이 공부해야하는 이유다

\- DBMS가 제공하는 다양한 기능 활용
인덱스 외에도 DBMS가 제공하는 다양한 기능을 활요애야한다.
파티션, 클러스터, IOT, MV, RESULT CACHE등 DBMS가 제공하는 기능들을 적그적으로 활용하는 것이 중요하다.

\- 옵티마이저 모드 설정

\- 정확하고 안정적인 토계정보

정리하면,
옵티마이저 모드를 포함해 각종 파라미터를 적절한 값으로 설정하고, 통계정보를 잘 수집하는 것이 중요하다.
전략적 인데스 구성이 필수적으로 뒷받침되야하고 DBMS가 제공하는 기능을 적극적으로 활용해야한다.

## 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스경로 유도

힌트를 통해 직접 데이터 액세스 경로를 선택해줄 ㅅ 있다. 이미 최적으로 실행하고 있더라도 절대 다른 방식으로 바뀌지 않게 실행계획을 고정해야하는 시슽메도 있다.

옵티마이저가 미처 생각하지 못한 최적의 액세스 경로를 찾아내고, 실행계획을 그 방식으로 유도할 수 있는 능력이 필욯다ㅏ

# 튜닝 전문가가 되는 공부방법

## 데이터베이스 튜닝이란?

데이터베이스 튜닝은 일반적으로 성능 튜닝을 말한다.
그리고 데이터베이스는 데이터 파일, 리두로그 파일, 컨트롤 파일 등 파일들의 집합을 의미하는데 튜닝대상은 파일이 아니다.
파일에 데이터를 읽고 쓰는 소프트웨어 애플리케이셔느 즉 DBMS가 대상이다. 따라서 엄밀히 말하면 데이터베이스 성능 튜닝 보다는 DBMS 성능 튜닝이 정확하다.

DBMS는 데이터를 익고 쓸때 SQL을 이용한다. 따라서 sql이 병목이나 지연 없이 빠르고 안정적으로 수행되도록 조치하는 모든 활동이라고 정의할 수 있다.

\- SQL 튜닝 : 아이오 효율화, DB CALL 최소화, SQL 파싱 최소화
\- DB 설계 : 논리적 데이터 구조 설계, 물리적 저장구조 설계
\- 인스턴스 튜닝 : LOCK/LATCH 모니터링 및 해소, 메모리 설정, 프로세스 설정

옵티마이저가 효율적으로 처리할 수 있게 작성한 SQL, 효율적인 데이터 구조가 중요하다.
