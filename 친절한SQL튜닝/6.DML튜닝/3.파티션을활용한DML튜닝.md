파티션을 이용하면 대량 추가/변경/삭제 작업을 빠르게 처리할 수 있다.
이를 이해하려면 파티션에 대한 사전 지식이 필요한데 이번 장에서는 필요한 수준에서만 간단히 정리한다.

# 테이블 파티션

파티셔닝은 테이블 또는 인덱스 데이터를 특정 컬럼 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.
데이터를 월별, 분기별, 반기별, 연별로 분할해서 저장해 두면 빠르게 조회할 수 있고 관리하기도 쉽다.
일반적으로 시계열에 따라 RANGE 방식으로 분활하지만 다른 기준(리스트 또는 해시 방식)으로 분할할 수도 있다.

파티셔닝이 필요한 이유를 관리적 측면과 성능적 측면으로 나눠 짧게 요약하면 다음과 같다.

\- 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경 -> 가용성 향상
\- 성능적 측면 : 파티션 단위 조회 및 DML, 경합 또는 부하 분산

파티션에는 RANGE, 해시, 리스트 세 종류가 있다.

## RANGE 파티션

오라클 8 버전부터 제공된 가장 기초적인 방식으로 주로 날짜 칼럼을 기준으로 파티셔닝 한다.

```sql

-- 주문 테이블을 주문일자 기준으로 분기별 RANGE 파티셔닝하는 방법에 대한 예시이다.
create table 주문 (주문번호 number, 주문일자 varchar2(8), 고객ID varchar2(5), 배송일자 varchar2(8), 주문금액 number, ...)
partition by range(주문일자) (
  partition P2017_Q1 values less then ('20170401')
  partition P2017_Q2 values less then ('20170701')
  partition P2017_Q3 values less then ('20171001')
  partition P2017_Q4 values less then ('20180101')
  partition P2018_Q1 values less then ('20180401')
  partition P9999_MX values less then (MAXVALUE) -- 주문일자 >= '20180401'
)

```

위와 같은 파티션 테이블에 값을 입력하면 각 레코드를 파티션 키 값에 따라 분할 저장하고 읽을 때도 검색 조건을 만족하는 파티션만 골라 읽을 수 있어
이력성 데이터를 FULL SCAN 방식으로 조회할 때 성능을 크게 향상한다. 보관주기 정책에 따라 과거 데이터가 저장된 파티션만 백업하고 삭제하는 등 데이터 관리 작업을 효율적이고 빠르게 수행할 수 있는 장점도 있다.
파티션 테이블에 대한 SQL 성능 향상 요인은 파티션 PRUNING에 있다. 파티션 PRUNING은 SQL 하드파싱이나 실행 시점에 조건절을 분석해 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.

```SQL
SELECT *
FROM 주문
WHERE 주문일자 >= '20120401'
AND 주문일자 <= '20120630'
```

이 조건절을 만족하는 데이터는 1200만 건 중 300만 건 이다. 이 정도 데이터를 인덱스로 스캔하고 랜덤 액세스하면 테이블 전체를 스캔하는것 보다 성능이 더느리다. 그렇다고 테이블 전체를 스캔하자니 사이즈가 너무 커 부담스럽다.

그럴 때 100만 건 단위로 나눠서 저장하면 FULL SCAN 하더라도 전체가 아닌 일부 파티션만 세그먼트하고 멈출 수 있어 성능을 크게 향상시킨다.

파티션도 클러스터 IOT와 마찬가지로 관련있는 데이터가 흩어지지 않고 물리적으로 인접하도록 저장하는 클러스터링 기술에 속한다.
클러스터와 다른 점은 세그먼트 단위로 모아서 저장한다는 것이다. 클러스터는 데이터 블록 단위로 모아 저장한다.
IOT는 데이터를 정렬된 순서로 저장하는 구조이다.

## 해시 파티션

해시 파티션은 RANGE 파티션에 이어 오라클 8i 버전부터 제공하기 시작했다.

파티션 키 값을 해시 함수에 입력해 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식이다.

파티션 개수만 사용자가 결정하고 데이터를 분산하는 알고리즘은 오라클 내부 해시함수가 결정한다.

해시 파티션은 고객 ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정해야 효과적이다.

```sql
-- 고객 ID 기준으로 고객 테이블을 해시 파티셔니하는 방법에 대한 예시다.
create table 고객(고객ID varchar2(5), 고객명 varchar2(10), ..._
partition by hash(고객ID) partitions 4;
```

검색할 때는 조건절 비교 값에 똑같은 해시 함수를 적용함으로써 읽을 파티션을 결정한다.
해시 알고리즘 특성상 등치조건 또는 IN-LIST 조건으로 검색할 때만 파티션 PRUNING이 작동한다.

## 리스트 파티션

오라클 9i 버전부터 제공하기 시작한 리스트 파티션은, 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.

```sql

-- 지역분류 기준으로 인터넷매물 테이블을 리스트 파티셔닝하는 방법이다.
create table 인터넷매물 (물건코드 varchar2(5), 지역분류 varchar2(4), ...)
partition by range(지역분류) (
  partition P_지역1 values  ('서울')
  partition P_지역2 values  ('경기', '인천')
  partition P_지역3 values  ('부산', '대구','대전', '광주')
  partition P_기타 values  (DEFAULT)
)

```

RANGE 파티션의 값의 순서에 따라 저장할 파티션이 결정되지만, 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.

해시 파티션과 비교하면, 해시 파티션은 오라클이 정한 해시 알고르리즘에 따라 임의로 분할하는 반면, 리스트 파티션은 사용자가 정의한 논리적인 그룹에 따라 분할한다.

업무적인 친화도에 따라 그룹핑 기준을 정하되, 될 수 있으면 각 파티션에 값이 고르게 분산되도록 해야한다.

---

# 인덱스 파티션

테이블 파티션과 인덱스 파티션은 구분돼야 한다. 인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다. 다양한 인덱스 파티션 구성을 설명하기 위해 우선 테이블 파티션을 다음과 같이 구분한다.

\- 비파티션 테이블

\- 파티션 테이블

인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비파티션 인덱스로 나뉘고, 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 LOCAL과 GLOBAL로 나뉜다

\- 비파티션 인덱스
\- 로컬 파티션 인덱스
\- 글로벌 파티션 인덱스

로컬 파티션 인덱스는 각 테이블 파티션과 인데스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다.
로컬이 아닌 파티션 인덱스는 '모두' 글로벌 파티션 인덱스이며, 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준값 정의)을 갖는다.

## 로컬 파티션 인덱스

테이블 파티션이 계절별로 옷을 관리하는 서랍장이라면 로컬 파티션 인덱스는 개절별로 별도 색인을 만드는 것과 같다.

주문 테이블에 로컬 파티션 인덱스를 만들어 보자.

아래와 같이 CREATE INDEX 문 뒤에 'LOCAL' 옵션을 추가하면 된다.

```sql
create index 주문_x01 on 주문( 주문일자, 주문금액 ) LOCAL;
create index 주문_x02 on 주문( 고객ID, 주문일자 ) LOCAL;
```

로컬 파티션 인덱스는 테이블의 파티션과 인덱스 파티션이 정확히 1:1 대응 관계를 갖도록 오라클이 파티션을 자동으로 관리해준다.

테이블 파티션 구성을 변경하더라도 인덱스를 재생성할 필요가 없다.

변경작업이 순식간에 끝나므로 피크 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다. 로컬 파티션 인덱스의 장점은 관리 편의성에 있다.

## 글로벌 파티션 인덱스

글로벌 파티션 인덱스는 파티션을 테이블과 다르게 구성한 인덱스다. 구체적으로 파티션 유형이 다르거나, 파티션 키가 다르거나, 파티션 기준값 정의가 다른 경우다.

비파티션 테이블이어도 인덱스는 파티셔닝 할 수 있다.

앞서 RANGE 파티션을 설명하면서 만든 주문 테이블에 [주문금액 + 주문일자] 순으로 글로벌 파티션 인덱스를 만든다.

아래와 같이 CREATE INDEX 문 뒤에 GLOBAL 키워드를 추가하여 파티션을 정의하면 된다.

```sql
create index 주문_x03 on 주문 (주문금액, 주문일자) GLOBAL
partition by range(주문금액) (
  partition P_01 values less than (100000)
  partition P_MX values less than (MAXVALUE) -- 주문금액 >= 100000
)
```

글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 UNUSABLE 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.

테이블과 인덱스가 정획히 1:1 관계가 되도록 DB 관리자가 파티션을 직접 구성할 수도 있지만, 그렇다고 그것이 로컬 파티션은 아니다. 오라클이 자동으로 관리해주지 않기 때문이다.

## 비파티션 인덱스

비파티션 인덱스는 말 그대로 파티셔닝하지 않은 인덱스다. 만드는 방법은 일반 CREATE INDEX를 이용하는 것이다.

```sql
create index 주문_x04 on 주문(고객iD, 배송일자)
```

비파티션 인덱스는 테이블의 여러 파티션을 가리킨다. 그런 의미에서 비파티션 인덱스를 글로벌 비파티션 인덱스라고 부르기도 한다.

글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 UNUSABLE 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.

## PREFIXED VS. NONPREFIXED

파티션 인덱스를 PREFIXED 와 NONPREFIXED로 나눌 수도 있다.
이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.

\- PREFIXED : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.

\- NONPREFIXED : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다

글로벌 파티션 인덱스는 PREFIXED 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비 파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리할 수 있다.

\- 로컬 PREFIXED 파티션 인덱스
\- 로컬 NONPREFIXED 파티션 인덱스
\- 글로벌 PREFIXED 파티션 인덱스
\- 비파티션 인덱스

```sql
select i.index_name, i.partitioned p.partitioing_type, p.locality, p.alignment
from user_indexes i, user_part_indexes p
where i.table_name = '주문'
and p.index_name(+) = i.index_name
order by i.index_name;

-- index_name   par   partition   local   aligment
-- 주문_x01      YES    RANGE       LOCAL   PREFIXED
-- 주문_x02      YES    RANGE       LOCAL   NON_PREFIXED
-- 주문_x03      YES    RANGE       GLOBAL   PREFIXED
-- 주문_x04      NO
```

## 중요한 인덱스 파티션 제약

인덱스 파티션과 관련해 반드시 기억해야할 제약이 있다.

UNIQUE 인덱스를 파티셔닝 하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.

만약 이 제약이 없으면 어떻게 될까?

우선 이 제약에 어긋나지 않는 경우부터 살펴보자.

예를 들어 '주문일자'로 파티셔닝한 테이블이 있다. PK는 '주문일자 + 주문번호' 이고 인덱스는 로컬 파티션이다.

결국 PK 인덱스도 주문일자로 파티셔닝한 셈이므로 파티션 키가 인덱스 구성 컬럼이다.

이 상태에서 2017년 12월 25일에 주문번호 123456 인 주문 레코드를 입력하면, 중복 값 확인 위해 P2017_Q4 파티션 인덱스만 탐색하면 된다.
2017년 12월 주문은 P2017_Q4 파티션에만 입력될 수 있기 때문이다.

이번에는 pk 인덱스가 주문번호 단일 컬럼인 경우를 보자. 테이블 파티션키인 주문일자가 인덱스 구성 컬럼이 아니다.

방금 설명한 제약 때문에 인덱스를 파티셔닝 할 수 없지만 파티셔닝을 허용했다고 가정하자.

이 상태에서 주문번호가 123456인 주문 레코드를 입력하면 중복 값이 있는지 확인하기위해 인덱스 파티션을 모두 탐색해야 한다.

주문번호가 123456인 레코드는 어떤 파티션에든 입력 될 수 있기 때문이다.
게다가 그 레코드를 입력하고 커밋하기 전까지, 다른 트랜잭션이 같은 주문번호로 다른 파티션에 입력하는 현상까지 막으려면 추가적인 LOCK 메커니즘이 필요하다.

지금 본 것처럼 UNIQUE 인덱스를 파티셔닝할 때 파티션 키 인덱스 컬럼에 포함돼야 한다는 조건은 DML 성능 보장을 위해 당연히 있어야 할 제약조건이다.
그리고 파티션 키 조건없이 PK인덱스로 엑세스하는 수많은 쿼리 성능을 위해서도 필요하다.

문제는, 이 제약으로 인해 PK 인덱스를 로컬 파티셔닝 하지 못하면 파티션 DROP, TRUNCATE, EXCHANGE, SPLIT MERGE 같은 파티션 구조 변경 작업이 쉽지 않다는데 있다.

이들 작업을 하는 순간 PK 인덱스가 UNUSABLE 상태로 바뀌기 때문이다. 곧바로 인덱스를 rebuild 하면 되지만, 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.

서비스 중단 없이 파티션 구조를 빠르게 변경하려면, pk를 포함한 모든 인덱스가 로컬 파티션 인덱스이어야 한다.

파티션을 활용한 대량 UPDATE/DELETE/INSERT 는 파티션 구조 변경작업을 수반하며 ILM을 지원하는 매우 중요한 기능이다.

이 기능을 활용해 ILM 관리체계를 효과적으로 운영하려면 가급적 인덱스를 로컬 파티션으로 구성해야 하며, 그러기 위해 테이블을 설계할 때부터 pk를 잘 구성해줘야한다.

---

# 파티션을 활용한 대량 UPDATE 튜닝

인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터를 입력/수정/삭제할 때는 1절 4항에서 본 것 처럼 인덱스를 DROP 하거나 UNUSABLE 상태로 변경하고서 작업하는 방법을 많이 활용한다.

손익분기점은 5% 정도로 입력/수정/삭제하는 데이터 비중이 5%를 넘는다면 인덱스 없이 작업한 후에 재생성하는 게 더 빠르다는 뜻이다.

```sql
-- 거래테이블이 10억건이 저장돼 있다.
-- UPDATE 문을 이용해 2015년 1월 1일 전에 발생한 거래 데이터를 수정하려는데, 거래 일자 조건을 만족하면서 상태코드가 'ZZZ 가 아닌 데이터가 5000만 건이다.
-- 테이블 레코드 5000만 건을 변경하면서 거래_X2 인덱스 까지 실시간으로 관리하려면 많은 시간이 소요된다.

update 거래 set 상태코드 = 'ZZZ'
where 상태코드 <> 'ZZZ'
and 거래일자 < '20150101'
```

## 파티션 EXCHANGE를 이용한 대량 데이터 변경

테이블이 파티셔닝 돼있고 인덱스도 로컬 파티션이라면 좋은 해법이 있다.
수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기 하는 방식이다.

작업순서는 다음과 같다.

(스크립트를 단순화 하기 위해 2015년 1월 1일 전에 발생한 거래 데이터는 모두 201412파티션에 저장돼 있다고 가정한다. 즉, '201412' 파티션이 첫 번째 파티션이다.)

```sql

-- 1. 임시 테이블을 생성한다. 할수 있다면 nologging 모드로 생성한다.
create table 거래_t
nologging
as
select * from 거래 where 1=2;

-- 2. 거래 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정한다.
insert /*+append*/ into 거래_t
select 고객번호, 거래일자, 거래순번, ...
,(case when 상태코드 <> 'ZZZ' then 'ZZZ' else 상태코드 end) 상태코드
from 거래
where 거래일자 < '20150101';

-- 3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성한다. 할 수 있다면 nologging 모드로 생성한다.
create unique index 거래_t_pk on 거래_t (고객번호, 거래일자, 거래순번) nologging;
create index 거래_t_x1 on 거래_t(거래일자, 고객번호) nologging;
create index 거래_t_x2 on 거래_t(상태코드, 거래일자) nologging;

-- 4. 2014 년 12월 파티션과 임시 테이블을 EXCHANGE 한다.
alter table 거래
exchange partition p201412 with table 거래_t
including indexes without validation;

-- 5. 임시 테이블을 DROP 한다.
drop table 거래_t;

-- 6. nologging 모드로 작업했다면 파티션을 logging 모드로 전환한다.
alter table 거래 modify partition p201412 logging;
alter index 거래_pk modify partition p201412 logging;
alter index 거래_x1 modify partition p201412 logging;
alter index 거래_x2 modify partition p201412 logging;
```

---

# 4. 파티션을 활용한 대량 DELETE 튜닝

아래와 같은 조건절로 수천만 건 데이터를 삭제할 때도, 인덱스를 실시간으로 관리하려면 큰 시간이 소모된다.

```sql
delete from 거래
where 거래일자 < '20150101'
```

그렇다고 초대용량 테이블 인덱스를 모두 DROP 했다가 다시 생성하기도 만만치 안다.
UPDATE는 변경 대상 컬럼을 포함하는 인덱스만 재생성하면 되지만, DELETE 는 모든 인데스를 재생성해야한다.

## DELETE가 느린 이유

아래와 같이 여러 부수작업을 수반하므로 느리다.

1. 테이블 레코드 삭제
2. 테이블 레코드 삭제에 대한 UNDO LOGGING
3. 테이블 레코드 삭제에 대한 REDO LOGGING
4. 인덱스 레코드 삭제
5. 인덱스 레코드 삭제에 대한 UNDO LOGGING
6. 인덱스 레코드 삭제에 대한 REDO LOGGING
7. UNDO 에 대한 REDO LOGGING

특히, 각 인덱스 레코드를 찾아서 삭제해 주는 작업에 대한 부담이 크다. 건건이 수직적 탐색과정을 거처 레코드를 찾아야하기 때문이다.

## 파티션 DROP 을 이용한 대량 데이터 삭제

테이블 삭제 조건절(거래일자 < '20150101') 이 컬럼 기준으로 파티셔닝돼 있고 인덱스도 다행히 로컬 파티션이라면, 아래와 같이 간단한 문장 하나로 대량 데이터를 순식간에 삭제할 수 있다.

```sql
alter table 거래 drop partition p201412;

-- 오라클 11g 부터 아래와 같이 값을 이용해 대상 파티션을 지정할 수도 있다.
alter table 거래 drop partition for ('20141201')
```

## 파티션 TRUNCATE 를 이용한 대량 데이터 삭제

거래이자 조건에 해당하는 데이터를 일괄 삭제하지않고 아래와 같이 또 다른 삭제 조건이 있는 경우가 있다.

(상태코드 <> 'ZZZ' or 상태코드 Is null) 조건을 만족하는 데이터가 소수라면, 아래 DELETE 문을 그대로 사용하면 된다.

```sql
delete from 거래
where 거래일자 < '20150101'
and (상태코드 <> 'ZZZ' or 상태코드 Is null)
```

(상태코드 <> 'ZZZ' or 상태코드 Is null) 조건을 만족하는 데이터가 대다수이면, 대량 데이터를 지울 게 아니라 남길 데이터만 백업했다가 재입력하는 방식이 빠르다.

```sql
-- 1.임시 테이블을 생성하고, 남길 데이터만 복제한다.

create table t
as
select *
from 거래
where 거래일자 < '20150101'
and 상태코드 = 'ZZZ'

-- 2. 삭제 대상 테이블 파티션을 TRUNCATE 한다.
alter table 거래 truncate partition p201412;

-- 오라클 11g 부터 아래와 같이 값을 이용해 대상 파티션을 지정할 수 있다.
alter table 거래 truncate partition for ('20141201');

-- 3. 임시 테이블에 복재해 둔 데이터를 원본 테이블에 입력한다.
insert into 거래
select * from 거래_t;

-- 4. 임시 테이블을 DROP 한다.
drop table 거래_t;
```

서비스 중단 없이 파티션을 DROP 또는 truncate 하려면 아래 조건을 모두 만족해야 한다.

1. 파티션 키와 커팅 기준 컬럼이 일치해야 함

- 예를 들어, 파티션 키와 커팅 기준 컬림이 모두 '신청일자'

2. 파티션 단위와 커팅 주기가 일치해야 함

- 예를 들어, 월 단위 파티션을 월 주기로 커팅

3. 모든 인덱스가 로컬 파티션 인덱스이어야 함

- 예를 들어 , 파티션 키는 '신청일자', PK는 '신청일자 + 신청순번'
- PK 인덱스는 지금처럼 삭제 기준(파티션 키) 컬럼이 인덱스 구성 컬럼이어야 로컬 파티셔닝 가능

---

5. 파티션을 활용한 대량 INSERT 튜닝

# 비파티션 테이블일 때

비파티션 테이블에 손익분기점을 넘는 대량 데이터를 iNSERT 하려면, 인데스를 UNUSABLE 시켰다가 재생성하는 방식이 더 빠를 수 있다.

```sql

-- 할 수 있다면 테이블을 nologging 모드로 전환한다.

alter table target_t nologgingl

-- 인덱스를 unusable 상태로 전환한다.
alter index target_t_x01 unusable;

-- 할 수 있다면 DIRECT PATH INSERT 방식으로 대량 데이터를 입력한다

insert /*+append*/ into target_t
select * from source_t

-- 할 수 있다면 테이블을 nologging 모드로 인덱스를 재생성한다.
alter index target_t_x01 rebuild nologging

-- nologging 몯로 작업했다면 Logging 몯로 전환한다.
alter table target_t logging;
alter index taret_t_x01 logging;
```

## 파티션 테이블일때

초대용량 인덱스를 재생성하는 부담이 만만치 않기 때문에 시간이 더 오래 걸리더라도 왠만하면 인덱스르 그대로 둔 상태로 INSERT 한다. 하지만 테이블 파티셔닝이돼 있고, 인덱스도 다행히 로컬 파티션이라면 고민 해결이다.
파티션 단위로 인덱스를 재생성할 수 있기 때문이다.

```sql

-- 할 수 있다면 작업 대상 테이블 파티션을 nologging 모드로 전환한다.

alter table target_t modify partition p_201712 nologging;

-- 작업 대상 테이블 파티션과 매칭되는 인덱스 파티션을 unusable 상태로 전환한다.
alter index target_t_x01 modify partition p_201712 unusable;

-- 할 수 있다면 DIRECT PATH INSERT 방식으로 대량 데이터를 입력한다
insert /*+append*/ into target_t
select * from source_t where dt between '20171201' and '20171231';

-- 할 수 있다면 테이블을 nologging 모드로 인덱스를 재생성한다.
alter index target_t_x01 rebuild partition p_201712 nologging

-- nologging 몯로 작업했다면 Logging 몯로 전환한다.
alter table target_t modify partiton p_201712 logging;
alter index taret_t_x01 modify partiton p_201712 0....00logging;
```
