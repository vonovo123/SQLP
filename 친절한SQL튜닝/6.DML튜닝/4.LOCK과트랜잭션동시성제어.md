LOCK은 데이터베이스의 특징을 결정짓는 가장 핵심적인 메커니즘이다. 자신이 사용하는 데이터베이스의 고유한 lock 메커니즘을 이해하지 못하면 고품질, 고성능 애플리케이션을 구축하기 어렵다.
트랜잭션 동시성 제어도 반드시 학습해야 할 주제다.

# 1. 오라클 LOCK

오라클은 공유 리소스에 사용자 데이터를 보호할 목적으로 DML LOCK, DDL LOCK, LETCH BUFFER LOCK, LIBRARY CACHE LOCK/PIN 등 다양하다. 이 외에도 내부에 더 많은 종류가 존재한다.

LETCH는 SGA에 공유된 각종 자료구조를 보호하기 위해 사용하며, 버퍼 LOCK은 버퍼블록에 대한 액세스를 직렬화하기 위해 사용한다.

라이브러리 캐시 LOCK과 PIN은 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용한다.

애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 LOCK은 무엇보다 DML LOCK이다.

DML LOCK은 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해 준다.

DML LOCK에는 테이블 LOCK 과 로우 LOCK이 있다.

## DML 로우 LOCK

두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 LOCK을 먼저 설정해야 한다.

어떤 DBMS 이든지 DML 로우 LOCK에는 배타적 모드를 사용하므로 UPDATE 또는 DELETE를 진행 중인달 아직 커밋하지 않은 로우를 다른 트랜잭션이 UPDATE 또는 DELETE 할 수 없다.

INSERT에 대한 로우 LOCK 경합은 UNIQUE 인덱스가 있을때만 발생한다. 즉, UNIQUE 인덱스가 있는 상황에서 두 트랜잭션이 같은 값을 입력하려고 할 때, 블로킹이 발생한다.

블로킹이 발생하면, 후행 트랜잭션은 기다렸다가 선행 트랜잭션이 커밋하면 INSERT에 실패하고, 롤백하면 성공한다.

두 트랜잭션이 서로 다른 값을 입력하거나 UNIQUE 인덱스가 아예 없으면 INSERT에 대한 로우 LOCK 경합은 발생하지 않는다.

MVCC 모델을 사용하는 오라클은 SELECT 문에 로우 LOCK을 사용하지 않는다.

요약하면, 오라클은 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 '시작된 지점' 으로 되돌려서 읽는다.

변경이 진행 중인 로우를 읽을 때도 LOCK이 풀릴 때까지 기다리지 않고 복사복을 만들어서 읽는다.

따라서 SELECT 문에 LOCK 을 사용할 필요가 없다.

결국, 오라클에서 DML과 SELECT는 서로 진행을 방해햐지 않는다. 물론 SELECT 끼리도 서로 방해하지 않는다.

DML 끼리는 서로 방해할 수 있는데, 이는 어떤 DBMS를 사용하더라도 마찬가지이다.

참고로, MVCC 모델을 사용하지 않는 DBMS는 SELECT 문에 공유 LOCK을 사용한다. 공유 lOCK 끼리는 호환된다. 두 트랜잭션이 같이 LOCK을 설정할 수 있다는 뜻이다.

반면, 공유 LOCK 과 배타적 LOCK 은 호환되지 않기 때문에 DML 과 SELECT가 서로 진행을 방해할 수 있다. 즉, 다른 트랜잭션이 읽고 있는 로우를 변경하면 다음 레코드로 이동할때까지 기다려야 하고
다른 트랜잭션이 변경 중인 로우를 읽으려면 커밋할 때 까지 기다려야 한다.

DML 로우 LOCK에 의한 성능 저하를 방지하려면, 온라인 트랜잭션을 처리하는 주간에 LOCK을 필요 이상으로 오래 유지하지 않도록 커밋 시점을 조절해야 한다.

그에 앞서 트랜잭션이 빨리 일을 마치도록, 즉 LOCK이 오래 지속되지 않도록 관련 SQL을 모두 튜닝해야 한다.

## DML 테이블 lock

오라클은 DML 로우 lock을 설정하기에 앞서 테이블 LOCK 을 먼저 설정한다. 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서다.

테이블 LOCK을 TM LOCK 이라고 부르기도 한다.

오라클은 로우 LOCK 에 항상 '배타적 모드'를 사용하지만 테이블 LOCK에는 여러가지 LOCK모드를 사용한다.

선행 트랜잭션과 호환되지 않는 모드로 테이블 LOCK을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.

```sql

-- rs : row share
-- rx : row exclusive
-- s : share
-- srx : share row exclusive
-- x : exclusive

--      null   rs    rx    s   srx   x
-- null  O      O     O    O    O    O
--  rs   O      O     O    O    O
--  rx   O      O     O
--  s    O      O          O
-- srx   O      O
--  x    O
```

INSERT, UPDATE, DELETE, MERGE 문을 위해 로우 lOCK을 설정하려면 해당 테이블에 RX 모드 테이블 LOCK을 먼저 설정해야한다.

SELECT FOR UPDATE 문을 위해 로우 LOCK을 설정하려면 10g 이하는 RS 모드, 11g 이상은 RX 모드 테이블 LOCK을 먼저 설정해야 한다.

RS,RX 간에는 어떤 조합으로도 호환 되므로 SELECT FOR UPDATE 나 DML문 수행 시 테이블 LOCK에 의한 경합은 절대 발생하지 않는다. 같은 로우를 갱신하려고 할 때만 로우 LOCK에 의한 경합이 발생한다.

테이블 LOCK 이라고 하면, 테이블 전체에 lock 이 걸린다고 생각하기 쉽다. 그래서 다른 트랜잭션이 더는 레코드를 추가하거나 갱신하지 못하게 막는다고 생각한다.

하지만 DML을 수행하기 전에 항상 테이블 LOCK을 먼저 설정하므로 그렇게 이해하는 것은 맞지 않다. 하나의 로우를 변경하기 위해 테이블 전체에 LOCK을 거는것은 성능상 좋지 못하다.

오라클에서 말하는 테이블 LOCK은 테이블 LOCK 을 설정한 트랜잭션이 해당 테이블에서 현재 어떤 작업을 수행중인지를 알리는 일종의 푯말이다.

그리고 위에서 본 것처럼 테이블 LOCK에는 여러 가지 모드가 있고 어떤 모드를 사용했는지에 따라 후행 트랜잭션이 수행할 수 있는 작업의 범위가 결정된다.

진행할 수 없다면 기다릴지, 아니면 작업을 포기할지 진로를 결정 해야 한다. 기다려야 한다면, 대기자 목록에 LOCK 요청을 등록하고 기다린다.

예를 들어, DDL을 이용해 테이블 구조를 변경하려는 트랜잭션은 해당 테이블에 TM LOCK이 설정돼 있는지 먼저 확인한다.

TML LOCK을 RX 모드로 설정한 트랜잭션이 하나라도 있으면, 현재 테이블을 갱신 중인 트랜잭션이 있다는 신호다. 따라서 ORA-00054 메시지를 남기고 작업을 멈춘다.

반대로 DDL 문이 먼저 수행 중일 때는, DML 문을 수행하려는 트랜잭션이 기다린다.

### 대상 리소스가 사용 중일 때, 진로 선택

LOCK을 얻고자 하는 리소스가 사용 중일 때, 프로세스는 아래 세 가지 방법 중 하나를 택한다. 보통은 내부적으로 진로가 결정돼 있지만, 사용자가 선택할 수 있는 경우도 있다.

사용자가 이 세 가지 옵션을 모두 선택할 수 있는 문장이 바로 SELECT FOR UPDATE 이다.

1. LOCK 이 해제될 때까지 기다린다 (select \* from t for update)

2. 일정 시간만 기다리다가 포기한다. (select \* from t for update wait 3)

3. 기다리지 않고 작업을 포기한다. (select \* from t for update nowait)

DML을 수행할 때 묵시적으로 테이블 LOCK 을 설정하는데, 이때는 1번, 기다리는 방법을 선택한다.

LOCK TABLE 명령을 이용해 명시적으로 테이블 LOCK을 설정할 때도 기본적으로 기다리는 방법을 선택하지만, NOWAIT 옵션을 이용해 곧바로 작업을 포기하도록 사용자가 지정할 수 있다.

```sql
  lock table emp in exclusive mode NOWAIT;
```

DDL을 수행할 땓 내부적으로 테이블 LOCK을 설정하는데, 이때 NOWAIT 옵션이 자동으로 지정된다.

오라클 11g 부터 ddl_lock_timeout 파라미터를 0 보다 크게 설정하면, 설정한 시간 만큼 기다리다가 작업을 포기하게 할 수 있다.

## LOCK 을 푸는 열쇠, 커밋

가끔 블로킹과 교착상태를 구분 못하는 분들이 있다. 블로킹은 선행 트랜잭션이 설정한 LOCK 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태를 말한다. 이를 해소하는 방법은 커밋 뿐이다.

교착상태는 두 트랜잭션이 각각 특정 리소스에 LOCK을 설정한 상태에서 맞은편 트랜잭션이 LOCK을 설정한 리소스에 또 LOCK을 설정하려고 진행하는 상황을 말한다.

교착상태가 발생하면 둘 중 하나가 뒤로 물러나지 않으면 풀릴 수 없다.

오라클에서 교착상태가 발생하면 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 에러메시지를 던진다. 교착상태를 발생시킨 문장 하나만 롤백하는 것이다.

```sql
deadlock detected while waiting for resource
```

이제 교착상태는 해소됐지만 블로킹 상태에 놓이게 된다. 따라서 이 메시지를 받은 트랜잭션은 커밋 또는 롤백을 결정해야 한다.

만약 프로그램 내에서 이 에러에 대한 예외처리를 하지 않는다면 대기 상태가 지속된다.

오라클에서 데이터를 읽을 때 LOCK을 사용하지 않으므로 다른 dbms에 비해 상대적으로 lock 경합이 적게 발생한다. 읽는 트랜잭션의 진행을 막는 부담감이 없으므로 필요한 만큼 트랜잭션을 충분히 길게 가져갈 수 있다.

그렇더라도 불필요하게 트랜잭션을 길게 정의하지 않도록 주의해야 한다. 트랜잭션이 너무 길면 롤백해야 할 때 너무 많은 시간이 걸려 고생할 수 있고 undo 세그먼트가 고갈되거나 undo 세그먼트 경합을 유발할 수도 있다.

같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 애플리케이션을 설계해야 하고 DML LOCK 때문에 동시성이 저하되지 않도록 적절한 시점에 커밋해야 한다.

반대로 불필요하게 커밋을 너무 자주 수행하면 서버 프로세스가 LGWR에게 로그 버퍼를 비우도록 요청하고 동기 방식으로 기다리는 횟수가 늘기 때문에 느려진다.

잦은 커밋 때문에 성능이 매우 느리다면 오라클 10gR2 부터 제공하는 비동기식 커밋과 배치 커밋을 활용하는 방안을 검토할 수 있다.

\- WAIT : LGWR 가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때 까지 기다린다(동기식 커밋)

\- NOWAIT : 완료 메시지를 기다리지 않고 바로 다음 트랜잭션을 진행한다(비동기식)

\- IMMEDIATE : 커밋 명령을 받을 때마다 LGWR가 로그 버퍼 파일을 기록한다.

\- BATCH : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄처리한다.

이들 옵션을 조합해 아래 네 가지 커밋 명령을 사용할 수 있다.

```sql
COMMIT WRITE IMMEDIATE WAIT;
COMMIT WRITE IMMEDIATE NOWAIT;
COMMIT WRITE BATCH WAIT;
COMMIT WRITE BATCH NOWAIT;
```

# 트랜잭션 동시성 제어

동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다.

'비관적 동시성 제어'는 사용자들이 같은 데이터를 동시에 수정할 것으로 가정한다. 따라서 한 사용자가 데이터를 읽는 시점에 LOCK을 걸고 조회 또는 갱신처리가 완료 될 때 까지 이를 유지한다.

LOCK은 첫 번째 사용자가 트랜잭션을 완료하기 전까지 다른 사용자들이 같은 데이터를 수정할 수 없게 만들기 때문에 비관적 동시성 제어를 잘못 사용하면 동시성이 나빠진다. 반대로 잘 사용하면 약이 될 수도 있다.

'낙관적 동시성 제어' 는 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정한다. 따라서 데이터를 읽을 때 LOCK을 설정하지 않는다.

그런데 낙관적 입장에 섰다고 해서 동시 트랜잭션에 의한 잘못된 데이터 갱신을 신경 쓰지 않아도 된다는 것은 절대 아니다. 읽는 시점에 LOCK을 사용하지 않았지만, 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사요자에 의해 변경 되었는지 반드시 검사해야 한다.

## 비관적 동시성 제어

우수 고객을 대상으로 적립포인트를 제공하는 이벤트를 실시한다고 가정하자.
고객의 다양한 실적정보를 읽고 복잡한 산출공식을 이용해 적립포인트를 계산하는 동안 다른 트랜잭션이 같은 고객의 실적정보를 변경한다면 문제가 생길 수 있다.

아래와 같이 SELECT 문에 FOR UPDATE를 사용하면 고객 레코드에 LOCK을 설정하므로 데이터가 잘못 갱신되는 문제를 방지할 수 있다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 from 고객
where 고객번호 = :cust_num for update;
```

비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있지만, FOR UPDATE 에 WAIT 또는 NOWAIT 옵션을 함께 사용하면 LOCK을 얻기 위해 무한정 기다리지 않아도 된다.

```sql
for update nowait -- 대기없이 EXCEPTION을 던짐
for update wait 3 -- 3초 대기 후 EXCEPTION을 던짐
```

WAIT 또는 NOWAIT 옵션을 사용하면, 다른 트랜잭션에 의해 LOCK이 걸렸을때 EXCEPTION 을 만나게 되므로 '다른 사용자에 의해 변경 중이므로 다시 시도하십시오' 라는 메세지를 출력하면서 트랜잭션을 종료할 수 있다.
따라서 오히려 동시성을 증가시킨다.

### QUEUE 테이블 동시성 제어

큐 테이블에 쌓인 고객 입금 정보를 일정한 시간 간격으로 읽어서 입금 테이블에 반영하는 데몬 프로그램이 있다고 가정하자.

데몬이 여러 개이므로 LOCK이 걸릴 수 있는 상황이다.

LOCK이 걸리면 3초간 대기했다가 다음에 다시 시도하게 하려고 아래와 같이 for update wait 3 옵션을 지정했다. 큐에 쌓인 데이터를 한 번에 다 읽어서 처리하면 LOCK이 풀릴 때 까지 다른 데몬이 오래 걸릴 수 잇으므로 고객정보를 100개 씩만 읽도록 한다.

```sql
select cust_id, rcpt_amt from cust_rcpt_q
where yn_upd = 'Y' and rownum <= 100 FOR UPDATE WAIT 3;
```

이럴 때 아래와 같이 skip locked 옵션을사용하면 lock이 걸린 레코드는 생략하고 다음 레코드를 계속 읽도록 구현할 수 있다.

```sql
select cust_id, rcpt_amt from cust_rcpt_q
where yn_upd = 'Y' FOR UPDATE SKIP LOCKED;
```

## 낙관적 동시성 제어

아래는 SELECT-LIST에서 네 개 컬럼을 참조햇을 때의 낙관성 동시성 제어 예시다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into :a, :b, :c, :d
from 고객
where 고객번호 = :cust_num

-- 새로운 적립포인트 계산

update 고객 set 적립포인트 = : 적립포인트
where 고객번호 = :cust_num
and 적립포인트 = :a
and 방문횟수  = :b
and 최근방문일시 = :c
and 구매실적 = :d ;

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되엇습니다.');
end if
```

SELECT 문에서 읽은 컬럼이 매우 많다면 UPDATE 문에 조건절을 일일이 기술하는 것은 귀찮을 일이다. 만약 UPDATE 대상 테이블에 최종변경일시를 관리하는 컬럼이 있다면, 이를 조건절에 넣어 간단히 해당 레코드의 갱신여부를 판단할 수 있다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시
into :a, :b, :c, :d, :mod_dt
from 고객
where 고객번호 = :cust_num

-- 새로운 적립포인트 계산

update 고객 set 적립포인트 = : 적립포인트
where 고객번호 = :cust_num
and 변경일시 = :mod_dt ;

if sql%rowcount = 0 then
  alert('다른 사용자에 의해 변경되엇습니다.');
end if
```

낙관적 동시성 제어에서도 UPDATE 전에 아래 SELECT 문을 한 번 더 수행함으로써 LOCK에 대한 예외처리를 한다면, 다른 트랜잭션이 설정한 LOCK을 기다리지 않게 구현할 수 있다.

```SQL
SELECT 고객번호
FROM 고객
WHERE 고객번호 = :cust_nm
AND 변경일시 = :mod_dt
for update nowait;
```

## 동시성 제어 없는 낙관적 프로그래밍

낙관적 동시성 제어를 사용하면 LOCK이 유지되는 시간이 매우 짧아져 동시성을 높이는 데 매우 유리하다. 하지만 다른 사용자가 같은 데이터를 변경했는지 검사하고 그에 따라 처리 방향성을 결정하는 귀찮은 절차가 뒤따른다.

온리안 쇼핑몰에서 특정 상품을 조회해서 결제를 완료하는 순간까지를 하나의 트랜잭션으로 정의했다고 가정하자.

주문을 진행하는 동안 가격이 수정되었다면 최종 결제 버튼을 클릭하는 순간의 가격처리는 어떻게 될까?

가격 처리가 상품 정보를 조회한 시점 기준이라면 문제가 없지만 그렇지 않다면 상품가격의 변경 여부를 체크함으로써 해당 주문을 취소시키거나 사용자에게 변경사실을 알리고 처리방향을 확인 받아야 한다.

```sql
insert into 주문
select :상품코드, :고객ID, :주문일시, :상점번호, ...
from 상품
where 상품코드 = :상품코드
and 가격 = :가격  -- 주문을 시작한 시점 가격

if sql%rowcount = 0 then
  alert("상품가격이 변경되었습니다.")
end if;
```

쿼리를 낙관적으로 개발한다면 이런 로직을 찾아보기 힘들다.

# 채번 방식에 따른 INSERT 성능 비교

INSERT, UPDATE, DELETE MERGE 중 가장 중요하고 튜닝 요소가 많은 것은 INSERT다. 수행빈도가 가장 높아서 그렇기도 하지만, 채번 방식에 따른 성능 차이가 매우 크기 때문이다.

신규 데이터를 입력하려면 PK 중복을 방지하기 위한 채번이 선행되어야 하는데, 가장 많이 사용하는 아래 세 가지 채번 방식의 성능과 장단점을 비교해 보자.

\- 채번 테이블

\- 시퀀스 오브젝트

\- MAX + 1 조회

설명의 편의를 위해 PK가 (상담원ID + 상담일자 + 상담순번) 처럼 복합컬럼으로 구성돼 있을 때, 순번 이외의 컬럼을 구분 속성이라고 한다.

## 채번 테이블

각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식이다.

채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는 데 사용한다.

이 방식은 채번 레코드를 변경하는 과정에서 자연스럽게 액세스 직렬화가 이루어지므로 두 트랜잭션이 중복 값을 채번할 가능성을 원칙적으로 방지해 준다.

이 방식의 장점은 다음과 같다.

\- 범용성이 좋다.

\- INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 되므로 채번 함수만 잘 정의하면 편리하게 사용할 수 있다.

\- INSERT 과정에 결번을 방지할 수 잇다.

\- PK 가 복합컬럼일 때도 사용할 수 있다.

이 방식의 가장 큰 단점은 채번 방식에 비해 성능이 안 좋다는데 있다. 채번 레코드를 변경하기 위한 로우 LOCK 경합 때문이다.

로우 LOCK은 기본적으로 대상 테이블에 INSERT를 마치고 커밋 또는 롤백할 때 까지 지속된다.

동시 INSERT가 아주 많으면 채변 레코드뿐만 아니라 채번 테이블 블록 자체에도 경합이 발생한다. 서로 다른 레코드를 변경하는 프로세스끼리도 경합할 수 있다.

PK 가 복합컬럼인 경우, 즉 구분 속성별 순번을 채번하는 경우에는 LOCK 경합이 줄어들지만, 구분 속성 레코드가 소수일 때만 이 방식을 사용하므로 LOCK 경합이 발생할 가능성은
다른 채번 방식에 비해 여전히 높다.

따라서 동시 INSERT가 아주 많은 테이블에는 사실상 이 방식을 사용하기 어렵다.

### 자율 트랜잭션

PL/SQL의 자율 트랜잭션 기능을 이용하면 메인 트랜잭션에 영향을 주지 않고 서브 트랜잭션에서 일부 자원만 LOCK을 해제할 수 있다. 방법은 간단하다.
PL/SQL 선언부에 아래와 같이 'pragma autonomous_transaction' 이라고선언하면 된다.

```sql
create or replace function seq_nextval(l_gubun number) return number;
as
   pragma autonomouse_transaction;
  l_new_seq_tab.seq%type
begin
  update seq_tab
  set seq = seq + 1
  where gubun = l_gubun;

  select seq into l_new_sq
  from sq_tab
  where gubun = l_gubun;

  commit;
  return l_new_seq;
end;
```

PL/SQL 함수/프로시저를 지율 트랜잭션으로 선언하면, 그 내부에서 커밋을 수행해도 메인 트랜잭션은 커밋하지 않은 상태로 남는다.
메인 트랜잭션 INSERT 문에서 아래와 같이 채번 함수를 호출하고 최종적으로 커밋하기 전까지 다른 작업을 많이 수행하더라도 채번 테이블 로우 LOCK 은 이미 해제한 상태이므로 다른 트랜잭션을 블록킹하지 않는다.

```sql
insert into target_tab values ( seq_nextval(123), :x, :y, :z);
```

## 시퀀스 오브젝트

시퀀스의 가장 큰 장점은 성능이 빠르다는데 있다. 채번 테이블과 마찬가지로 INSERT 과정에 중복 레코드 발생에 대비한 예외처리에 크게 신경 쓰지 않아도 된다. 테이블별로 시퀀스 오브젝트를 생성하고
관리하는 부담은 있지만, 개발팀 입장에서는 사용하기에 매우 편리하다.

시퀀스의 가장 큰 장점은 성능이지만, 성능 이슈가 없는 것은 아니다. 시퀀스 채번 과정에 발생하는 LOCK 때문이다. 시퀀스 성능 이슈를 이해하려면 시퀀스 오브젝트가 오라클 내부에서 관리하는 채번 테이블이라는 사실을 이해해야 한다.

구체적으로 SYS.SEQ$테이블을 말하며, DBA_SEQUENCES 뷰를 통해 조회할 수 있다.

스퀀스 오브젝트도 결국 테이블이므로 값을 읽고 변경하는 과정에 LOCK 메커니즘이 작동한다. 시퀀스 LOCK에 의한 성능 이슈가 있지만, 캐시 사이즈를 적절히 설정하면 가장 빠른 성능을 제공한다.
시퀀스에는 자율 트랜잭션 기능도 기본적으로 구현돼 있다.

### 시퀀스 LOCK

오라클이 시퀀스 오브젝트에 사용하는 LOCK 으로는 세 가지가 있다. 로우 캐시 LOCK, 시퀀스 캐시 LOCK, SV LOCK 이 그것이다.

1. 로우 캐시 LOCK

딕셔너리 정보를 매번 디스크에서 읽고 쓰면 성능이 매우 느리므로 오라클은 로우 캐시를 사용한다.
로우 캐시는 SGA 구성요소이므로 정보를 읽고 쓸 때 액세스를 직렬화해야 한다. 이를 위해 사용하는 LOCK이 로우 캐시 LOCK 이다.

로우 캐시를 사용하는 대표저인 오브젝트가 시퀀스이므로 로우 캐시 LOCK 경함이 나타날 수 있다.
즉, nextval을 호출할 때마다 로우 캐시에서 시퀀스 레코드를 변경하애햐는데 많은 사용자가 동시에 nextval을 호출하면 로우 캐시 LOCK 경합이 발생한다.

시퀀스 채번으로 인한 로우 캐시 LOCK 경합을 줄이기 위해 오라클은 기본적으로 CACHE 옵션을 사용한다. 옵션을 명시적으로 설정하지 않았을 때 기본 갑은 20이다.

시퀀스 채번에 의해 로우 캐시 LOCK 경합을 줄이고 싶다면, 이 값을 크게 설정하면 된다.

반대로, 채번 빈도가 낮아 굳이 캐시를 사용하고 싶지 않다면 NOCACHE 옵션을 지정하면 된다.

CACHE 크기를 1000으로 지정한 시퀀스를 생성하고 nextval으 호추하면 last_number 값이 1에서 1001로 증가한다.
nextval을 호출할 때마다 시퀀스 레코드를 변경하지 않아도 된다. 값을 시퀀스 캐시에서 얻으면 되기 때문이다. 시퀀스 캐시의 1000개 값을 모두 소진한 직후 nextval을 호출하면
그때 다시 로우 캐시에서 시퀀스 레코드를 20001로 변경한다.

2. 시퀀스 캐시 LOCK

시퀀스 캐시도 공유 캐시에 위치한다. 따라서 시퀀스 캐시에서 값ㅇ르 얻을 때도 엑세스 직렬화가 필요하며 이를 SQ LOCK이라고 부른다.

3. SV LOCK

시퀀스 캐시는 한 인스턴스 내에서 공유된다. nextval을 호출하는 순서대로 값을 제공하믈 인스턴스 내에서는 번호 순서를 보장한다.
데이터베이스 하나에 인스턴스가 여러 개인 RAC 환경에서는 인스턴스마다 시퀀스 케시를 따로 갖는다.

따라서 인스턴스 간에는 번호 순서를 기본적으로 보장하지 않는다.

예를 들어, 첫 번째 nextval을 1번 인스턴스 A프로세스가 호출하고, 이어서 두 번째 nextVal은 2번 인스턴스 B 프로세스가 호출한다.
그때부터 1번 인스턴스 시퀀스 캐시는 1부터 1000까지의 값을 순서대로 반환하고, 2번 인스턴스 시퀀스 캐시는 10001qjsqnxj 2000까지의 값을 순서대로 반환한다.
따라서 1번 2번 인스턴스에 있는 프로세스드리 교차로 nextval을 호출하면, 테이블에는 아래와 같은 순서로 값이 입력된다.

```sql
1 -> 1001 -> 2 -> 1002 -> 3 -> 1003 ...
```

식별자가 갖추어야 하는 기본 조건은 다음과 같다. 식별자는 값이 유일해야하고, 반드시 값이 있어야 한다.

식별자에 값을 순서대로 입력해야 한다는 조건은 없다. 위와 같이 입력해도 식별자로서의 조건을 전혀 위배하지 않는다.

업무적으로 식별자 순서를 보장해야한다면 ORDER OPTION을 사용해야 한다. 시퀀스 캐시 하나를 모든 RAC 노드가 공유한다.

그런데 자원을 공유할 때는 항상 LOCK 메커니즘이 필요하다. RAC 환경에서 ORDER 옵션을 사용하면 오라클은 'SV LOCK' 을 통해 시퀀스 캐시에 대한 엑세르를 직렬화한다.

RAC 각 노드는 네트워크 상에 서로 분리된 서버인데 네트워크를 통해 시퀀스 캐시를 서로 주고 받으면서 공유한다.

1번 인스턴스에서 nextval 을 연속해서 1000번 호출하고, 이어서 2번 인스턴스에서 연속해서 1000번 을 호출하고, 이어서 다시 1번 인스턴스가 1000번을 호출하는 트랜잭션 패턴이라면 order 옵션을 사용해도 성능이 나빠지ㅣ 않는다.

하지만 1번과 2번 인스턴스가 교대로 nextval을 빠르게 호출하는 트랜잭션 패턴이라면 ORDER 옵션을 사용하는 순간 INSERT 성능이 급격히 나빠진다.

시퀀스의 가장 큰 단점은 기본적으로 PK가 단일컬럼을 때만 사용 가능하다는데 있다. PK 가 복합컬럼일 때도 사용할 수는 있지만, 각 레코드를 유일하게 식별하는 최소 컬럼으로 PK를 구성해야 한다는 최소성 요건을 위배한다.

---

### 순환오변을 가진 시퀀스 화룡

PK가 복합컬럼인데 동시 트랜잭션이 높아 시퀀스가 꼭 필요하다면, 순환 옵션을 가진 시퀀스 활용을 고려할 수 있다. 하루에 도저히 도달할 수 없는 값으로 최대값을 설정하고, 그 값에 도달하면 1부터 다시 시작하도록
순환오변을 설정한다.

---

시퀀스의 또다른 단점은, 신규 데이터를 입력하는 과정에 결번이 생길 수 있다는 점이다.

시퀀스 채번 이후에 트랜잭션을 롤백하는 경우다. 둘째, CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우이다. 자주 사용하지 않아 캐시에서 밀려나거나 인스턴스를 재기동하는 순간, 캐시돼 있던 번호는 모두 사라지며
디스크에서 다시 읽을 때 그 번호부터 읽는다.

사용빈도가 낮아서 생기는 결번은 해결방법이 있다. 시퀀스를 SHARED POOL 에 KEEP 하독 아래 명령을 수행한다.

```sql
EXEC SYS.DBMS_SARED_POOL.KEEP(TABLE_NAME, 'Q')
```

하지만 일련볂의 결변을 반드시 막을 필요는 없다. 데이터를 삭제하면서 생기는 결번은 막을 수 없기 때문이다.

## MAX+1 조회

아래와 같이 대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT하는 방법이다.

```sql
insert into 상품거(거래일련번호, 계좌번호, 거래이시, 상품코드, 거래가격, 거래수량)
values ((select max(거래일련번호) + 1 from 상품거래)), :acnt_no, sysdate, :prod_cd, :trd_price, :trd_qty);


```

이 방식의 장점으로는 첫째, 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 업다. 둘째, 동시 트랜잭션에 의한 충돌이 많지 않으면 성느이 매우 빠르다.

셋째, PK가 복합컬럼인 경우, 즉 구분 속송별 순번을 채변할 때도 사용할 수 ㅣㅆ다. 채번 테이블은 구분 속성 값의 수가 적을 때만 사용할 수 있지만, 이 방식은 값의 수가 아무리 많아도 상관없다.
오히려 값의 수가 많을수록 성능이 더 좋아진다. 입력 값 중복에 의한 로우 lock 경합이 줄고 재실행 횟수도 줄기 때문이다.

단점으로는 첫째, 레코드 중복에 대비한 세밀한 예외처리가 필요하다. 둘째, 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 나빠질 수 있다. 레코드 중복에 의한 로우 LOCK 경합 때문이다.

로우 LOCK은 선행 트랜잭션이 커밋 또는 롤백할 때까지 지속된다. 선행 트랜잭션이 롤백하지 않는 한, INSERT는 결국 실패하게 되므로 채번과 INSERT를 다시 실행해야 한다.

다행히 PK 가 복합컬럼이고 구분 속성별 값의 수가 많으면, 구분 속성 값별로 채번이 본산된다. 따라서 동시 채번이 만아도 로우 LOCK 경합 및 재실행 가능성은 현저히 줄어든다.

로우 LOCK 경합 이외의 성능 이슈는 MAX 값 조회에 최적화된 인데스를 구서애 주지 않을 때 생긴다.

LOCK 경합 오소를 고려한 채번 방식 선택 기준을 저이하면 다음과 같다.

1. 다중 트랜잭션에 의한 동시 채번이 많지 않으면, 세 가지 방식중 어느 것도 크게 상관업삳. 하지만, 채번 테이블이나 시퀀스 오브젝트 관리 부담을 고려한다면 가급적 max+1 방식이 ㅗㅎ다.

2. 다중 트랜잭션에 의한 동시 채번이 많고 PK 가 단일 컬럼 일련번호라면, 시퀀스 방식이 가장 좋다.

3. 다중 트랜재션에 의한 동시 채번이 맣고 PK 구분 속성에 값 종류 개수가 만흐면 중복에 의ㅏㄴ 로우 LOCK 겨압 및 재시랭 가능성이 낮다. 그러다면 시퀀스보다 MAX_1 방식이 구조저 으로 조다.

4. 다중 트랜잭션에 의ㅏㄴ 동시 채번이 만고 PK 구분 속성에 값 종류 개수가 적으면 수놘 옵션을 가진 시퀀스 오브젝트 활용으 고려할 수 있다.

### 12C 시퀀스 신기능

1. 컬럼 기본값으로 시퀀스 지정

```sql
create sequence my_seq;

create table t (
  c1 number default my_seq.nextval not null
  , c2 varchar2(5)_;
)
```

2. IDENTITY 컬럼

특정 컬름을 IDENTITY 컬럼으로 지정할 수 있다.

```sql
create table t (c1 number generated alwyas as identity, c2 varchar2(5));

insert into t(c2) value('X');
insert into t (c1,c2) value (default, 'X')
```

사용자가 직접 값을 입력할 수 도 있으려면 GENERATED BY DEFAULT 옵션을 지정하면 된다.

```sql
create table t (c1 number generated by default as identity, c2 varchar2(5));

```

3. 세션 시퀀스

글로벌 시퀀스는 여러 세션이 공유할수 있는 시스템 레벨 시퀀스이다.

```sql
create sequence g_deq GLOBAL;
```

세션 시퀀스는 여러 세션이 공유할 수 없는 세션 레벨 시퀀스로 아래와 같이 생성한다.

```sql
create sequence S_deq SESSION;
```

세션 시퀀스는 세션이 종료되면 초기화 된다. LOCK 메커니즘이 불필요하므로 당연히 글로벌 시퀀스보다 성능이 좋다. 그렇닥 세션 시퀀스가 깆ㄴ에 사용하던 시퀀스를 ㅁ두 대체할 수는 없다.

## 시퀀스보다 좋은 솔류션

한 개 이상의 구분 속성과 함께 뒤쪽에 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계하면 채변 또는 INSERT 과정에서 발생하는 LOCK 이슈를 거의 해소할 수 있다.

채번 과정을 생략하고 SYSDATE 또는 systimestamp 함수만 호출하면 되지 때문에 빠르고 간펺나다.

구분 속성에 값의 종류 개수가 많으면 입력일시에 DATE 타입을 써도 된다. 값의 종류 개수가 적으면 TIMESTAMP를 타입을 써 더 세밀한 구분값을 가지는 것이 좋다.

정보생명주기(ILM)을 효과적으로 관리하는데 있어 데이터 삭제는 매우 중요하다. 빠르게 삭제할수 있는 구조로 설계해야 한다.
뿐만아니라 삭제한 공간을 바로 시스템에 반납합으로써 새로 입력하는 데이터를 위해 재활용할 수 있어야한다.
서비스 중단 없이 파티션 단위로 커팅 하려면 기본적으로 PK 인덱스가 로컬 파티션이어야하고 PK 인덱스를 로컬 파티셔닝하려면 삭제 기준 컬럼(파티션키)가 PK에 포함돼 있어야 한다.
대게 삭제 기준은 입력일시 컬럼이다.

## 인덱스 블록 경합

INSERT 성능이 너무 빨라도 ㅁㄴ제다. 인덱스 경합이 발생한다.

인덱스 경합은 RIGT GROWIG 인데스에서 가장 흔하게 볼 ㅅ 있다. 인덱스에는 키순으로 정렬된 상태를 유지하며 값이 입력된다.
일련번호, 입력일시/변경일시 처럼 순차적으로 값이 ㅡㅇ가하는 단일 컬럼인ㄷ게스는 항상 맨 우측 블록에만 데이터가 입력된다. 이런 특성을 갖는 인덱스를 RIGHT GROWING 인덱스라고 부른다.

입력하는 값이 달라도 같은 블록을 갱신하려는 프로세스 간 버퍼 LOCK 경합이 발생할 수 있다.
이는 여러 프로세스에 의한 동시 iNSERT가 많을 때 트랜잭션 성능을 떨어뜨린다.
특히 RAC 환경에서 심각한 성능 저하를 일으킨다.

구분 속성을 앞에두면 right growing 인덱스는 아니다. 그래도 동시성이 매우 높으면 인덱스 블록 경합은 생길 수 있다. 구분 속성 값 종류 개수가 적을수록 경합도 심하다.

인덱스 블록 경합을 해소하는 가장 일바적이 방법으 인덱스를 해시 파티셔닝 하는 것이다. 인덱스를 해시 파티셔닝 하면 값이 순차적으로 증가하더라도 해시 함수가 리턴한 값에 따라 서로 다른 파티션에 입력되므로 경합을 주일 수 있따. 인덱스를 리버스키 인덱스로 전환하는 방법도 고려할 수 있다.

### 시퀀스 신기능 활용

```sql
create sequnece g_seq global;
create sequensce s_seq session;
```

글로벌 시퀀스는 데몬 프로세스 또는 커넥션 풀에 드옥된 프로세스가 dB에 접속하는 순간 아래와 같이 호출한다.

```sql
select g_seq.nextval from dual;
```

세션 시퀀스는 INSERT를 수행할 때마다 호출한다. 아래와 같이 글로벌 시퀀스 currval과 세션 시퀀스 nextvaldㅡㄹ 조합한 값으로 iNSERT 한다.

```sql
insert into t(id, c1, c2) values
(to_char(g_seq.currval, 'fm000')  || to_char(s_seq.nextval, 'fm0000'), 'A', 'B');

```

오라클 18c 버전에서는 'SCALABLE SEQUENCE' 를 이용할 수 있다.

시퀀스를 생성 할 때 아래와 같이 'SCALE' OR 'SCALE EXTEND' OPTION을 지정하면 된다.

nextval을 호출하면 아래와 같이 인스턴스 벊, 세션ID, 시퀀스번호를 조합한 번호를 반환한다.

EXTEND 옵션을 생략하면, 맨 우측 시퀀스 번호가 1,2,3 순으로 증가한다.

```sql
-- 하위 버전에서도 아래 값들을 조합하면 같은 기능을 구현할 수 있다.

select sys_context('userenv', 'instance')
, sys_context('userenv', 'sid')
, my_seq.nextval
from dual;
```
