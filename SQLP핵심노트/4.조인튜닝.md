# 조인튜닝

1. 주문, 고객, 결제방식 순으로 조인하되, 고객 테이블과는 NL 조인, 결제방식 테이블과는 해시조인 하도록 유도하는 힌트

```sql
-- 주문, 고객, 결제방식 순으로 조인
-- 주문, 고객 테이블은 NL 조인
-- 결제 방식과는 HASH JOIN

SELECT
/*+ ordered use_nl(c) use_hash(t) */
/*+ leading(o c t) use_nl(c) use_hash(t)*/
FROM 주문 o, 고객 c, 결제방식 t
where o.주문일자 >= trunc(sysdate)
and c.고객번호 = o.고객번호
and t.결제방식코드 = o.결제방식코드
```

FROM 절에 테이블을 나열한 순으로 조인하고자 할 때 ordered 힌트를 사용한다.
주문, 고객, 결제방식 순으로 조인하도록 leading 힌트 인자에 테이블 별칭을 명시해도 된다.
NL 조인으로 유도할 때 use_nl 힌트를 사용하며, 해시 조인으로 유도할 때 use_hash 힌트를 사용한다.

2. sql server에서 NL 조인 유도

```sql
-- 주문 테이블을 기준으로 고객 테이블과 NL 조인하도록 유도
select o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액
from 주문 o, 고객 c
where o.주문일자 >= trunc(sysdate)
and c.고객번호 = o.고객번호
option (force order, loop join)
```

FROM 절에 테이블을 나열한 순으로 조인하고자 할 때 force order 힌트를 사용한다.
NL 조인으로 유도할 때 loop join 힌트를 사용한다.

3. SQL 서버에서 주문,고객,결제방식 순으로 조인하되, 고객 테이블과는 NL 조인, 결제방식과는 해시 조인하도록 쿼리 재작성 후 힌트 기술

```sql
-- as-is
select o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액, t.결제방식명
from 주문 o, 고객 c, 결제방식 t
where o.주문일자 >= trunc(sysdate)
and c.고객번호 = o.고객번호
and t.결제방식코드 = o.결제방식코드

-- 주문 테이블을 기준으로 고객 테이블과 NL 조인하도록 유도
-- to-be
select  o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액, t.결제방식명
from 주문 o
      inner loop join 고객 c on (c.고객번호 = o.고객번호)
      inner hash join 결제방식 t on(t.결제방식코드 = o.결제방식코드)
where o.주문일자 >= trunc(sysdate)
and c.고객번호 = o.고객번호
and t.결제방식코드 = o.결제방식코드
option (force order)
```

FROM 절에 테이블을 나열한 순으로 조인하고자 할 때 force order 힌트를 사용한다.
NL 조인을 유도할때 'inner join table on (join condition)' 구문을 사용하며,
해시 조인으로 유도할 때 'inner hash join tableN on (join condition)' 구문을 사용한다.

4. 조인 조건에 따른 조건절 비교 순서

```sql
-- 사원_pk : 사원번호
-- 사원_x1 : 입사일자
-- 고객_pk : 고객번호
-- 고객_x1 : 관리사원번호

select
/*+ordered use_nl(c) index(e) index(c)*/
*
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 -- 가
and e.입사일자 >= '19960101' -- 나
and e.부서코드 = 'Z123' -- 다
and c.최종주문금액 >= 20000 -- 라

```

- 나 - 다 - 가 - 라

사원을 기준으로 고객과 NL 조인한다.
INDEX(E) 힌트를 지정했으므로 인덱스를 통해 엑세스한다. 어떤 인덱스를 사용할지는 옵티마이저가 선택한다.

조건절에 있는 입사일자는 인덱스가 있고 부서코드는 인덱스가 없으므로 사원\_x1 인덱스를 스캔해 얻은 ROWID로 테이블을 엑세스한 후 부서코드를 필터링 한다.

INDEX(C)힌트를 지정했으므로 고객 테이블도 인덱스를 통해 액세스한다. 어떤 인덱스를 사용할지는 옵티마이저가 선택한다.

관리사원번호 조인 조건으로 스캔해 얻은 ROWID로 테이블 액세스한 후 최종주문금액 조건을 필터링 한다.

고객 테이블 최종주문금액에 인덱스가 있다면 최종주문금액으로 먼저 스캔하고 관리사원번호로 스캔하거나 관리사원번호로 스캔하고 최종주문금액으로 스캔할 수도 있다
어느 쪽이 유리한지는 관리사원번호 조건과 최종주문금액 조건의 데이터 분포에 따라 결정된다.

5. 옵티마이저의 인덱스 선택 전략

아래와 같이 힌트를 통해 인덱스명이나 컬럼명을 지정하지 않은 상태에서
옵티마이저가 선택할 가능성이 적은 인덱스 조합을 고르시오.

```sql
-- 사원_pk : 사원번호
-- 사원_x1 : 입사일자
-- 사원_x2 : 부서코드
-- 고객_pk : 고객번호
-- 고객_x1 : 관리사원번호
-- 고객_x2 : 최종주문금액

select
/*+ordered use_nl(c) index(e) index(c)*/
*
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호 -- 가
and e.입사일자 >= '19960101' -- 나
and e.부서코드 = 'Z123' -- 다
and c.최종주문금액 >= 20000 -- 라

```

- 사원\_PK, 고객\_x1

---

사원을 기준으로 고객과 NL조인한다.
각테이블에 존재하는 조건절이 모두 인덱스에 있으므로 사원\_PK 를 제외한 모든 인덱스를 스캔을 위해 사용할 수 있다.

- 나 > 다 > 가 > 라 : 사원\_x1, 고객\_x1
- 나 > 다 > 라 > 가 : 사원\_x1, 고객\_x2
- 다 > 나 > 가 > 라 : 사원\_x2, 고객\_x1
- 다 > 나 > 라 > 가 : 사원\_x1, 고객\_x2

6. NL조인의 특징

a. 랜덤 엑세스 위주의 조인방식이다.
b. 조인할 대상 레코드가 많아도 ArraySize에 해당하는 최초 N 건을 빠르게 출력할 수 있다.
c. 인덱스 유무, 인덱스 구성에 의해 성능이 달라진다.
d. 부분범위처리가 가능한 상황에서만 효과적인 조인 방식이다.
=> 부분범위 처리가 효과적인 상황에서는 NL 조인이 가장 유리하다. 그러나 부분범위 처리가 불가능한 상황이더라도 소량의 데이터를 조인할 때는 NL 조인이 가장 유리하다.

---

NL 조인의 첫 번째 특징은 랜덤 액세스 위주의 조인 방식이라는 점이다.
인덱스 구성이 아무리 완벽해도 대량 데이터 조인시 불리한 이유이다.

두 번째 특징은 조인을 한 레코드씩 순차적으로 진행한다는 점이다. 따라서 부분범위 처리가 가능하다면 조인할 대상 레코드가 아무리 많아도 빠른 응답 속도를 낼 수 있다.

순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 있다.

마지막으로, 다른 조인 방식과 비교할때 인덱스 구성 전략이 중요하다는 점도 중요한 특징이다.

이런 특징을 종합할 때, NL 조인은 소량의 데이터를 주로 처리하거나 부분범위 처리가 가능한 OLTP 시스템에 적합하다.

7. SQL 튜닝방안

```sql
-- 한 달 간 거래 건수는 평균 20만 건

-- AS-IS

SELECT p.상품코드, P.상품가격, t.거래일자, T.거래수량, t.거래금약
FROM 상품 p, 거래 t
WHERE P.상품분류코드 = 'KTG'
AND P.상품가격 between 100000 and 20000
AND T.상품코드 = P.상품코드
AND T.거래일자 BETWEEN '20210101' AND '20210131'

--- execution plan
-- 368 NESTED LOOPS
-- 68  TABLE ACCESS BY INDEX ROWID 상품
-- 9185    INDEX RANGE SCAN 상품_X01
-- 368  TABLE ACCESS BY INDEX ROWID 거래
-- 385    INDEX RANGE SCAN 거래_X01
```

- c. 상품\_x01에 인덱스 컬럼을 추가한다.

---

한 달간 주문 건수는 평균 20만건 이므로 컬럼 수가 많은 거래를 먼저 드라이빙하는 것은 성능 향상에 도움이 되지 않는다.

인덱스 정보가 제공되지않지만 데이터 스캔건수와 테이블 엑세스를 통해 얻은 로우 건수를 통해 추론해볼수 있다.

상품 테이블의 인덱스에서 9185건을 스캔해서 68건의 로우를 얻었기 때문에 상품 테이블의 인덱스에 특정 조건에서 사용된 컬럼이 포함되지 않음을 알 수 있다.

결국, 상품 테이블에서 읽어오는 테이블 로우에 비해 랜덤 엑세스가 많이 발생하는 것이 문제다.

테이블 엑세스량은 컬럼 순서를 조정해도 줄지 않으므로 테이블에 필터링된 조건절 컬럼을 상품 인덱스에 추가해주는 것 많이 해법이다.

거래 인덱스를 스캔한 후에 테이블에서 필터링된 데이터는 17건에 불과하므로 컬럼을 추가해서 얻을 수 있는 성능개선은 미미하다.

8. 인덱스 튜닝방안

```sql
-- 테이블 : 상품, 거래
-- 상품_PK : 상품코드
-- 상품_X01 : 상품분류코드 + 상품가격 + 공급업체코드
-- 거래_PK  : 거래번호
-- 거래_X01 : 거래일자 + 상품코드
-- 거래_X02 : 상품코드 + 거래구분코드 + 거래일자

SELECT P.상품코드 , P.상품가격, T.거래일자, T.거래수량, T.거래금액
FROM 상품 P, 거래 T
WHERE P.상품분류코드 = 'KTG'
AND P.공급업체코드 = 'SP8732'
AND P.상품가격 BETWEEN  10000 AND 1000000
AND T.상품코드 = P.상품코드
AND T.거래일자 BETWEEN '20210101' AND '20210131'
-- 368 NESTED LOOP (CR=1311 PR=124)
-- 69   TABLE ACCESS BY INDEX ROWID 상품(cr=986 pr=35)
-- 69     INDEX RANGE SCAN 상품_X01 (CR=922 PR = 31)
-- 368  TABLE ACCESS BY INDEX ROWID 거래(cr=325 pr=89)
-- 385    INDEX RANGE SCAN 거래_X02 (CR=140 PR = 21)
```

a. 상품\_x01 인덱스의 컬럼 순서를 조정한다.

---

조건에 대한 상품\_X01 인덱스의 스캔 효율이 매우 좋지 않다. 69개의 로우를 읽기 위해 922개의 블록을 읽었기 때문이다.

한 블록에 평균 1000개 로우가 저장돼 있다면, 922,000개 가량의 로우를 읽은 셈이다. 상품가격을 인덱스 맨 뒤로 옮기면 문제를 해결할 수있다.

상품 테이블을 액세스하는 과정에 필터링되는 데이터가 없으므로 상품\_X01 인덱스에 컬럼 추가는 불필요하다.

거래 테이블을 액세스하는 과정에 필터링되는 데이터가 거의 없으므로 거래\_X02 인덱스에 컬럼 추가는 불필요하다.

거래\_X02 인덱스에서 385 개의 로우를 얻는 과정에 140개의 블록을 읽었다.
하지만 조인과정에서 인덱스 수직적 탐색에 69번 일어났다는 사실을 고려하면 그렇게 많지 않다 않다.

수직 탐색 과정에서 2블록씩만 읽어도 138개의 블록이 된다.

거래일자가 필터 조건이라 스캔 효율이 안 좋을 수 있는 구성임에도 I/O가 많이 발생하지 않은 것을 보면, 조건을 만족하는 거래량이 많지 않음을 알 수 있다.

그런 상품을 조회하는데 거래일자를 선두로 갖는 거래\_X01 인덱스를 사용하면 거래량이 많은 다른 상품이 포함된 한 달치 거래를 모드 스캔해야하므로 오히려 성능이 나빠질 수 있다.

9. 인덱스 튜닝

```sql
-- 테이블 : 상품, 거래
-- 상품_PK : 상품코드
-- 상품_X01 : 공급업체코드 + 상품가격
-- 거래_PK  : 거래번호
-- 거래_X01 : 거래일자 + 상품코드
-- 거래_X02 : 상품코드 + 거래일자

SELECT P.상품코드 P.상품가격, T.거래일자, T.거래수량, T.거래금액
FROM 상품 P, 거래 T
AND P.공급업체코드 = 'SP8732'
AND P.상품가격 BETWEEN  100000 AND 2000000
AND T.상품코드 = P.상품코드
AND T.거래일자 BETWEEN '20210101' AND '20210131'

-- 368 NESTED LOOPS
-- 69   TABLE ACCESS BY INDEX ROWID 상품(cr=42 pr=0)
-- 69     INDEX RANGE SCAN 상품_X01 (CR=2 PR=0)
-- 368  TABLE ACCESS BY INDEX ROWID 거래(cr=25625 pr=3548)
-- 368    INDEX RANGE SCAN 거래_X02 (CR=25257 PR = 3421)
```

a. 상품\_X01 인덱스의 컬럼 순서를 조정한다.

=> 상품 인덱스에서 69 로우를 읽는데 2개의 블록을 읽었으므로 인덱스 스캔 효율에는 문제가 없다. 따라서 상품\_X01 컬럼 순서 조절은 불필요하다.

b.상품\_x01 인덱스에 컬럼 추가를 검토한다.
=> 상품 테이블을 액세스하는 과정에 필터링 되는 데이터가 없으므로 상품\_X01 인덱스 컬럼 추가는 불필요하다.

c. 거래\_X01 대신 거래\_X02 인덱스 사용을 검토한다.
=> 거래\_X01 인덱스에서 368 로우를 얻는 과정에 25,257 개의 블록을 읽었다.
조인 과정에서 인덱스를 69번 수직적 탐색 한것에 비해 많은 수의 블록을 읽었다.
이를 통해 인덱스 스캔 효율이 좋지 않다는 것을 알 수 있다.
거래\_X01 인덱스 선두 컬림인 거래일자가 BETWEEN 조건이므로 공급업체코드 조건을 만족하는 상품마다 한달치 거래를 모두 스캔하면서 상품코드를 필터랑 하는 것이 문제다.
거래\_X02로 인덱스를 변경해주면 상당한 성능 개선효과를 얻을 수 있다.

d.해시조인으로 유도하는 것을 검토한다.

=> 인덱스 구성을 보면 해시 조인도 I/O를 줄이는데 상당한 도윰을 줄 수 있을 것으로 보인다.
하지만 NL조인을 우선 검토한 후에 성능 개선 방안을 찾긱 어려울 때 해시 조인을 검토하는껏이 올바른 순서다.

10. 튜닝방안

```sql
-- 상품_PK : 상품코드
-- 상품_x01 : 상품분류코드 + 상품가격
-- 거래_pk : 거래번호
-- 거래_X01 : 상품코드 + 거래일자
-- 거래_x02 : 거래일자

-- 한 달간 거래는 평균 10만 건

select p.상품코드, p.상품가격, t.거래일자, t.거래수량, t.거래금액
from 상품 P, 거래 T
where p.상품분류코드 = 'KTG'
AND P.상품가격 BETWEEN  10000 AND 100000
AND T.상품코드 = P.상품코드
AND T.거래일자 BETWEEN '20210101' AND '20210131'

--- EXECUTION PLAN

-- 368 NESTED LOOPS (CR = 171325 PR = 54250)
-- 35372 TABLE ACCESS BY INDEX ROWID 상품 (cr = 15202 pr = 735)
-- 35372   INDEX RANGE SCAN 상품_x01 (cr = 79 pr = 3)
-- 64368 TABLE ACCESS BY INDEX ROWID 거래 (cr = 156123 pr = 53515)
-- 64368   INDEX RANGE SCAN 거래_x01 (cr = 105818 pr = 3953)
```

a. 상품\_x01 컬럼를 순서 조정한다.
=> 35372 로우를 얻기 위해 인덱스에서 70 개의 블록을 읽었기 때문에 상품\_x01 인덱스 스캔 효율에 비효율은 없다. 따라서 컬럼 순서 조정은 불필요하다.

b. 상품\_X01 인덱스에 컬럼을 추가한다.
=> 상품 테이블을 액세스하는 과정에서 필터링되는 데이터가 없으므로 상품\_x01 인덱스 컬럼 추가는 불필요하다.

c. 조인순서변경를 변경한다.

거래쪽으로 35372번 조인하는 과정에 거래\_x02 인덱스에서 105818 개의 블록을 읽었다.

조인과정에서 발생하는 i/O가 전체 I/O의 90% 를 차지하므로 조인 순서 변경을 검토해 볼 수 있다.

하지만 한달 평균 거래가 평균 10만건 이므로 I/O 가 더 증가할 것이다.

d. 해쉬조인으로 변경

인덱스가 모두 최적인 상황에서 조인 순서를 변경해도 좋은 성능을 기대하기 어렵다면 다른 조인 메서드를 고려해야 한다.

해시 조인으로 유도하면 거래 테이블은 거래\_X02 인덱스를 통해 엑세스하게 된다.

이 인덱스의 클러스터링 팩터가 성능을 좌우해겠지만, 최악의 경우를 가정해도 지금보다 i/o가 줄어든다

11. 주어진 SQL을 위한 PRA_HST_STC 테이블의 최적인덱스

```sql

--sql 1

SELECT  /*+ORDERED USE_NL(B)*/ *
FROM  PRA_HST_SCT A, ODM_TRMS B
WHERE A.SALE_ORG_ID = :SALE_ORG_ID
AND A.STRD_GRP_ID = B.STRD_GRP_ID
AND A.STRD_ID = B.STRD_ID
ORDER BY A.STC_DT

-- SQL 2
SELECT  /*+ORDERED USE_NL(B)*/ *
FROM  PRA_HST_SCT A, ODM_TRMS B
WHERE  A.USER_ID = :USER_ID
AND A.SALE_ORG_ID = :SALE_ORG_ID
AND A.STRD_GRP_ID = B.STRD_GRP_ID
AND A.STRD_ID = B.STRD_ID
ORDER BY  A.STC_DT

```

SALE_ORG_ID + USER_ID + STC_DT

NL 조인으로 처리할 때 조인컬럼은 check 테이블의 인덱스에는 반드시 필요하지만
DRIVING 테이블의 인덱스에는 불필요하다.

따라서 조인조건에 사용된 컬럼이 포함된 인덱스는 최적인덱스가 아니다.

SQL 1 을 위해선 SALE_ORG_ID 가 필요하고 SQL2를 위해선 SALE_ORG_ID, USER_ID가 필요하므로 인덱스를 각각 생성하기 보다는 SALE_ORG_ID + USER_ID 로 구성된 인덱스만 하나 생성하면 된다.

인덱스에 ORDER BY 컬럼은 STC_DT를 추가하는 것은 부분범위 처리가 가능한 상황이라는 전제가 필요하다.

부분범위 처리가 불가능하다거나 그다지 효과를 볼 수 없느 상황이라면 저장공간과 DML 성능명에서 비효율 적이다.

만약 부분범위 처리가 가능한 상황이라면, 아래와 같은 설계안을 고려할 수 있다.

SALE_ORG_ID + STC_DT
USER_ID + SALE_ORG_ID

SALE_ORG_ID 가 변별력이 좋지않고(특정 조건에 해당하는 데이터가 많고)
STC_DT 가 변별력이 좋다고 가정할때, SQL1 에서 SALE_ORG_ID 조건을 만족하는 데이터가 많으면 STC_DT 컬럼을 통한 소트연산을 생략해서 상당한 성능 효과를 얻을 수 있다.

SQL 2에서 USER_ID 와 SALE_ORG_ID 조건을 만족하는 데이터가 적다면 소트 연산을 생략해서 얻을 수 있는 성능 효과가 미미하므로 STC_DT가 인덱스에 포함될 필요가 없다.

두 SQL을 위해 인덱스를 하나만 생성해야 한다면 아래와 같다.

SALE_ORG_ID + STC_DT + USER_ID

다만, SQL2에서 USER_ID를 필터링하면서 생기는 스캔 비효율은 감수해야한다.

12. 인덱스 튜닝

```SQL
SELECT *
FROM (
  SELECT A.*, B.TRMS_DT, B.TRMS_DESC
  FROM PRA_HST_STC A, ODM_TRNS B
  WHERE A.SALE_ORG_ID = :SALE_ORG_ID
  AND B.STRD_GRP_ID = A.STRD_GRP_ID
  AND B.STRD_ID = A.STRD_ID
  AND B.TRMS_DT BETWEEN :TRMS_DT1 AND :TRMS_DT2
  ORDER BY A.STC_DT DESC
)
WHERE ROWNUM <= 10

```

PRA_HST_STC_X1 : SALE_ORG_ID + STC_DT
TRMS_DESC_X1 : STRD_GRP_ID + STRD_ID + TRMS_DT

이 문제의 핵심은 STC_DT 역순으로 정렬한 결과집합 중 상위 10개만 아주 빠르게 출력할 수 있도록 인덱스를 구성하는데 있다.

이를 위해서는 부분범위 처리가 가능하도록(소트 생략 가능하도록), 그리고 nL 방식 조인에 최적화 되도록 인덱스를 구성해야 한다.

소트 연산을 생략하려면 드라이빙 테이블인 PRA_HST_STR의 인덱스를
SALE_ORG_ID + STC_DT 로 구성해야한다.

NL조인을 효과적으로 처리하려면 INNER TABLE인 ODM_TRMS의 인덱스를
STRD_GRP_ID + STRD_ID + TRMS_DT 로 구성해야한다.

13. 인덱스 튜닝

```sql
-- ODM_TRMS_X1 : STRD_GRP_ID + TRMS_DT + STRD_ID
-- ODM_TRMS_X2 : STRD_ID + STRD_GRP_ID + TRMS_DT
-- ODM_TRMS_X3 : STRD_GRP_ID + STRD_ID + TRMS_DT

  SELECT /*+ORDERED USE_NL(B)*/
  *
  FROM PRA_HST_STC A, ODM_TRMS B
  WHERE A.SALE_ORG_ID = :SALE_ORG_ID
  AND B.STRD_ID = A.STRD_ID -- 조인조건
  AND B.STRD_GRD_ID = :STRD_GRD_ID
  AND B.TRMS_DT BETWEEN :TRMS_DT1 AND :TRMS_DT2 -- 일반조건
  ORDER BY A.STC_DT DESC
```

a. 상수 또는 변수 조건을 앞에 두는것이 유리하므로 ODM_TRMS_X1 인덱스가 가장 효과적이다.

b. 조인 조건을 앞에 두는 것이 유리하므로 다른 인덱스보다 ODM_TRMS_X2가 효과적이다.

c. ODM_TRMS_X2, ODM_TRMS_X3 인덱스가 최적이며, 둘 간 성능 차이는 없다.
=> INNER TABLE인 ODM_TRMS를 액세스하는 시점에 STRD_ID와 STRD_GRP_ID 모두
'=' 조건이므로 둘 중 어느것이 앞에와도 인덱스 액세스 효율에는 차이가 없다.

d. 세 인덱스 모두 최적이다.

---

조인 컬럼을 인덱스 앞쪽에 두는게 유리하다고 생각하기 쉽지만,
= 조건이 아닐때 데이터 분포에 따라 유불리가 결정된다.
= 인 조인 조건보다 부둥호인 일반 조건절의 변별력이 좋다면, 일반 조건절을 조인 조건절 앞쪽에 두는게 유리할 수도 있다.

14. BATCH, PREFETCH

```sql
select /*+ ordered use_nl(t) index(p) index(t) */
p.상품코드 , p.상품가격, t.거래일자, t.거래수량,t
from 상품 p, 거래 t
where p.공급업체코드 = 'SP245794'
and T.상품코드 = P.상품코드
and T.거래일자 between '20210101' and '20210131'


--- Execution plan
-- 정동적인 방식의 nl 조인 실행계획
-- select statement
--  nested loop
--    table access by index rowid of 상품
--      index range scan of 상품_x01
--    table access by index rowid of 거래
--      index range scan of 거래_x01
```

테이블 PREFETCH는 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능이다.

INNER 쪽 테이블 액세스가 NESTED LOOPS 위쪽에 위치한다.

이는 INNER 쪽 테이블에 대한 디스크 i.o 과정에서 PREFETCH 기능이 작동할 수 있음을 표시하기 위함이다. 9i 버전 부터 나타나기 시작했다.

```sql
-- select statement
-- table access by index rowid of 거래
--  nested loop
---    table access by index rowid of 상품
--      index range scan of 상품_x01
--     index range scan of 거래_x01
```

배치I/O는 디스크 I/O CALL을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.

INNER TABLE ACCESS가 INNER 쪽 인덱스 스캔 아래'쪽에 위치한다.

이는 INNER 쪽 테이블에 대한 디스크 i.O 과정에서 배치 i/o기능이 작동할 수 있음을 표시하기 위함이다.

```sql
--  select statement
--    nested loop
--      nested loop
--        table access by index rowid of 상품
--          index range scan of 상품_x01
--        index range scan of 거래_x01
--      table access by index rowid of 거래
```

15. 인덱스 튜닝

```sql
SELECT ...
, (
  SELECT
  CASE
      WHEN A.일할계산여부 = 'Y'
      THEN NVL(A.총청구건수, 0) - NVL(A.청구횟수 , 0)
      ELSE B.할부개월수 - NLV(A.청구횟수, 0) END
  FROM 서비스별할부 A, 할부계획 B
  WHERE A.서비스계약번호 = MV.서비스계약번호
  AND A.할부상태코드 = 'XR'
  AND B.할부계획ID(+) = A.할부계획ID
  AND ROWNUM <= 1) AS 청구횟수...
FROM (...) MV
WHERE ...

--- execution plan
--                                            STARTS  A-ROWS  BUFFERS
-- COUNT STOPKEY                               37243   28953    293k
--  NESTED LOOP OUTER                         37243   28953    293K
--    TABLE ACCESS BY INDEX ROWID 서비스별할부    37243  28953    177k
--      INDEX RANGE SCAN 서비스별할부_X1         37243   28953    149k
--    TABLE ACCESS BY INDEX ROWID 할부계획      28953   28953    115k
--      INDEX RANGE SCAN 할부계획_PK            28953   28953    86860
```

메인쿼리 집합 mv 건수 만큼 스칼라 서브쿼리를 37243 번 수행했다.

서비스별할부를 먼저 엑세스 해서 얻은 28953 로우만큼 할부 계획과 조인했고, 그 과정에서 11만 5천 개 블록을 읽었다.

할부계획과 조인하는 이유는 할부개월 수 값을 읽기 위함인데 할부개월 수는 일할계산여부가 y가 아닐때만 필요하다.(b 테이블의 컬럼을 참조하고 있지 않음)

따라서 할부계획은 서비스별할부의 일할계산여부가 y가 아닐 때만 조인하도록 조치하는 것이 좋다.

문제점 : 할부계획의 할부개월수는 서비스별할부의 일할계산여부가 y가 아닐때만 필요한데 일할 계싼여부가 y일때도 조인을 수행하고 있다.

튜닝 방안 : 서비스별할부의 일할계산여부가 y가 아닐 때만 조인하도록 수정해 조인 일량을 최소화한다.

```sql
SELECT
  ,(
    SELECT CASE WHEN A.일할계산여부 = 'Y'
                THEN NVL(A.총청구건수, 0) - NVL(A.청구횟수 , 0)
                ELSE B.할부개월수 - NLV(A.청구횟수, 0) END
    FROM 서비스별할부 A, 할부계획 B
    WHERE A.서비스계약번호 = MV.서비스계약번호
    AND A.할부상태코드 = 'XR'
    AND B.할부계획ID(+) = (CASE WHEN A.일할계산여부 = 'Y'
                         THEN NULL
                        ELSE A.할부계획ID END)
    AND ROWNUM <= 1) AS 청구횟수


  )
FROM ... MV
WHERE ...
```

# 소트머지조인

16. 소트머지조인을 유도하는 Oracle 힌트

```sql
select /*+leading(o) use_merge(c)*/
o.주문번호, O.고객번호, c.고객명, c.전화번호, O.주문금액
from 주문 O, 고객 C
where O.주문일자 >= TRUNC(SYSDATE)
AND C.고객번호 = O.고객번호
```

17. 소트머지조인을 유도하는 SQL SERVER 힌트

```sql
select
o.주문번호, O.고객번호, c.고객명, c.전화번호, O.주문금액
from 주문 O, 고객 C
where O.주문일자 >= TRUNC(SYSDATE)
AND C.고객번호 = O.고객번호
OPTION(FORCE ORDER, MERGE JOIN)
```

18. 특정 실행계획을 유도하는 오라클 힌트

```sql
select  /*+LEADING(D) USE_MERGE(E)*/
d.deptno, d.dname, e.empno, e.ename
from emp e, dept d
where d.deptno = e.deptno

-- SELECT STATEMENT
--   MERGE JOIN
--    SORT JOIN
--      TABLE ACCESS FULL DEPT
--    SORT JOIN
--      TABLE ACESS FULL EMP
```

조인 순서를 조정하는 힌트로는 'ordered' 와 'Leading' 두 가지가 있다.
DEPT 테이블을 먼저 읽어 emp 테이블로 조인하는 실행계획이므로 ordered를 사용하려면 FROM 절을 수정해야 한다.

FROM 절의 테이블 순서 변경없이 힌트로만 조인 순서를 조정하려면 LEADING 힌트를 사용하면 된다.

소트머지 조인으로 유도할때는 'use_merge' 힌트를 사용한다.

19. 소트머지 조인의 특징

a. 랜덤 액세스가 아닌 스캔 위주의 조인 방식이다.
b. 양쪽 집합을 개별적으로 읽어 정렬하므로 조인 컬럼에 인덱스가 없어도 상관없다.
c. 양쪽 테이블 모두 조인 컬럼에 인덱스가 있으면 따로 정렬을 수행하지 않아도 된다.
=> 두 번째 집합은 반드시 정렬해서 PGA에 저장한 후에 조인을 시작한다.
첫 번째 집합도 일반적으로는 PGA에 저장하지만,조인 컬럼에 인덱스가 있어서 그것을 사용한다면 PGA에 저장하지 않고 조인한다.
하지만 두 번째 집한은 인덱스 여부에 관련없이 반드시 저장한다.
d. 두 테이블을 각각 읽어 조인 대상집합을 줄일 수 있을 때 매우 효과적이다.

---

소트머지조인은 조인을 위해 실시간으로 인덱스를 생성하는 것이나 다름이 없다.

양쪽 집합을 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다.

따라서 소트 부하만 감수한다면, 건건이 버퍼 캐시를 경유하는 NL 조인보다 빠르다.

NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만 소트 머지 조인은 영향을 받지 않는다.

양쪽 집합을 개별적으로 읽고 나서 조인을 시작한다는 특징도 있다.

따라서 조인 컬럼에 인덱스가 없는 상황에서는 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을때 유리하다.

스캔 위주의 액세스 방식을 사용한다는 점도 중요하다. 하지만 모든 처리가 스캔 방식으로 이루어지진 않는다.

양쪽 소스 집합으로부터 조인 대상 레코드를 찾을 때 인덱스를 이용한다면 랜덤 액세스가 일어난다.

소트 머지 조인도 조인 프로세싱 자체는 NL 조인과 같다.

소트머지 조인이 빠른이유는 첫 번째 집합을 기준으로 두 번째 집합을 반복 액세스할때 버퍼캐시를 탐색하지 않고 PGA에서 읽기 때문이다.

따라서 두 번째 집합은 반드시 정렬해서 PGA에 저장한 후에 조인을 시작한다.

첫 번째 집합도 일반적으로는 PGA에 저장하지만,

조인 컬럼에 인덱스가 있어서 그것을 사용한다면 PGA에 저장하지 않고 조인한다.

하지만 두 번째 집한은 인덱스 여부에 관련없이 반드시 저장한다.

20. 대량 데이터를 조인할때 소트머지조인이 NL 조인보다 빠른이유.

a. NL 조인보다 더 빠른 조인 알고리즘을 사용하기 때문이다.
b. 데이터를 PGA 영역에 읽어들인 후 조인하기 때문이다.
=>
소트 머지 조인은 양쪽 테이블로 부터 조인 대상집합을 일괄적으로 읽어 PGA 또는 TEMP 테이블 스페이스에 저장한 후 조인한다. PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다. 이에 소트머지 조인이 대량 데이터 조인에 유리하다.

c. 조인 대상 집합을 버퍼 케시에서 읽을 때 래치를 획득하기 때문이다.
d. Temp 테이블스페이스를 활용하기 때문이다.

---

소트 머지 조인은 SORT AREA에 미리 정렬해 둔 자료구조를 이용한다는 점만 다를뿐 프로세싱 자체는 nl 조인과 같다.

성능차이는 다음과 같은 부분에서 나타난다.

nL 조인은 인덱스를 이용한 조인 방식이다. 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 '건건이' DB 버퍼캐시를 경유해서 읽는다.

인덱스든, 테이블이든 읽는 모든 블록에 래치 확득 및 캐시버퍼 체인스캔 과정을 거친다.
버퍼캐시에서 찾지 못하는 블록은 건건이 디스크에서 읽어 들인다.

소트 머지 조인은 양쪽 테이블로 부터 조인 대상집합을 일괄적으로 읽어 PGA 또는 TEMP 테이블 스페이스에 저장한 후 조인한다.

PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다.

이에 소트머지 조인 이 대량 데이터 조인에 유리하다.

21. 해시조인과 비교할때 소트머지조인의 장점

a. 메모리를 적게 사용한다.
=> 해시 조인은 둘 중 작은 쪽 집합만 읽어 PGA에 해시 맵으로 저장하는 반면, 소트머지 조인은 양쪽 집합을 정렬해 PGA에 저장하므로 더 많은 메모리를 사용한다.

b. Temp 테이블스페이스를 적게 사용한다.
=> Temp 테이블스페이스의 사용량도 소트머지조인이 더 많다.
두 테이블 중 하나만 대용량일 때 해시 조인은 TEMP 테이블스페이스를 전혀 사용하지 않지만 소트머지 조인은 사용한다.
양쪽 집합이 모두 대용량일 때 소트머지조인과 해시조인 둘다 TEMP 테이블 스페이스에 저장한다.

c. 조인 조건이 = 가 아니어도 된다.
=> 해시 조인과 비교한 소트머지조인의 가장 큰 장점은 조인 조건이 =이 아닐때 심지어 조인조건이 없어도 사용할 수 있다는 점이다.

d. 양쪽 집합이 모두 대용량일 때 해시 조인보다 빠르다.
=> 한쪽 테이블이 매우 작을때 해시조인이 가장 극적인 성능을 내지만 둘 다 큰 테이블일 때도 일반적으로 해시조인이 빠르다.

# 해시조인

22. 해시조인의 과정

1. 작은 테이블을 읽는다.
1. 해시맵을 만든다
1. 큰 테이블을 읽는다
1. 해시 맵을 탐색한다.
1. 조인에 성공한 데이터를 전송한다.

해시 조인은 크게 두 단계로 진행한다.

\- 해시맵 생성(BUILD PHASE) : 작은 테이블을 읽어 해시맵을 생성한다.

\- 해시 맵 탐색(PROBE PHASE) : 큰 테이블을 스캔하면서 해시 맵을 탐색한다. 조인에 성곤한 데이터는 클라이언트에 전송한다.

23. 해시조인을 유도하는 오라클 힌트

```sql
select
/*+leading(d) use_hash(e)*/
/*+ordered use_hash(e d) swap_join_inputs(d)*/
/*+use_hash(e d) swap_join_inputs(d)*/
*
from emp e, dept d
where d.deptno = e.deptno
-- execution plan

-- select statement
--  hash join
--    table access full dept
--    table access full emp
```

HASH JOIN 오퍼레이션 바로 아래쪽 테이블이 BUILD 인풋이다.

BUILD INPUT을 명시적으로 선택하는 힌트가 swap_join_inputs 이지만, leading 또는 ordered에 의해 선택된 첫번째 테이블은 무조건 build input이다.

따라서 두 테이블을 조인할 때는 굳이 swap_join_inputs 힌트를 쓰지 않고도 실행계획을 쉽게 제어할 수 있다.

swap_join_inputs(d) 힌트를 명시하지 않으면 ordered use_hash(e)는 ordered 힌트에 의해 DEPT 테이블이 BUILD INPUT으로 선택된다.

24. SQL_SERVER에서 해시조인을 유도하는 힌트

```SQL
-- 주문테이블을 기준으로 고객 테이블과 해시 조인 유도
SELECT
FROM 주문 O
-- INNER HASH JOIN 으로도 가능하다.
INNER JOIN 고객 c on (o.고객번호 = c.고객번호)
WHERE O.주문일자 >= TRUNC(SYSDATE)
OPTION (FORCE ORDER)
```

25. 해시조인에 대한 설명으로 부적절한 것

a. 조인 컬럼에 인덱스가 없어도 성능에 미치는 영향은 없다.
b. 조인 조건 중 하나 이상이 = 조건일 때만 사용할 수 있다.
c. 조인하는 양쪽 집합 중 어느 한쪽이 다른 한쪽에 비해 현저히 적을 때 효과적이다.
d. 조인하는 양쪽 집합이 모두 대량 데이터일 때는 NL 조인이 유리하다. 단, 인덱스를 최적으로 구성해야한다.
=> 양쪽 모두 PGA 공간을 초과하더라도 대량 데이터를 조회할 때는 해시 조인이 빠르다.

---

조인 컬럼에 인덱스가 없어도 조인 조건 중 하나 이상이 = 조건일 때만 사용할 수 있다.

조인하는 양쪽 집합 중 어느 한쪽이 다른 한쪽에 비해 현저히 작을 때 효과적인 조인 방식이다.

해시조인은 조인 프로세싱 자체는 NL 조인과 같지만, 건건이 INNER 집합을 버퍼케시에서 탐색하지 않고 PGA에 미리 생성 해둔 해시 테이블을 탐색하면서 조인한다는 점이 다르다.

해시 맵을 이용하므로 조인 컬럼에 인덱스가 없어도 상관 없다.

해시 맵을 PGA에 생성해야하므로 둘 중 어느 한쪽이 PGA 담을 수 있을 정도록 충분히 작을 때 효과적인다.

해시 조인은 해시 알고리즘 튻성상, 조인 조건 중 하나 이상이 = 조건일 때만 사용할 수 있다.

26. 조인하는 양쪽 집합 중 어느 한쪽이 다른 한쪽에 비해 현저히 작을 때 해시 조인이 소트머지 조인보다 빠른 이유

a. 소팅을 수행하지 않기 때문이다.

b. 소트 알고리즘 보다 해시 알고리즘이 더 빠르기 때문이다.

c. Temp 테이블스페이스를 활용하지 않을 가능성이 높기 때문이다.

d. 조인 단계에 버퍼 캐시를 전혀 액세스하지 않기 때문이다.
=> HASH AREA에 담을 수 없을 정도로 큰 경우가 아니면, 해시 조인은 TEMP 테이블스페이스 즉 디스크에 쓰는 작업이 발생하지 않는다.

HASH AREA에서 생성한 해시 테이블을 이용한다는 점만 다를 뿐 NL 조인과 프로세싱은 같다.

그런데도 해시 조인이 인덱스 기반 조인보다 빠른 이유는 해시 테이블 영역을 PGA영역에 할당하기 때문이다.

NL 조인은 outer 테이블 레코드마다 INNER 테이블 쪽 테이블 레코드를 읽기 위해 래치 획득 및 캐시버퍼 체인 스캔 과정을 반복하지만 해시 조인은 래치 획득 과정없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.

해시 조인도 BUILD INPUT과 PROBE INPUT의 각 테이블을 읽을 때는 DB버퍼캐시 를 경유한다.

이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 해시조인도 피할 수 없다.

그렇다면 소트머지 조인보다 해시조인이 빠른 이유는 뭘까?

조인의 성능 차이는 조인 오퍼레이션을 시작하기 전 발생하는 사전 준비작업에서 기인한다.

소트 머지 조인은 양쪽 집합을 모두 정렬해서 PGA에 담는 작업이다.

PGA는 그리 큰 메모리 공간이 아니므로 두 집합 중 어느 하나가 중대형이상이면 디스크에 쓰는 작업을 반드시 수반한다.

해시 조인에서 사전 준비작업은 양쪽 집합 중 어느 한쪽을 읽어 해시 맵을 만드는 작업이다.

HASH AREA에 담을 수 없을 정도로 큰 경우가 아니면, 해시 조인은 TEMP 테이블스페이스 즉 디스크에 쓰는 작업이 발생하지 않는다.

27. 조인튜닝

```sql
-- 데이터
-- 대리점 : 1,000 개
-- 상품판매실적 : 월평균 100만 건

-- 인덱스 구성
-- 대리점_PK : 대리점코드
-- 상품판매실적_pk : 대리점코드 + 상품코드 + 판매일자
-- 상품판매실적_X1 : 판매일자 + 상품코드

select a.대리점명, SUM(b.판매금액) 매출금액
FROM 대리점 A, 상품판매실적 B
WHERE A.대리점코드 = B.대리점코드
AND B.상품코드 in ('A1847','Z0413')
and B.판매일자 between '20210101' AND '20210331'
group by b.대리점코드, a.대리점명
order by 1,2

-- execution plan
-- 30     SORT GROUP BY
-- 90000    NESTED LOOPS
-- 90000      TABLE ACCESS BY INDEX ROWID 상품판매실적
-- 90000        INDEX RANGE SCAN 상품판매실적_X1
-- 90000      TABLE ACCESS BY INDEX ROWID 대리점
-- 90000        INDEX RANGE SCAN 대리점 PK

```

a. 상품판매실적\_x1 인덱스를 [상품코드 + 판매일자] 순으로 변경한다.
=> 상품판매실적\_X1 인덱스가 판매일자 + 상품코드 순으로 구성돼 있고, 선두 컬럼인 판매일자가 between 조건 이므로 상품코드는 인덱스 필터 조건으로 사용된다
3개월 판매실적은 300만건 정도인데 상품코드 In 조건으로 필터링한 결과는 9 만건 이므로 인덱스 스캔 비효율이 크다
인덱스를 상품코드 + 판매일자 순으로 변경한다면 성능 개선에 도움이 된다.

b. 조인순서를 변경한다

대리점 테이블을 먼저 읽은 후 상품판매실적과 NL 조인한다면, 1000 번의 조인 액세스가 발생한다. 조건에 해당하는 대리점은 30개인데 판매가 없는 나머지 970개 대리점의 판매실적까지 읽고 버리는 비효율이 크다.
상품판매실적의 상품코드를 사용하는 조건이 IN이므로 대리점별로 인덱스를 두 번씩 탐색하는 부담도 있다.

c. 판매일자 조건을 만족하는 상품판매실적을 대리점 코드로 GROUP BY 한 후 대리점 테이블과 조인하는 SQL로 변환한다.
=>
현재 실행계획을 분석해 보면, 상품 판매실적을 먼저 읽은 후 30개의 대리점 코드에 대해 대리점 테이블을 각각 3000번씩 반복해서 조인 액세스 학 ㅗ있다.

상품판매실적을 대리점 코드로 GROUP BY 한 후 대리점 테이블과 조인하도록 SQL을 아래와 같이 변환하면, 조인 액세스를 대리점코드 별로 한 번씩만 할 수 있어 성능 개선에 큰 도움이 된다.

단, 인라인 뷰가 merge 되면 쿼리가 원래 현태로 돌아가므로 반드시 실행계획을 확인하고, 필요하다면 NO_MERGE 힌트로 뷰 merging을 방지해야 한다.

```sql
-- 데이터
-- 대리점 : 1,000 개
-- 상품판매실적 : 월평균 100만 건

-- 인덱스 구성
-- 대리점_PK : 대리점코드
-- 상품판매실적_pk : 대리점코드 + 상품코드 + 판매일자
-- 상품판매실적_X1 : 판매일자 + 상품코드

select A.대리점명, B.판매금액
FROM 대리점 A,
(
  select /*+no_merge*/
  대리점코드, sum(판매금액) 판매금액
  FROM 상품판매실적
  WHERE 상품코드 IN ('A1847', 'Z0413')
  AND 판매일자 bETWEEN '20210101' AND '20210331'
  GROUP BY 대리점코드
  ORDER BY 대리점코드
) B
WHERE A.대리점코드 = B.대리점코드

-- execution plan
-- 30 NESTED LOOPS
-- 30   VIEW
-- 30  SORT GROUP BY
-- 90000 TABLE ACCESS BY INDEX ROWID 상품판매실적
-- 90000  INDEX RANGE SCAN 상품판매실적_X1 (nonunique)
-- 30   TABLE ACCESS BY INDEX ROWID 대리점
-- 30     INDEX RANGE SCAN 대리점 PK (unique)

```

d. 해시조인으로 유도한다.

=> 해시조인으로 유도하면 1000개의 로우를 가진 대리점 테이블로 PGA에 해시맵을 만들어 조인하게 되므로 SGA 버퍼 캐시를 반복 탐색하는 비효율을 제거할 수 있다.

28. 조인튜닝

```sql
-- 데이터
-- 상품 : 50만 row
-- 상품상세 : 500만 row
-- 상품변경이력 : 1000만

-- 인덱스
-- 상품_PK : 상품코드
-- 상품상세_pK : 상품코드 + 상품상세코드
-- 상품변경이력_PK : 상품코드 + 변경일시

create table 상품상세_temp
nologging
as
select /*+ ordered use_hash(b) use_hash(c) swap_join_inputs(c)*/
*
from 상품상세 a, 상품변경이력 b, 상품 c
where b.상품코드 = a.상품코드
and b.변경일시 like substr(a.등록일시, 1, 8) || '%'
and c.상품코드 = a.상품코드
```

a.use_hash(b) 힌트를 use_nl(b) 로 수정한다.
=> 상품상세와 상품변경이력을 조인할때 nl 조인으로 한다.

b.ordered use_hash(b) 힌트를 leading(b) use_hash(a)로 수정한다.
=> 상품상세와 상품변경이력을 조인할때 순서를 변경한다.

c.힌트 전체를 leading(c a b) use_hash(b) swap_join_inputs(a)로 수정한다.
c > a > b 순서로 조인한다.

d.두 번째 조건절을 아래와같이 수정한다.
and substr(b.변경일시, 1, 8) = substr(a.등록일시 ,1, 8)

해시조인은 조인조건이 = 일 때만 사용 가능하다.

해시 함수를 이용해 체인을 할당하고 값을 찾는 특성으로 인해 해시 조인은 조인 조건이 = 일 때만 사용할 수 있다.

더 정확히 표현하면 조인 조건 중 하나 이상이 = 이어야 해시조인 할 수 있다.

해시 알고리즘 특성상 한 체인에 여러 개 값이 연결될 수 있는 구조이므로, 각 해시 체인에 연결된 값이 많을 수록 해시 맵 탐색 효율은 나빠진다.

상품코드 하나당 10개의 상품상세와 평균 20개의 상품변경이력이 있으므로 어느 쪽을 해시 맵으로 선택하더라도 해시 체인 하나에 여러 레코드가 달릴 수밖에 없는 구조이다.

상품상세의 등록일시를 해시 맵을 구성하는 기준 키 값으로 사용할 수 있으면 같은 상품이더라도 여러 체인으로 흩어진다.

그런데 조인 조건이 LIKE 이므로 해시 맵 기준 키로 사용할 수 없다.

조인 조건을 아래와 같이 = 로 바꿔주면 a.상품코드와 substr(a. 등록일시 , 1, 8) 두개의 값으로 해시맵을 구성할 수 있다.

29. 해시조인의 특징

a. 작은 집합을 해시 맵 build input 으로 선택하는 것이 좋다.
b. 중복 값이 거의 없는 집합을 해시 맵의 Buildinput으로 선택하는 것이 좋다.
c. 수행빈도가 매우 높은 쿼리는 해시 조인으로 유도하는 것이 좋다.
=> 해시 조인은 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대량 데이터를 조회할 때 사용하는 것이 좋다.

d. 모든 조인 조건이 = 면 가장 좋고, 적어도 하나는 = 이어야 해시 조인할 수 있다.

---

해시 맵 BUILD INPUT은 중복 값이 거의 없는 작은 집합일 때가 가장 좋다.
모든 조인 조건이 = 조건이면 가장 좋고, 적어도 하나는 = 조건이어야 해시 조인이 가능하다.

30. 해시조인 사용기준

a. 조인 컬럼에 적당한 인덱스가 없어 NL 조인이 비효율적일 때 사용한다.
b. 수행 빈도가 매우 높아 시스탬 전체 성능에 미치는 영향도가 큰 쿼리에 사용한다.
c. 대량 데이터를 조인할 때 주로 사용한다.
d. DW/OLAP성 쿼리, BATCH 프로그램에 주로 사용한다.

---

수행빈도가 높은 쿼리에 해시 조인을 사용하는 것은 위험할 수 있다.

NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용 하는 자료구조다. 반면, 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸한다.

같은 쿼리를 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개 만들어진다. 따라서 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다. 해시 맵을 만드는 과정에 여러 가지 래치 경합도 발생한다.

결론적으로 해시 조인은 아래 세 가지 조건을 만족하는 SQL 문에 주로 사용한다.

\- 수행 빈도가 낮고
\- 쿼리 수행 시간이 오래걸리고
\- 데량 데이터를 다루는 테이블 인 경우

31. 조인 순서에 가장 영향을 적게 받는 조인 메서드

a. NL 조인
=> NL 조인은 드라이빙 집합에 의해 전체 일량이 정해지므로 순서가 매우 중요하다.

b. 소트머지조인
=> 소트머지 조인은 여타 조인에 비해 순서에 따른 성능차이가 크지 않다.

c. 해시조인
d. 해시조인
=>
해시조인은 HASH AREA에 build input을 모두 채울 수 있느냐가 관건이므로 작은쪽을 드라이빙 하는것이 중요하다.

32. 해시조인 실행계획

```sql
select
/*+ORDERED USE_HASH(B) USE_HASH(C) SWAP_JOIN_INPUTS(C)*/
/*+LEADING(A, B, C) USE_HASH(B) USE_HASH(C) SWAP_JOIN_INPUTS(C)*/
*
from 주문 a, 주문상품 b, 상품 c
where b.주문번호 = a.주문번호
and c.상품코드 = b. 상품코드

-- Execution plan
-- SELECT STATEMENT
--  HASH JOIN
--    TABLE ACCESS FULL OF 상품
--    HASH JOIN
--      TABLE ACCESS FULL OF 주문
--      TABLE ACCESS FULL OF 주문상품
```

주문(A)과 주문상품(b)을 조인한 후에 상품(c)과 조인하는 실행계획이댜.

따라서 leading 힌트의 인자는 a,b,c 순으로 나열한다.

상품과 주문이 BUILD INPUT 이므로 각각을 swap join inputs 힌트로 지정해주면 된다.

주문은 leading 힌트의 첫 번째 인자로 지정했으므로 swap_join_inputs를 생략할 수 있다.

leading 또는 ordered 힌트에 의해 선택된 첫 번째 테이블은 무조건 build input으로 선택된다.

33. 해시조인 힌트

```sql
select
/*+LEADING(A, B, C) USE_HASH(B) USE_HASH(C) NO_SWAP_JOIN_INPUTS(C)*/
*
from 주문 a, 주문상품 b, 상품 c
where b.주문번호 = a.주문번호
and c.상품코드 = b. 상품코드

-- Execution plan
-- SELECT STATEMENT
--  HASH JOIN
--    HASH JOIN
--      TABLE ACCESS FULL OF 주문
--      TABLE ACCESS FULL OF 주문상품
--    TABLE ACCESS FULL OF 상품

```

주문과 주문상품을 조인한 후에 상품과 조인하는 실행계획이다.
leading 힌트를 통해 a,b,c 순으로 조인하도록한다.

주문과 주문상품을 조인할 때는 주문이 BUILD INPUT인데 leading 힌트의 첫 번째 인자이므로 swap_join_inputs를 생략할 수 있다.

주문과 주문상품을 조인한 집합으로 상품과 조인할 때는 상품이 PROBE INPUT이다. probe input을 명시적으로 선택할 때는 no_swap_join_inputs 힌트를 사용한다.

34. 해시조인 힌트

```sql
select
/*+LEADING(C, B, A) USE_HASH(B) USE_HASH(A) SWAP_JOIN_INPUTS(A)*/
/*+LEADING(B, C, A) USE_HASH(C) USE_HASH(A) SWAP_JOIN_INPUTS(C) SWAP_JOIN_INPUTS(A)*/
*
from 주문 a, 주문상품 b, 상품 c
where b.주문번호 = a.주문번호
and c.상품코드 = b. 상품코드

-- Execution plan
-- SELECT STATEMENT
--  HASH JOIN
--    TABLE ACCESS FULL OF 주문
--    HASH JOIN
--      TABLE ACCESS FULL OF 상품
--      TABLE ACCESS FULL OF 주문상품
```

상품과 주문상품을 조인한 후에 주문과 조인하는 실행계획이다.

따라서 leading 힌트의 인자는 c,b,a 순으로 나열한다.

상품과 주문이 BUILD INPUT이므로 각각을 swap_join_inputs 힌트로 지정해주면 된다.

상품을 leading 힌트의 첫 번째 인자로 지정했으므로 swap_join_inputs 를 생략할 수
있다.

leading 힌트의 인자를 b,c,a 순으로 나열할 수도 있는데 이 때는 c(상품)와 a(주문)을 모두 swap_join_inputs 힌트로 지정해 줘야한다.

35. 해시조인 힌트

```sql
select
/*+LEADING(C, B, A) USE_HASH(B) USE_HASH(A) NO_SWAP_JOIN_INPUTS(A)*/
/*+LEADING(B, C, A) USE_HASH(C) SWAP_JOIN_INPUTS(C) USE_HASH(A) NO_SWAP_JOIN_INPUTS(A)*/
*
from 주문 a, 주문상품 b, 상품 c
where b.주문번호 = a.주문번호
and c.상품코드 = b. 상품코드

-- Execution plan
-- SELECT STATEMENT
--  HASH JOIN
--    HASH JOIN
--      TABEL ACCESS FULL OF 상품
--      TABEL ACCESS FULL OF 주문상품
--    TABLE ACCESS FULL OF 주문

```

상품과 주문상품을 조인한 후에 주문과 조인하는 실행계획이다.
따라서 leading 힌트의 인자는 c,b,a 순으로 나열한다.

상품과 주문 상품을 조인할 때는 상품이 BUIld input 인데 상품은 leading 힌트의 첫 번째 인자이므로 Swap_join_inputs를 생략할 수 있다.

상품과 주문상품을 조인한 집합으로 주무노가 조인할 때는 주문이 probe input이다.
probe input을 명시적으로 선택할 때 NO_swap_join_inputs 힌트를 사용한다.

leading 힌트의 인자를 B,C,A 순으로 나열할 수도 있는데, 이때는 상품(C)가 build input이 되도록 USE_HASH(C) SWAP_JOIN_INPUTS(C) 힌트를 지정해 줘야 한다.

36. 해시조인 힌트

```sql
-- 인덱스 구성
-- 계약_Pk : 계약번호
-- 계약_X1 : 계약일자
-- 가입상품_Pk : 계약번호 + 상품번호
-- 가입상품_X1 : 가입일자
-- 가입부가상품_Pk : 계약번호 + 상품코드 + 부가상품콛,
-- 상품_Pk : 상품코드

SELECT
/*+index(A 계약_X1) index(B 가입상품_X1) index(C 가입부가상품_PK) index(D 상품_PK) LEADING(B A C D) USE_HASH(A) USE_NL(C) USE_HASH(D) SWAP_JOIN_INPUTS(D) */
/*+index(A 계약_X1) index(B 가입상품_X1) index(C 가입부가상품_PK) index(D 상품_PK) ORDRED USE_HASH(B) SWAP_JOIN_INPUTS(B)
USE_NL(C) USE_HASH(D) SWAP_JOIN_INPUTS(D) */

*
FROM 계약 A, 가입상품 B, 가입부가상품 C, 상품 D
WHERE A.계약일자 = :CNTR_DT
AND B.계약번호 = A.계약번호
AND B.가입일자 = :ent_dt
AND C.계약번호 = B.상품코드
AND C.부가상품코드 like 'A%'
AND D.상품코드 = C.부가상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  HASH JOIN
--    TABLE ACCESS BY INDEX ROWID OF '상품'
--      INDEX RANGE SCAN OF 상품_PK
--    NESTED LOOPS
--      HASH JOIN
--        TABLE ACCES BY INDEX ROWID OF 가입상품
--          INDEX RANGE SCAN OF 가입상품_X1
--        TABLE ACCESS BY INDEX ROWID OF 계약
--          INDEX RANGE SCAN OF 계약_X1
--      INDEX RANGE SCAN OF '가입부가상품_PK'
```

37. 해시조인 힌트

```sql
-- 인덱스 구성
-- 계약_Pk : 계약번호
-- 계약_X1 : 계약일자
-- 가입상품_Pk : 계약번호 + 상품번호
-- 가입상품_X1 : 가입일자
-- 가입부가상품_Pk : 계약번호 + 상품코드 + 부가상품콛,
-- 상품_Pk : 상품코드

SELECT
/*+LEADING(B A C D) USE_HASH(A) USE_NL(C) USE_HASH(D) NO_SWAP_JOIN_INPUTS(D)
INDEX(B 가입상품_X1) INDEX(A 계약_X1) INDEX(C 가입부가상품_PK) INDEX(D 상품_PK)*/
*
FROM 계약 A, 가입상품 B, 가입부가상품 C, 상품 D
WHERE A.계약일자 = :CNTR_DT
AND B.계약번호 = A.계약번호
AND B.가입일자 = :ent_dt
AND C.계약번호 = B.상품코드
AND C.부가상품코드 like 'A%'
AND D.상품코드 = C.부가상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  HASH JOIN
--    NESTED LOOPS
--      HASH JOIN
--        TABLE ACCES BY INDEX ROWID OF 가입상품
--          INDEX RANGE SCAN OF 가입상품_X1
--        TABLE ACCESS BY INDEX ROWID OF 계약
--          INDEX RANGE SCAN OF 계약_X1
--      INDEX RANGE SCAN OF '가입부가상품_PK'
--    TABLE ACCESS BY INDEX ROWID OF '상품'
--      INDEX RANGE SCAN OF 상품_PK
--

```

# 스칼라서브쿼리ß

38. 스칼라서브쿼리 변환

```sql
select 주문번호, 주문일자, 고객번호, 주문금액, 배송지
,(SELECT 고객명 FROM 고객 WHERE 고객번호 = O.고객번호) 고객명
,(SELECT 결제구분명 FROM 결제구분 WHERE 결제구분코드 = O.결제구분코드) 결제구분명
FROM 주문 O
WHERE 주문일자 BETWEEN :ORD_DT1 AND :ORD_DT2

select 주문번호, 주문일자, 고객번호, 주문금액, 배송지, C.고객명, S.결제구분명
FROM 주문 O, 고객 C, 결제구분 S
where C.고객번호 = O.고객번호
AND S.결제구분코드(+) = O.결제구분코드
AND O.주문일자 BETWEEN :ORD_DT1 AND :ORD_DT2

```

ERD에서 주문과 결제구분 간 관계선을 보면, 주문 레코드를 입력할 때 결제구분코드는 입력하지 않을 수 있다.

따라서 결제구분과 조인하는 스칼라 서브쿼리를 일반 조인문으로 변환할 때는 반드시 OUTER 조인을 사용해야 결과집합을 보장할 수 있다.

주문 레코드를 입력할 때 고객번호는 반드시 입력해야 한다고 정의했다.

따라서 고객과 조인하는 스칼라 서브쿼리를 일반 조인문으로 변환할 때는 INNER 조인과 OUTER 조인 중 어느 것을 사용해도 결과집합에는 영향이 없다.

그렇지만 성능을 위해 가급적 INNER 조인을 사용하는 것이 좋다.

INNER 조인은 어느 쪽 방향으로든 조인이 가능하지만 OUTER 조인은 방향이 한쪽으로 고정되기 때문이다.

39. 스칼라서브쿼리 변환

```sql
SELECT O.주문번호,
MIN(O.고객번호) AS 고객번호
, MIN(C.고객명) AS 고객명
, MIN(O.주문금액) AS 총주문금액
, MAX(P.주문금액) AS 최대주문금액
 FROM 고객 C, 주문 O, 주문상품 p
WHERE O.주문일자 BETWEEN :ORD_DT1 AND :ORD_DT2
AND   C.고객번호 = O.고객번호
AND   P.주문번호 = O.주문번호
GROUP BY  O.주문번호

SELECT O.주문번호
,(SELECT 고객명 FROM 고객 WHERE 고객번호 = O.고객번호) as 고객명
,(SELECT MAX(주문금액) FROM 주문상품 WHERE 주문번호 = O.주문번호)
, 주문금액
FROM 주문
WHERE O.주문일자 BETWEEN :ORD_DT1 AND :ORD_DT2

```

일반 조인문을 스칼라 서브쿼리로 변환할 때는 테이블 간 필수/옵션 관계를 신경쓰지 않아도 된다.

스칼라 서브쿼리는 OUTER 조인과 같은 결과를 반환하는데 OUTER 조인은 inner 조인 결과를 포함하기 때문이다.

하지만 조인 카디널리티는 반드시 확인해야 한다.

스칼라 서브쿼리는 메인 집합의 레코드당 하나의 레코드만 반환해야 하므로 m쪽 집합을 스칼라 서브 쿼리로 변환할 때는 집계 함수를 사용하거나 ROWNUM <= 1 조건을 사용해야 한다.

---

1. 주문과 주문상품 간의 조인 카디널리티는 1:M 이다.
   주문 하나당 두 개 이상의 주문 상품을 반환할 수 있으므로 주문상품과의 조인을 스칼라 서브쿼리로 변환할 때 ORA-01427 에러를 피하려면 집계 함수를 사용하거나 ROWNUM <= 1 조건을 사용해야 한다.

2. 고객과 주문 간 조인 카디널리티는 1:M 이다.
   고객과의 조인을 스칼라 서브쿼리로 변환하면 항상 단일 행을 반환하므로 ROWNUM <= 1 조건 또는 집계함수는 불필요하다.
   변환 전 원본 SQL은 주문별 최대 주문금액을 반환하므로 주문상품과의 조인을 스칼라 서브쿼리로 변환하려면 MAX(주문금액) 함수를 사용해야 정확한 결과를 보장한다.

3. 고객과 주문간 조인 카디널리티는 1:M 이다.
   고객과의 조인을 스칼라 서브쿼리로 뱐환하면 항상 단일 행을 반환하므로 집계함수는 불필요하다.

---

40. 스칼라 서브쿼리의 특징

a. 메인쿼리의 한 레코드당 하나의 값만 반환할 수 있다.
b. 주로 코드명, 상품명 등을 조회할 때 사용한다.
c. Unnesting 쿼리변환이 작동하지 않으면 NL 조인과 같은 방식으로 조인한다.
d. 스칼라 서브쿼리는 성능이 좋지 않아 일반 조인문을 사용하는 것이 좋다.
=> 스칼라 서브쿼리에는 캐싱 기능이 작동하므로 코드, 분류, 부서, 사원, 상품 등 조인 컬럼의 값 종류 개수가 적은 테이블과 조인하면 성능향상에 도움이 된다.

---

매인 쿼리의 한 레코드당 하나의 값만 반환할 수 있다.
주로 코드명, 상품명 등을 조회할 때 사용한다.
UNNESTING 쿼리 변환이 작동하지 않는다면 NL 조인과 같은 방식으로 조인한다.

\- 스칼라 서브쿼리 캐싱 효과

스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하기위해 입력 값과 출력 값을 내부 캐시에 저장해 둔다. 조인할 때마다 캐시에서 입력 값을 찾아보고 찾으면 저장된 출력 값을 반환한다.

이런 캐신 매커니즘은 조인성능을 높이는데 큰 도움이 된다. 매인쿼리 집합이 아무리 커도 조인할 때 데이터를 대부분 캐시에서 찾는다면 조인 수행횟수를 최소화 할 수 있기 때문이다.

스칼라 서브쿼리에는 캐싱 기능이 작동하므로 코드, 분류, 부서, 사원, 상품 등 조인 칼럼의 값 종류 개수가 적은 테이블과 조인할 때 사용하면 성능 향상에 도움이 된다.

41. 스칼라서브쿼리 캐싱

```sql
--          데이터 건수
-- 결제구분     5
-- 상품       100000
-- 고객       1000000
-- 고객이력     10000000
-- 주문         100000000
-- 주문상세       500000000

SELECT
,(SELECT 고객명 FROM 고객 WHERE 고객번호 = O.고객번호) 고객명
,(SELECT 상품명 FROM 상품 WHERE 상품코드 = O.상품코드) 상품명
,(SELECT 결제구분명 FROM 결제구분 WHERE 결제구분코드 = O.결제구분코드) 결제구분명
,(SELECT /*+INDEX_DESC(고객번호, 변경일시)*/ 휴대폰번호
  FROM  고객이력 H
  WHERE 고객번호 = O.고객번호
  AND ROWNUM <= 1
) 휴대폰번호
FROM 주문 O, 주문상세 D
WHERE O.주문일자 BETWEEN :ord_dt1 and :ort_dt2
and d.주문번호 = O.주문번호
```

스칼라 서브쿼리에 사용하는 캐시는 매우 작은 메모리 공간이다.

스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 적을 때 효과가 있다.
반대의 경우라면 캐시를 매번 확인하는 비용 때문에 오히려 성능이 나빠지고 cpu 사용률이 증가한다.

결제구분코드는 5개의 값이 존재한다. 다섯 개면 캐시에 모두 저장하고도 남는다.
그렇다면 메인쿼리가 아무리 큰 집합이더라도 결제구분코드와의 조인 엑세스는 최초 한번씩 총 5번만 발생한다.

이후로는 모두 캐시에서 데이터를 찾게 되므로 조인 성능을 높이는데 큰 도움이 된다.

반면, 값의 종류가 100만개인 고객 테이블과 조인하는 경우 스칼라 서브쿼리와 조인하는 고객이 10만명만 되도 캐시에서 찾을 가능성이 거의 없는데 건건이 캐시를탐색하면서 시간을 허비한다.

42. 스칼라서브쿼리 실행계획

```sql
select C.고객번호, C.거래명
,(
  select round(avg(거래금액), 2) 평균거래금액
  from 거래
  where 거래일시 >= trunc(sysdate, 'mm')
  and 고객번호 = c.고객번호
)
from 고객 c
where C.가입일시 >= Trunc(add_months(sysdate, -1), 'mm')

-- SELECT STATEMENT
-- SORT AGGREAGATE
--  TABLE ACCESS BY INDEX ROWID OF 거래
--   INDEX RANGE SCAN 고객_IDX
-- TABLE ACCESS BY INDEX ROWID OF 고객
--   INDEX RANGE SCAN 고객_IDX
```

메인 쿼리 실행부분이 아래쪽에 있고, 스칼라 서브쿼리 실행부분이 위쪽에 나타난다.

43. 부분범위 처리가 가능한 상황에서 조인 조건 PUSHDOWN을 활용한 인라인 뷰 최적화

```sql
-- 인덱스 구성
-- 고객_pk : 고객번호
-- 고객_x1 : 가입일시
-- 거래_pk : 거래번호
-- 거래_x1 : 거래일시
-- 거래_x2 : 고객번호 + 거래일시

SELECT /*+ordered use_nl(t) index(고객_x1)*/
c.고객번호, C.고객명, T.평균거래, T.최소거래, T.최대거래
FROM 고객 C
,(
  select /*+no_merge push_pred index(거래 거래_x2)*/
  고객번호
  ,avg(거래금액) 평균거래
  ,min(거래금액) 최소거래
  ,max(거래금액) 최대거래
  from 거래
  where 거래일시 >= Trunc(sysdate, 'mm')
  group by 고객번호
) t
-- 전월 이후 가입한 사람
WHERE c.가입일시 >= Trunc(add_months(sysdate, -1), 'mm')
and t.고객번호 = c.고객번호

-- SELECT STATEMENT
--  NESTED LOOPS
--    TABLE ACCESS BY INDEX ROWID OF 고객
--      INDEX RANGE SCAN OF 고객_X1
--    VIEW PUSED PREDICATE
--      SORT(GROUP BY)
--        TABLE ACCESS BY INDEX ROWID BATCHED OF 거래
--          iNDEX RANGE SCAN OF 거래_X2


-- MERGING
SELECt 고객번호
,MIN(고객명) 고객명
,avg(거래금액) 평균거래
,min(거래금액) 최소거래
,max(거래금액) 최대거래
FROM
(
  SELECT /*+ordered use_hj(t)+*/
    C.고객번호, C.고객명, T.거래금액
  FROM 고객 C, 거래 T
  WHERE c.가입일시 >= Trunc(add_months(sysdate, -1), 'mm')
  AND T.거래일시 >= Trunc(sysdate, 'mm')
  and t.고객번호 = c.고객번호
)
group by 고객번호


-- EXECUTION PLAN
--   SELECT STATEMENT
--      HASH (GROUP BY)
--        HASH JOIN
--            TABLE ACCESS FULL OF 고객
--            TABLE ACCESS FULL OF 거래
```

옵티마이저는 쿼리 블록 단위로 최적화 한다.

문제의 쿼리에서 view를 변환하지 않고 그대로 두면, 뷰 쿼리 블록을 독립적으로 최적화 한다.

그러면 당월 거래 전체를 읽어 고객번호 수준으로 GROUP BY 한 후 고객 테이블과 조인하므로 부분범위 처리가 불가능하다.

더 큰 문제는 고객 테이블에서 전월 이후 가입한 고객을 필터링 하는 조건이 인라인 뷰 바깥에 있다는 사실이다.

이 조건이 있음에도 인라인 뷰 안에서는 전월 이전에 가입한 고객의 당월 거래 데이터까지 모두 읽어야 한다.

뷰 바깥에 있는 조건절을 활용하기 위해 옵티마이저는 뷰를 메인 쿼리와 머징할 수 있다. 문제에서 제시한 실행계획이 바로 그것이다.

여기서는 뷰 머징한 거래 테이블을 고객과 해시 조인한 후에 GOUP BY 했지만, NL 조인으로 처리할 수도 있다.

고객을 기준으로 거래 테이블과 NL 조인을 유도하고 그 순서에 최적화된 인덱스를 구성해 주면 가입일시 조건을 만족하는 고객의 거래 중 거래일시 조건을 만족하는 데이터만 읽도록 구현할 수 있다.

그러나 여전히 부분범위 처리는 불가능하다. 조인에 성공한 전체 집합을 GROUP BY 해야 데이터를 출력할 수 있기 때문이다.

11g에 도입된 조인 조건 pushdown 쿼리 변환을 이용하면 지금까지 설명한 비효율을 해결할 수 있다.

이는 메인 쿼리를 실앻아면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능이다.

이 기능이 작동하면 실행계획에 아래와 같이 VIEW PUSHED PREDICATE 오퍼레이션이 나타난다.

GROUP BY를 포함한 뷰를 부분범위 처리 가능한 실행계획으로 유도할 수 있는지 검증하는 문제다.

지금과 같은 상황에서 과거에는 스칼라 서브 쿼리를 활용하곤 했다.

11G 이후로 조인 조건 pushdown 쿼리 변환을 이용하면 복잡한 스칼라 서브 쿼리를 활용하지 않고도 문제를 간단히 해결할 수 있다.

```sql
-- 옵티마이저는 다음과 같이 쿼리를 실행한다.

select  /*+ordered use_nl(t)*/
C.고객번호, C.고객명, T.평균거래, T.최소거래, T.최대거래
FROM 고객 c
, (
  SELECT /*+ no_merge*/
   고객번호
  , avg(거래금액) 평균거래
  , min(거래금액) 최소거래
  , max(거래금액) 최대거리
  from 거래
  where 거래일시 >= trunc(sysdate, 'mm')
  and t.고객번호 = c.고객번호 -- 조인 조건 pushdown
  group by 고객번호
) t
where C.가입일시 > trunc(add_months(sysdate, -1), 'mm')


-- EXECUTION PLAN
-- SELECT STATEMENT
--  HASH GROUP BY
--    HASH JOIN
--      TABLE ACCESS FULL OF 고객
--      TABLE ACCESS FULL OF 거래

-- 스칼라 서브쿼리 활용 모범답안

select 고객번호, 고객명
,TO_NUMBER(SUBSTR(거래금액, 1, 10)) 평균거래금액
,TO_NUMBER(SUBSTR(거래금액, 11, 10)) 최소거래금액
,TO_NUMBER(SUBSTR(거래금액, 21)) 최대거래금액
FROM
(
  SELECT C.고객번호, C.고객명,
  (
    SELECT LPAD(avg(거래금액) 평균거래, 10) || LPAD(min(거래금액) 평균거래,10)
    || max(거래금액) 평균거래, 10
    from 거래
    where 거래일시 >= trunc(sysdate, 'mm')
    and 고객번호 = C.고객번호
  )
  FROM 고객 c
  where C.가입일시 > trunc(add_months(sysdate, -1), 'mm')
)

```

44. 부분범위 처리를 위한 스칼라 서브쿼리 최적화

```SQL
-- 인덱스 구성
-- 고객_PK : 고객번호
-- 거래_PK : 거래번호
-- 거래_X1 : 거래일시

SELECT C.고객번호, C.고객명
,(
  SELECT ROUND(AVG(거래금액), 2) 평균거래금액
  FROM 거래
  WHERE 거래일시 >= TRUNC(SYSDATE, 'MM')
  AND 고객번호 = C.고객번호
)
FROM 고객 C
WHERE  C.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'MM')

SELECT 고객번호, min(고객명), Round(avg(거래금액))
(
  SELECT C.고객번호, C.고객명, T.거래금액
  FROM 고객 C,거래 T
  WHERE  C.고객번호 = T.고객번호 (+)
  AND C.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'MM')
  AND T.거래일시 >= TRUNC(SYSDATE, 'MM')
)
group by 고객번호

-- EXECUTION PLAN
-- SELECT STATEMENT
-- HASH GROUP BY
--    HASH JOIN
--      TABLE ACCESS FULL OF 고객
--      TABLE ACCESS FULL OF 거래
```

스칼라 서브쿼리도 nl 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 I/O에 따른 부담이 클 수 있다.

그래서 NL이 아닌 다른 조인 방식을 선택하기 위해 스칼라 서브쿼리를 일반 조인문으로 변환해야하는 경우가 있다.

예전에는 사용자가 직접 쿼리를 변경해야 했찌만 오라클 12c 부터는 스칼라 서브 쿼리도 UNNESTING이 가능하다.

문제 쿼리는 스칼라 서브쿼리임에도 NL 조인이 아닌 해시 조인하는 실행계획이 수립됐다.
이는 스칼라 서브쿼리가 일반 조인문으로 변환(UNNESTING)됐기 때문에 가능한 일이다.

하지만 문제는 조인에 성공한 전체 집합을 GROUP BY 한 후 데이터를 출력했으므로 부분범위 처리가 불가능해졌다는데 있다.

그럴 때 no_unnest 힌트로 unnesting 을 방지해 주면 기존처럼 부분범위 처리 가능한 실행계획이 수립된다.

아예 쿼리를 조인문으로 변환한 후 조인 조건 pushdown 방식을 활용하는 방법도 있따.

```sql
-- 인덱스 추가
-- 고객_X1 : 가입일시
-- 거래_X2 : 고객번호 + 거래일시

-- no_unnest 힌트 활용
SELECT /*+ no_unnest*/ C.고객번호, C.고객명
,(
  SELECT ROUND(AVG(거래금액), 2) 평균거래금액
  FROM 거래
  WHERE 거래일시 >= TRUNC(SYSDATE, 'MM')
  AND 고객번호 = C.고객번호
)
FROM 고객 C
WHERE  C.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'MM')

-- 쿼리변환후 조인조건 Pushdown

SELECT /*+ Ordered use_nl(t)*/ C.고객번호, C.고객명
, t.평균거래금액
FROM 고객 C
, (
  SELECT /*+no_merge push_pred*/
  고객번호, ROUND(AVG(거래금액), 2) 평균거래금액
  FROM 거래
  WHERE 거래일시 >= TRUNC(SYSDATE, 'MM')
  group by 고객번호
)t
WHERE  C.가입일시 >= TRUNC(ADD_MONTHS(SYSDATE, -1), 'MM')
AND T.고객번호(+) = c.고객번호

```

# 고급 조인 기법

45. 쿼리변환

```sql
-- 데이터
-- 지점 : 30개
-- 판매내역 : 월 평균 3만 건

-- 인덱스 구성
-- 지점_PK : 지점코드
--cj 판매내역_PK : 판매지점코드 + 판매월
-- 판매내역_X1 : 판매월

select A.지점명, SUM(B.판매금액) 판매금액
from 지점 A, 판매내역 B
where A.지점코드 = B.판매지점코드
and B.판매월 between '202101' and '202103'
group by B.판매지점코드, A.지점명
order by 1, 2

-- Execution plan
-- 30 SORT GROUP BY
-- 90000 NESTED LOOPS
-- 90000  TABLE ACCESS BY INDEX ROWID 판매내역
-- 90000     INDEX RANGE SCAN 판매내역_x1
-- 90000  TABLE ACCESS BY INDEX ROWID 지점
-- 90000      INDEX UNIQUE SCAN 지점_PK

SELECT /*+ORDERED USE_NL(B)*/
A.지점명, SUM(B.판매금액) 판매금액
FROM 지점 A
,(
  SELECT /*+NO_MERGE*/
  판매지점코드, SUM(판매금액)
  FROM 판매내역
  WHERE B.판매월 between '202101' and '202103'
  GROUP BY 판매지점코드
) B
WHERE A.지점코드 = B.판매지점코드
```

a. GROUP BY의 'B.판매지점코드' 를 'A.지점코드'로 변경한다.
=> GROUP BY에 b.판매지점코드를 기술하든 A.지점코드를 기술하든 성능과는 무관하다.

b. 조인 순서를 변경한다.
=> 지점 테이블을 먼저 읽은 후 판매내역과 NL 조인한다, 조인 엑세스를 30번으로 줄일 수 있다. 판매내역\_PK 인덱스가 판매지점코드 + 판매월로 구성돼 있어 성능 개선이 가능하다.

c. 해시조인으로 유도한다.
=> 해시 조인으로 유도하면 작은 지점 테이블로 PGA에 해시맵을 만들어 조인하므로 SGA 버퍼 캐시를 반복해서 탐색하는 비효율을 제거할 수 있다.

d. 판매월 조건을 만족하는 판매내역을 지점코드로 group by 한 후 지점 테이블과 조인하도록 sql을 변경한다.
=>
조건 월에 해당하는 판매내역을 판매지점으로 group by 한 후 지점 테이블과 조인한다.

문제의 SQL의 가장 큰 문제점은 같은 지점코드에 대한 반복적인 조인 엑세스가 많다는 데 있다.
다량의 판매내역을 읽으면서 작은 지점 테이블과 조인하기 때문이다.

SQL을 변환하면 조인 액세스를 지점 별로 한 번씩만 할 수 있어 성능 개선에 큰 도움이 된다.

단, 인라인 뷰가 merge되면 쿼리가 원래의 형태로 돌아가므로 반드시 실행계획을 확인하고 필요하다면 NO_MERGE 힌트로 뷰 MERGING을 방지해야 한다.

```sql
select A.지점명, B.판매금액
from 지점 a,
(
SELECT /*+NO_MERGE*/
판매지점코드, SUM(판매금액) 판매금액
FROM 판매내역
WHERE 판매월 between '202101' and '202103'
group by 판매지점코드
) B
where a.지점코드 = b.판매지점코드
명

-- Execution plan
--
-- 30     NESTED LOOPS
-- 30     VIEW
-- 30     SORT GROUP BY
-- 90000    TABLE ACCESS BY INDEX ROWID 판매내역
-- 90000       INDEX RANGE SCAN 판매내역_x1
-- 30      TABLE ACCESS BY INDEX ROWID 지점
-- 30       INDEX UNIQUE SCAN 지점_PK
```

46.

```sql
-- 튜닝 전 SQL
select c.고객번호, min(c.고객명) 고객면
,sum(o.주문금액) 주문금액
from 주문 o, 고객 c
where o.주문일시 >= add_month(sysdate, -1)
and c.등록지점코드 = 'KTG'
and c.고객번호 = o.고객번호
group by o.고객번호

-- 튜닝 후 SQL
select c.고객번호, c.고객명 ,o.주문금액
from 고객 c,
(
  select 고객번호, sum(주문금액) 주문금액
  from 주문
  where 주문일시 >= add_month(sysdate, -1)
  group by 고객번호
) o
where c.등록지점코드 = 'KTG'
and c.고객번호 = o.고객번호

```

group by를 조인된 전체 결과에 하느냐/ 주문 테이블에서 주문일시 조건을 만족하는 레코드에 대해서만 하느냐의 차이

조인되는 전체 결과가 적을수록 전자가 유리하고 많을 수록 후자가 유리하다.

소수의 고객이 여러번 반복해서 주문하는 쇼핑몰이라면, 주문일시 조건절 구간에 같은 고객이 여러번 나타난다.

따라서 튜닝 전 sql은 같은 고객에 대해 여러번 조인하는 비효율이 나타난다.

전체 조인결과수도 많다.

주문일시 조건을 만족하는 데이터가 많을수록 같은 고객이 반복해서 나타나므로 비효율도 커진다.

튜닝 후 처럼 고객번호로 group by 한 후 조인하면 고객별로 한 번씩만 조인할 수 있어 성능 개선에 큰 도움이 된다.

반대로 다수의 고객이 어쩌다 한 번 주문하는 쇼핑몰이라면 고객 번호로 GROUP BY 한 후 조인했을 때의 이점이 사라진다.

주문일시 조건절 구간에 같은 고객이 여러 번 나타나지 않기 때문이다.

게다가 등록지점코드를 만족하는 고객이 소수라면 더 불리해진다

한 달치 주문 데이터를 모두 읽어 group by 한 후 고객 테이블과 조인했는데 대부분의 고객이 등록지점코드 조건을 만족하지 않아 필터링 되는 경우이다.

그렇다면 등록지점코드 조건을 만족하는 고객만 읽어서 주문과 조인하는 것이 유리하다.

단, 주문 테이블의 인덱스는 고객번호 + 주문일시로 구성돼 있어야 한다.

튜닝 후 SQL의 성능 개선 효과를 극대화 하려면 고객 당 하루 주문 건수가 많아야하고, 주문일시 조건을 만족하는 데이터가 많아야 하며, 등록지점코드 조건을 만족하는 데이터도 많아야 한다.

47. sql 튜닝

```sql

-- 결과집합을 모두 출력하는 에플리케이션 환경을 기준을 튜닝
-- 필요하다면, 인덱스 재구성안을 제시
-- 튜닝 의도대로 정확히 실행되도록 옵티마이저 힌트 기술

SELECT p.상품코드, MIN(P.상품명) 상품명, MIN(P.상품가격) 상품가격
FROM 주문상품 O, 상품 P
WHERE
AND O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
AND O.할인유형코드 = 'K890'
and P.상품코드 = o.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 desc, 상품코드

-- Execution plan
-- select statement
--  sort order by
--    hash group by
--      nested loops
--        nested loops
--          table acces by index rowid  주문상품
--            index range scan of 주문상품_X1
--          INDEX UNIQUE SCAN OF 상품_PX
--        TABLE ACEESS BY INDEX ROWID OF 상품

-- 주문상품은 비파티션 테이블
-- 한 달 주문상품 = 100만 건
-- 주문상품의 보관기간 = 10년
-- 주문상품 총 건수 = 1억2천만건
-- 할인유형코드 조건을 만족하는 데이터 비중 20%
-- 등록된 상품 = 2만 개
-- 2만개 상품을 고르개 주문
-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드

```

한 달 주문상품 100만 건 중 할인유형코드 조건을 만족하는 데이터는 20% 이므로 GROUP BY 절에 상품과 조인할 대상 레코드는 20만 건.

주문상품은 비파티션 테이블이므로 1억 2천만 건중 20만 건을 찾으려면 인덱스가 필요하고 할인유형코드 + 주문일시 순으로 구성하면 효과적이다.

상품은 2만개이고 Sql에 사용된 컬럼도 3개 뿐이다.

상품 데이터를 pga에 충분히 담을 수 있고 2만 개 상품을 고르게 주문하므로

불필요한 상품을 PGA에 적재하는 비효율도 없다.

따라서 20만개 주문상품을 기준으로 nL 조인으로 버퍼 캐시를 탐색하는것 보다 해시 조인으로 PGA를 탐색하는 것이 훨씩 효과적이다.

```sql
/*+LEADING(P) USE_HASH(O) INDEX(O 주문상품\_x1) FULL(P)*/
-- SELECT STATEMENT
--  SORT (ORDER BY)
--      HASH GROUP BY
--        HASH JOIN
--          TABLE ACCESS FULL OF 상품
--          TABLE ACCESS BY INDEX ROWID OR 주문상품
--            INDEX RANGE SCAN OF 주문상품_X1
```

GROUP BY 후 조인하는 방법도 고려할 수 있다. PGA에 충분히 담을 수 있는 집합이므로 GROUP BY 수행 부담을 무시할만하다.

```sql
SELECT
/*+LEADING(O) USE_HASH(P) FULL(P)*/
/*+LEADING(p) USE_HASH(o) FULL(P)*/
p.상품코드, O.총주문수량, O.총주문금액
FROM (
  SELECT  상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액
  FROM 주문상품 A
  where 주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND O.할인유형코드 = 'K890'
  GROUP BY 상품코드
) O
,상품 P
WHERE P.상품코드 = o.상품코드
ORDER BY 총주문금액 desc, 상품코드

-- index 재구성 주문상품_x1: 할인유형코드 + 주문일시
```

2만개의 상품을 고르개 주문하므로 GROUP BY의 결과 집합은 2만여 건이다.

상품코드당 주문 상품은 평균 10건이므로 조인횟수를 10분의 1로 줄일 수 있다.
GROUP BY 추가 수행에 따른 부담을 상쇄하고도 남는다.

조인 횟수가 줄고 같은 상품코드로 여러번 조인하지도 않으므로 NL 조인의 부담이 줄지만, 여기서도 해시 조인이 더 빨고 효과적이다.

상품 데이터를 PGA에 충분히 담을 수 있을 뿐아니라 2만개 상품을 고르게 주문하므로 불필요한 상품을 PGA에 적제하는 비효율도 없다.

해시 조인은 출력 순서를 보자하지 않으므로 ORDER BY 맨 마지막에 기숧애ㅑ 한다.
ORDER BY 가 없은 인라인 뷰는 옵티마이저에 의해 merge 될 수 있으므로 정확히 위 실행계획이 나오게 하려면 No_merge 힌트가 필요하다.

48. SQL튜닝

```sql

SELECT
P.상품코드, MIN(P.상품명) 상품명, MIN(P.상품가격) 사품가격
, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
FROM 주문상품 O, 상품 P
WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
AND O.할인유형코드 = 'K890'
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION bPLAN
-- SELECT STATEMENT
--  SORT ORDER BY
--    HASH GROUP BY
--      NESTED LOOPS
--        NESTED LOOPS
--          PARTITION RANGE
--            TABLE ACCESS BY INDEX ROWID OF 주문상품
--              INDEX RANGE SCAN OF 주문상품_x1
--            INDEX UNIQUE SCAN OF 상품_PK
--         TABLE ACCESS BY INDEX ROWID OF 상품

-- 주문상품은 월 단위 파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 20%(20만건)
-- 등록된 상품 = 2만개
-- 대부분 상품을 한달에 한 개 이상 주문

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드
```

한 달 주문상품 100만 중 할인유형코드 조건을 만족하는 데이터는 20만 건이다.

주문 상품은 월 단위 파티션 테이블이므로 인덱스로 20만 건을 랜덤 액세스 하는 것 보다 full scan이 유리하다.

2만개의 상품을 한 달에 한 개 이상 주문하므로 GROUP BY 결과 집합은 2만여 건이다.
상품코드당 주문상품은 평균 10건이므로 주문상품을 GROUP BY 한 후 조인하면 조인 횟수를 1/10으로 줄일수 있ㄷ.

```sql


SELECT /*+LEADING(O) USE_NL(P) FULL(P)*/
P.상품코드, P.상품명, O.총주문수량, O.총주문금액
FROM (
  SELECT /*+FULL(A) NO_MERGE*/
  상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액
  FROM 주문상품 A
  WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND O.할인유형코드 = 'K890'
  GROUP BY O.상품코드
)O, 상품 P
WHERE P.상품코드 = O.상품코드
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  SORT ORDER BY
--    HASH JOIN
--      VIEW
--        HASH GROUP BY
--          PARTITION RANGE
--            TABLE ACCESS FULL OF 주문상품
--      TABLE ACCESS FULL OF 주문
```

조인 횟수가 줄고 같은 상품코드로 여러번 조인하지 않으므로 NL 조인의 부담이 줄지만,
해시 조인이 더 빠르고 효과적이다.

상품 데이터를 PGA에 충분히 담을 수 있을 뿐아니라 2만개의 상품을 고르개 주문하므로 불필요한 상품을 PGA에 적재하는 비효율도 없기 때문이다.

해시 조인은 촐력 순서를 보장하지 않으므로 ORDER BY 맨 마지막에 기술해야한다.
ORDER BY가 없는 인라인뷰는 옵티마이저에 의해 merging 될 수 있으므로 정확히 위 실행계획이 나오게 하려면 no_merge 힌트가 필요하다.

49. 쿼리튜닝

```sql
SELECT
P.상품코드, MIN(P.상품명) 상품명, MIN(P.상품가격) 사품가격
, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
FROM 주문상품 O, 상품 P
WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
AND O.할인유형코드 = 'K890'
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  SORT ORDER BY
--    HASH GROUP BY
--      NESTED LOOPS
--        NESTED LOOPS
--          PARTITION RANGE
--            TABLE ACCESS BY INDEX ROWID OF 주문상품
--              INDEX RANGE SCAN OF 주문상품_x1
--            INDEX UNIQUE SCAN OF 상품_PK
--         TABLE ACCESS BY INDEX ROWID OF 상품

-- 주문상품은 월 단위 파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 20%(20만건)
-- 등록된 상품 = 2만개
-- 할인유형코드 = K890 조건으로 판매되는 상품은 100여개

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드


SELECT /*+*/
P.상품코드, P.상품명, P.상품가격
, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
FROM
(
  -- group by 후 100건
  SELECT /*+FULL(A) NO_MERGE*/
  상품코드, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
  FROM 주문상품 A
  WHERE 주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND 할인유형코드 = 'K890'
) O
, 상품 P
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 DESC, 상품코드
```

한 달 주문상품 100만건 중 할인유형코드 = 'K890' 조건을 만족하는 데이터는 20만 건이다. 주문 상품은 월 단위 파티션 테이블로 인덱스로 20만 건을 랜덤 엑세스하는 것 보다 FULl SCAN이 유리하다.

2만 개 상품 중 할인유형 코드 조건으로 판매되는 상품은 100여 개 이므로 GROUP BY 결과 집합도 100여 건이다.

상품당 주문상품은 평균 2000건 이므로 GROUP BY를 먼저 처리하면 조인 횟수가 많이 감소한다.

GROUP BY 결과 집합은 100건이고 상품은 2만 개 이므로 해시조인보다 NL조인이 효과적이다.
조인 기준 집합이 소량이고, 같은 상품코드를 여러번 조인하지 않기 때문이다.

해시조인으로 처리하면 할인유형코드에 해당하는 상품이 100여개 인데 2만개 상품을 모두 PGA에 적재하는 비효율이 있다.

NL 조이는 출력 순서를 보장하지만 전체범위 처리이므로 굳이 ORDER BY를 인라인 뷰에서 처리할 이유가 없다. Orderby 가 없는 인라인 뷰는 옵티마이저에 의해 MERGING 될 수 있으므로 정확한 실행계획을 위해 NO_MERGE힌트가 필요하다.

```sql

SELECT /*+LEADING(O) USE_NL(P*/
P.상품코드, P.상품명 상품명, P.상품가격 상품가격
O.총주문수량, O.총주문금액
FROM
(
  select /*+FULL(A) NO_MERGE*/
  SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
  from 주문상품 O
  WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND O.할인유형코드 = 'K890'
  GROUP BY O.상품코드
)
WHERE P.상품코드 = O.상품코드
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  SORT ORDER BY
--    NESTED LOOPS
--      NESTED LOOPS
--        VIEW
--          HASH GROUP BY
--            PARTITION RANGE
--              TABLE ACCESS FULL OF 주문상품
--        INDEX UNIQUE SCAN OF 상품_PK
--       TABLE ACCESS FULL OF 주문

```

50. 쿼리튜닝

```sql

SELECT 상품코드, 상품, 상품가격, 총주문수량, 총주문금액
FROM
(
SELECT
P.상품코드, MIN(P.상품명) 상품명, MIN(P.상품가격) 사품가격
, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
FROM 주문상품 O, 상품 P
WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
AND O.할인유형코드 = 'K890'
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 DESC, 상품코드
)
WHERE ROWNUM <= 100

-- EXECUTION PLAN
-- SELECT STATEMENT
--  COUNT(STOPKEY)
--    VIEW
--      SORT ORDER BY
--        HASH GROUP BY
--          NESTED LOOPS
--            NESTED LOOPS
--              PARTITION RANGE
--                TABLE ACCESS BY INDEX ROWID OF 주문상품
--                  INDEX RANGE SCAN OF 주문상품_x1
--                INDEX UNIQUE SCAN OF 상품_PK
--            TABLE ACCESS BY INDEX ROWID OF 상품

-- 주문상품은 월 단위 파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 20%(20만건)
-- 등록된 상품 = 2만개
-- 대부분 상품을한 달에 한 개 이상 주문

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드


  SELECT /*+leading(P) USE_NL(O)+*/
  P.상품코드, P.상품명, P.상품가격, O.총주문수량, O.총주문금액
  FROM
  (
    SELECT /*+FULL(A)*/
    상품코드, SUM(주문수량) AS 총주문수량, SUM(주문금액) AS 총주문금액
    FROM 주문상품 A
    WHERE 주문일시 >= ADD_MONTHS(SYSDATE, -1)
    AND O.할인유형코드 = 'K890'
    GROUP BY 상품코드
    ORDER BY 총주문금액 DESC, 상품코드
  ) O, 상품 P
  WHERE P.상품코드 = O.상품코드
  AND ROWNUM <= 100
  ORDER BY 총주문금액 DESC, 상품코드

```

한 달 주문상품 100만 중 할인유형코드 조건을 만족하는 데이터는 20만 건이다.

주문 상품은 월 단위 파티션 테이블 이므로 인덱스로 20만 건을 랜덤 액세스 하는 것 보다 full scan이 유리하다.

2만개의 상품을 한 달에 한 개 이상 주문하므로 GROUP BY 결과 집합은 2만여 건이다.

상품코드당 주문상품은 평균 10건이므로 주문상품을 GROUP BY 한 후 조인하면 조인 횟수를 1/10으로 줄일수 있다.

```sql

SELECT
P.상품코드, MIN(P.상품명) 상품명, MIN(P.상품가격) 사품가격
, SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
FROM 주문상품 O, 상품 P
WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
AND O.할인유형코드 = 'K890'
AND P.상품코드 = O.상품코드
GROUP BY P.상품코드
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--  SORT ORDER BY
--    COUNT(STOPKEY)
--      NESTED LOOPS
--        NESTED LOOPS
--          VIEW
--            SORT ORDER BY
--              HASH GROUP BY
--                PARTITION RANGE
--                  TABLE ACCESS BY INDEX ROWID OF 주문상품
--           INDEX UNIQUE SCAN OF 상품_PK
--         TABLE ACCESS BY INDEX ROWID OF 상품

-- 주문상품은 월 단위 파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 20%(20만건)
-- 등록된 상품 = 2만개
-- 대부분 상품을 한달에 한 개 이상 주문

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드
```

총주문금액 내림차순, 상품코드 오름차순으로 정렬한 2만여 개 결과집합 중 상위 100개 만 출출해야 하므로 ORDER BY는 인라인 뷰 안에 기술해야 한다.

등록된 2만 개 상품 중 100개만 조인해야하므로 해시조인보다 NL 조인이 효과적이다.

ORDER BY 가 있는 인라인뷰는 옵티마이저에 의해 MERGING 될 수 없으므로 NO_MEGE 힌트는 불필요하다.

인라인 뷰에서 정렬한 결과집합 중 100 건을 출력했는데 NL 조인 과정에서 배치 i/O가 작동하면 출력 순서가 흐트러질 수 있으므로 정렬 기준을 바깥에 한 번 더 명시해야 한다.

인라인 뷰 바깥에 ORDER BY 를 기술하지 않으려면 NO_NLJ_BATCHING 힌트를 추가하면 된다.

```sql

SELECT /*+LEADING(O) USE_NL(P) */
P.상품코드, P.상품, P.상품가격, O.총주문수량, O.총주문금액
FROM
(
  select /*+FULL(A)*/
  SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
  from 주문상품 O
  WHERE O.주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND O.할인유형코드 = 'K890'
  GROUP BY O.상품코드
  ORDER BY 총주문금액 DESC, 상품코드
) o, 상품 P
where P.상품코드 = O.상품코드
AND ROWNUM <= 100
ORDER BY 총주문금액 DESC, 상품코드

-- EXECUTION PLAN
-- SELECT STATEMENT
--    COUNT(STOPKEY)
--      TABLE ACCESS BY INDEX RWID OF 상품
--        NESTED LOOPS
--          VIEW
--            SORT
--              HASH GROUP BY
--                PARTITION RANGE
--                  TABLE ACCESS FULL OF 주문상품
--        INDEX UNIQUE SCAN OF 상품_PK

```

51. SQL 튜닝

```sql
-- 결과집합을 일부(보통 상위 100개)만 출력하고 멈추는 애플리케이션 환경

select p.상품코드, min(p.상품명) 상품명, min(p.등록일시) 등록일시
, min(p.상품가격) 상품가격, min(p.공급자id) 공급자id
, sum(o.주문수량) 총주문수량, sum(o.주문금액) 총주문금액
from 주문상품 o, 상품 p
where o.주문일시 >= add_months(sysdate, -1)
and o.할인유형코드 = 'K890'
and  P.상품코드 = O.상품코드
group by p.상품코드
order by P.등록일시 desc

--- EXECUTION PLAN
-- SELECT STATEMENT
--    SORT ORDER BY
--      HASH GROUP BY
--        NESTED LOOPS
--          TABLE ACCESS BY INDEX ROWID 주문상품
--            INDEX RANGE SCAN of 주문상품_x1
--          INDEX UNIQUE SCAN OF 상품_PK
--        TABLE ACCESS BY INDEX ROWID OF 상품


-- 주문상품은 비파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 10%(10만건)
-- 등록된 상품 = 50만개 / 속성 500개
-- 대부분 상품을 한달에 한 개 이상 주문

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 상품_X1 : 등록일시 생성
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드
-- 주문상품_X1 : 할인유형코드 + 상품코드 + 주문일시 으로 변경

SELECT /*+LEADING(P) USE_NL(o) INDEX_DESC(P 상품_X1) */
P.상품코드, P.상품, P.상품가격, O.총주문수량, O.총주문금액
FROM
(
  select /*+index(A 주문상품_X1) no_merge push_pred*/
  SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액
  from 주문상품 A
  WHERE 주문일시 >= ADD_MONTHS(SYSDATE, -1)
  AND 할인유형코드 = 'K890'
  GROUP BY 상품코드
) o, 상품 P
where P.상품코드 = O.상품코드

--- EXECUTION PLAN
-- SELECT STATEMENT
--        NESTED LOOPS
--          INDEX UNIQUE SCAN OF 상품_PK
--            TABLE ACCESS BY INDEX ROWID OF 상품
--          NEW PUSHED PREDICATE
--            FILTER
--              SORT(AGGREGATE)
--                TABLE ACCESS BY INDEX ROWID 주문상품
--                  INDEX RANGE SCAN of 주문상품_x1

```

결과집합 일부만 출력하고 멈춘다는 건 부분범위 처리 가능함을 의미한다.

부분범위 처리를 활용하려면 소트연산을 생략할 수 있어야한다. (전체를 데이터를 정렬하지 않아도 정렬이 돼있어야한다)

소트 연산을 생략하고 상품테이블의 등록일시 컬럼 기준 역순으로 정렬된 결과집합을 빠르게 출력하려면,

등록일시가 선두인 상품 인덱스를 역순으로 스캔하면서 주문상품 GROUP BY 집합과 NL조인하면 된다.

반드시 JOIN PREDICATE PUSHDOWN 기능이 작동해야 한다. 따라서 의도대로 정확히 실행되게 하려면 NO_MERGE , PUSH_PRED 힌트를 사용해야 한다.

52. sql 튜닝

```sql
-- 결과집합을 일부(보통 상위 100개)만 출력하고 멈추는 애플리케이션 환경

select p.상품코드, min(p.상품명) 상품명, min(p.등록일시) 등록일시
, min(p.상품가격) 상품가격, min(p.공급자id) 공급자id
, sum(o.주문수량) 총주문수량, sum(o.주문금액) 총주문금액
from 주문상품 o, 상품 p
where o.주문일시 >= add_months(sysdate, -1)
and o.할인유형코드 = 'K890'
and  P.상품코드 = O.상품코드
group by p.상품코드
order by 등록일시 desc

--- EXECUTION PLAN
-- SELECT STATEMENT
--    SORT ORDER BY
--      HASH GROUP BY
--        NESTED LOOPS
--          TABLE ACCESS BY INDEX ROWID 주문상품
--            INDEX RANGE SCAN of 주문상품_x1
--          INDEX UNIQUE SCAN OF 상품_PK
--        TABLE ACCESS BY INDEX ROWID OF 상품


-- 주문상품은 월 단위 파티션 테이블
-- 한 달 주문상품 100만 건
-- 주문 상품의 보관 기간 = 10년
-- 주문상품 총 건수 = 총 1억 2천만 건
-- 할인유형코드 조건을 만족하는 주문상품 데이터 비중 10%(10만건)
-- 등록된 상품 = 50만개 / 속성 500개
-- 할인유형코드 = "K890" 조건으로 판매되는 상품은 5000개

-- 인덱스 구성
-- 상품_PK : 상품코드
-- 주문상품_PK : 고객번호 + 상품코드 + 주문일시
-- 주문상품_X1 : 주문일시 + 할인유형코드

SELECT  /*+LEADING(P) USE_NL(O) INDEX_DESC(O 상품_X1)*/
p.상품코드, p.상품명, p.등록일시, p.상품가격, p.공급자id
o.총주문수량, o.총주문금액
FROM (
  select /*+no_merge push_pred INDEX(주문상품 주문상품_X2)*/
  상품코드, sum(주문수량) 총주문수량, sum(주문금액) 총주문금액
  from 주문상품
  where  주문일시 >= add_months(sysdate, -1)
  and o.할인유형코드 = 'K890'
  group by 상품코드
) o, 상품 p
WHERE P.상품코드 = O.상품코드
order by 등록일시 desc

```

부분범위 처리를 활용하려면 등록일시 인덱스를 역순으로 스캔하면서 주문상품 GROUP BY 집합을 Join Predecate Pushdown 방식으로 NL 조인해야한다.

문제는 상품 기준으로 주문상품과 조인하면 첫 번째 fetch call으 위한 array를 채우기 까지 상당히 많은 데이터를 읽어야 한다는 데 있다.

할인유형코드 k890 조건을 만족하는 데이터는 5000개이므로 나머지 495000개는 조인에 실패하기 때문이다.

상위 100개 상품을 출력하려면 대략 10,000개의 상품을 스캔하면서 주문상품과 조인하고 조건절을 필터링해야하므로 빠른 응답속도를 얻기 힘들다.

정렬기준이 상품의 등록일시인 상황에서 주문상품을 먼저 읽어 GROUP BY 후 조인하면 정렬을 생략할 수 없기 때문에 부분범위 처리가 불가능하다.

```sql
SELECT  /*+LEADING(O) USE_NL(p)*/
p.상품코드, p.상품명, p.등록일시, p.상품가격, p.공급자id
o.총주문수량, o.총주문금액
FROM (
  select /*+no_merge */
  상품코드, sum(주문수량) 총주문수량, sum(주문금액) 총주문금액
  from 주문상품
  where  주문일시 >= add_months(sysdate, -1)
  and o.할인유형코드 = 'K890'
  group by 상품코드
) o, 상품 p
WHERE P.상품코드 = O.상품코드
order by 등록일시 desc

```

20만 개 상품 중 할인유형코드 = 'K890' 조건으로 판매되는 상품은 5000개 이므로 group by 결과집합도 5000건이다. GROUP BY 후 NL 조인하면 50만개 중 5000개 상품만 인덱스로 읽어 조인하면되지만 느리다.

GROUP BY 후 해시 조인하면, 50만 개 상품을 모두 해시 맵에 올린 후 해시 맵을 5000번 탑색한다.(상품 : build input , 주문상품 : probe input)

PGA에서 탐색하므로 조인 과정의 성능은 해시 조인이 우세하지만, 상품 테이블에 컬럼이 많으므로 해시 맵 생성을 위해 FULL SCAN 하는 과정에서 블록 I/O가 많이 발생한다. 가용 PGA 공간이 가득차면 그로 인한 성능 저하를 검수해야 한다.

상품 인덱스를 등록일시 + 상품코드 또는 상품코드 + 등록일시 순으로 구성하고
인라인 뷰 내에서 인덱스만 읽어서 해시 조인하면 정렬 기준인 등록일시를 빠르게 얻을 수 있다.

상품코드로 GROUP BY 하고 등록일시로 ORDER BY 까지 끝낸 집합을 기준으로 인덱스로 NL 조인하면 앞쪽 일부 상품만 읽으면 되기 때문에 효과적이다.

```sql

SELECT /*+LEADING(O) USE_NL(P) NO_NLJ_BATCHING(P)*/
P.상품코드, P.상품명, B.등록일시, P.상품가격, P.공급자ID
,O.총주문수량, O.총주문금액
FROM
(
  select /*+FULL(A) INDEX_FFS(B) LEADING(B) USE_HASH(A)*/
  a.상품코드, min(b.등록일시) 등록일시
  , sum(a.주문수량) 총주문수량, sum(a.주문금액) 총주문금액
  from 주문상품 a, 상품 b
  where  a.주문일시 >= add_months(sysdate, -1)
  and a.할인유형코드 = 'K890'
  and b.상품코드 = a.상품코드
  group by a.상품코드
  order by 등록일시 desc
) O, 상품 P
where P.상품코드 = O.상품코드

--EXECUTION PLAN

-- SELECT STATMENT
--   TABLE ACCSS BY INDEX ROWID of 상품
--     NESTED LOOPS
--       VIEW
--         SORT ORDER BY
--         HASH GROUP BY
--             HASH JOIN
--               INDEX FAST FULL SCAN OF 상품_X1
--               PARTITION RANGE (ITERATOR)
--                 TABLE ACCESS FULL OF 주문상품
--       INDEX UNIQUE SCAN OF 상품_PK
```

ORDER BY 가 있는 인라인 뷰는 옵티마이저에 의해 merging 될 수 없으므로 no_merge 힌트는 불필요하다. NL 조인 과정에서 배치 I/O가 작동하면 출력 순서가 흐트러질 수 있으므로 nO_NLJ_BATCHING 힌트를 추가해야 한다.

인라인 뷰에서 상품\_x1 인덱스와 해시 조인할 때 rowid를 읽어서 상품 테이블과 다시 조인할 때 사용하는 방법도 있다.

```sql

SELECT /*+LEADING(O) USE_NL(P)*/
P.상품코드, P.상품명, B.등록일시, P.상품가격, P.공급자ID
,O.총주문수량, O.총주문금액
FROM
(
  select /*+FULL(A) INDEX_FFS(B) LEADING(B) USE_HASH(A)*/
  a.상품코드, min(b.등록일시) 등록일시, MIN(B.ROWID) RID
  , sum(a.주문수량) 총주문수량, sum(a.주문금액) 총주문금액
  from 주문상품 a, 상품 b
  where  a.주문일시 >= add_months(sysdate, -1)
  and a.할인유형코드 = 'K890'
  and b.상품코드 = a.상품코드
  group by a.상품코드
  order by 등록일시 desc
) O, 상품 P
where P.ROWID = O.RID

-- 인덱스 재구성
-- 상품_x1 : 등록일시 + 상품코드
-- 주문상품_X1 : 할인유형코드 + 주문일시

-- EXECUTION PLAN

-- SELECT STATMENT
--     NESTED LOOPS
--       VIEW
--         SORT ORDER BY
--         HASH GROUP BY
--             HASH JOIN
--               INDEX FAST FULL SCAN OF 상품_X1 50만건
--               PARTITION RANGE (ITERATOR)
--                 TABLE ACCESS FULL OF 주문상품
--       TABLE ACCESS BY USER ROWID OF 상품

```

53. 베타적테이블조인

```sql
-- 작업자 id = 'Z123456' 가 최근 한 달간 방문해서 처리한 작업 지시 중 실제방문이자를 역순으로 최근 10건만 ㅊㄹ력하는 sql

-- 작업지시_x1 : 작업자ID + 실제방문일자

SELECT 작업일련번호, 실제방문일자, 접수구분, 고객번호, 주소
FROM (
  SELECT /*+INDEX_DESC(a 작업지시_X1)*/
  a.작업일련번호, a.실제방문일자
  , nvl2(b.개통접수번호, '개통', '장애') 접수구분
  , nvl2(b.개통접수번호, b.고객번호, c.고객번호) 고객번호
  , nvl2(b.개통접수번호, b.주소, c.주소) 주소
  FROM 작업지시 a, 개통접수 b, 장애접수 c
  WHERE a.작업자ID = :작업자id
  AND a.실제방문일자 >= trunc(ADD_MONTHS(sysdate, -1))
  AND b.개통접수번호(+) = a.개통접수번호
  AND c.장애접수번호(+) = a.장애접수번호
  Order by  실제방문일자 desc
)
WHERE ROWID < 10;
```

특정 작업자가 최근 한달간 방문해서 처리한 작업지시 중 실제방문일자 역순으로 최근 10건만 출력하는 sql이다. 최적 인덱스 구성은 작업자id + 실제방문일자 이다

```sql
select *
from (
  select 작업일련번호, 실제방문일자
  from 작업지시
  where 작업자id = :작업자id
  and 실제방문일자 >= trunc(add_month(sysdate, -1))
  order by 실제방문일자 desc
)
where rownum <= 10
```

고객번호와 주소정보는 개통접수 또는 장애 접수 테이블에서 읽어야 하는데,
제시한 발생규칙은 작업자가 나머지 두 테이블과 베타적 관계임을 설명하고 이싸.
따라서 두 테이블을 outer 조인해서 선택적으로 값을 읽어야 한다.

접수구분은 작업지시의 개통접수번호와 장애접수번호 중 어느 쪽에 값이 입력됐는지 여부에 따라 구분해도 되고 어느 테이블과 저인에 성공했는지 여부에 따라 구분해도 된다.

전체 범위를 읽어야하는 경우 원 테이블을 조건에 맞게 먼저 10건 읽은 후 조인하는 것이 좋다.

54. 베타적 테이블 조인

```sql
 SELECT /*+INDEX(a 작업지시_X1)*/
  a.작업일련번호, a.실제방문일자, a.작업자id
  , '개통' as 작업구분
  , b.고객번호
  , b.주소
 FROM 작업지시 a, 개통접수 b
 WHERE a.작업구분코드 = 'A'
 AND a.방문예정일자 = to_char(sysdate, 'yyyymmdd')
 UNION ALL
 SELECT /*+INDEX(a 작업지시_X1)*/
  a.작업일련번호, a.실제방문일자, a.작업자id
  , '장애'  as 작업구분
  , b.고객번호
  , b.주소
 FROM 작업지시 a, 장애접수 b
 WHERE a.작업구분코드 = 'B'
 AND a.방문예정일자 = to_char(sysdate, 'yyyymmdd')
```

데이터를 모두 출력해야 하므로 부분범위 처리를 활용한 튜닝 기법은 고려할 필요가 없다.
데이터 모델은 작업지시가 나머지 두 테이블과 베타저인 관계임을 나타내고 있다.

작업구부코드에 따라 개통접수 테이블과, 장애테이블과 각각 관계를 갖고 있다.

작업지시\_x1 인덱스가 작업구분코드 + 방문예정일자 순으로 구성돼 있으므로 개통건가 정애건을 각각 조회해서 union all로 결합했을때 발생하는 비효율은 업삳.

55. 배타적 테이블 조인

```sql
 SELECT
  a.작업일련번호, a.실제방문일자, a.작업자id
  , DECODE(A.작업구분코드 , 'A', '개통' , 'B', '장애') as 작업구분
  , DECODE(A.작업구분코드 , 'A', b.고객번호 , 'B', c.고객번호) as 고객번호
  , DECODE(A.작업구분코드 , 'A', b.주소 , 'B', c.주소) as 주소
 FROM 작업지시 a, 개통접수 b, 장애접수 c
 WHERE  a.방문예정일자 = to_char(sysdate, 'yyyymmdd')
 and b.개통접수번호(+) = decode(a.작업구분코드, 'A', a.접수번호)
 and b.개통접수번호(+) = decode(a.작업구분코드, 'B', a.접수번호)

```

작업지시는 나머지 두 테이블과 베타적 관계이다.
작업구분코드를 기준으로 Union all하면 작업지시\_X1 인덱스에서 방문예정일자 조건 을 두 번 스켄해야한다. 테이블 레코드도 각각 두 번 액세스한 후에 작업구분코드로 필터링해야 한다.

위 sql로 작성하면 작업지시\_x1 인덱스에서 방문예정일자를 한 번만 스캔하면된다.
작업구분코드 값에 따라 개통접수 또는 장애접수와 선택적으로 조인하므로 테이블 레코드도 한 번씩만 액세스하면된다.

데이터를 모두 출력해야 한다고 전제했으므로 부분범위 처리를 활용한 튜닝 기법은 고려할 필요가 없지만, sql을 이 방식으로 정의하면 부분범위처리가 가능한 장점도 있다.
예를 들어 접수번호로 정렬한 결과집합에서 앞쪽 부만 읽고 멈출 수 있는 상황이라면,
인덱스를 방문예정일자 + 접수번호 순으로 구성해주면된다.

union all 로 작성한 경우 인덱스를 이용한 소트 생략이 불가능하므로 부분범위 처리도 불가능하다. 단 결과집합을 정렬하지 않는 부분범위 처리는 가능하다.

56. 베타적 테이블 조인

조회조건이 베타적 테이블에 있고 NL 조인으로 처리해야 유리한 소량의 결과집합이라면 UNION ALL 방식이 유리하다.개통접수 및 장애접수 테이블이 드라이빙이 되도록 조인순서를 유도하고 그에 따른 최적 인덱스를 구성한다.

```sql
-- 작업접수_x1 : 작업일련번호 + 작업구분코드
-- 개통접수_x1 : 개통접수일시
-- 장애접수_x1 : 장애접수번호 + 장애접수일시
 SELECT
  a.작업일련번호, a.실제방문일자, a.작업자id
  , '개통' as 작업구분
  , b.고객번호
  , b.주소
 FROM 개통접수 b, 작업지시 a
 WHERE b.개통접수일시 >= trunc(sysdate)
 and b.개통접수일시 < trunc(sysdate + 1)
 and a.작업구분코드 = 'A'
 and a.접수번호 = b.개통접수번호
 UNION ALL
 SELECT
  a.작업일련번호, a.실제방문일자, a.작업자id
  , '장애'  as 작업구분
  , b.고객번호
  , b.주소
 FROM 작업지시 a, 장애접수 b
 WHERE b.장애접수일시 >= trunc(sysdate)
 and b.개통접수일시 < trunc(sysdate + 1)
 and  a.작업구분코드 = 'B'
 and a.접수번호 = b.장애접수번호
```

57. 점이력 쿼리작성

```sql
-- 장비_PK : 장비번호
-- 장비_x1 : 장비구분코드
-- 상태변경이력_pk : 장비번호 + 변경일자 + 변경순번

-- 장비구분코드 = 'A001' 인 장비는 10건
-- 결과집합을 장비번호 순으로 정렬

select /*+leading(a b) use_nl(b) index(a 장비_x1)*/
최종상태코드, 변경일자,변경순번
from 장비 a,
(
  select /*+no_merge push_pred*/
   장비번호
  , 상태코드
  , 변경일자
  , 변경순번
  from (
    select 장비번호, 상태코드, 변경일자, 변경순번 , ROW_NUMBER() OVER (PARTITION BY 장비번호 ORDER BY 변경일자 DESC ) as rm
    from 상태변경이력
  )
  where rm = 1
) b
where
a.장비구분코드 = 'A001'
and
b.장비번호 = a.장비번호
order by a.장비번호
```

```sql
select p.장비번호, p.장비명, h.상태코드 as 최종상태코드
, h.변경일자 as 최종변경일자, h.변경순번 as 최종변경순번
from 장비 p, 상태변경이력 h
where p.장비구분코드 = 'A001'
and h.장비번호 = p.장비번호
and (h.변경일자, h.변경순번) =
(
  select 변경일자, 변경순번
  from (
    select 장비번호, 변경일자, 변경순번
    from 상태변경이력
    order by 변경일자 desc, 변경순번 desc
  )
  where 장비번호 = p.장비번호
  and rownum < 1
)
order by p.장비번호

-- execution plan
-- select statement
--   sort
--     nested loops
--       nested loops
--         table access by index rowid of 장비
--           index range scan of 장비_x1
--         index unique scan of 상태변경이력_pk
--           count stopkey
--             view
--               index range scan descending of 상태변경이력_pk
--       table access by index rowid of 상태변경이력
```

rowid를 이용한 아래 답은 상태변경이력\_pk 인덱스를 한 번만 액세스 한다.

힌트를 사용하지 않았지만, order by 조건에 따라 인덱스를 역순으로 스캔한다.
order by를 생략학 index_desc 힌트를 명시하면 sql은 좀 더 단순해지지만,
혹시라도 인덱스 구성이 변경되면 결과집합에 오류가 발생할 수 있다.

```sql
select p.장비번호, p.장비명, h.상태코드 as 최종상태코드
, h.변경일자 as 최종변경일자, h.변경순번 as 최종변경순번
from 장비 p, 상태변경이력 h
where p.장비구분코드 = 'A001'
and h.rowid = (
  select /*+index_desc(h 상태변경이력_pk)*/ rowid
  from 상태변경이력 h
  where 장비번호 = p.장비번호
  and rownum <= 1
)
order by p.장비번호

-- select statement
--   sort order by
--     nested loops
--       table access by index rowid of 장비
--         INDEX RANGE SCAN OF 장비_x1
--       table access by user rowid of 상태변경이력
--         count stopkey
--           index range scan descending of 상태변경이력_pk
```

58. 점이력 쿼리작성

```sql
-- 장비구분코드가 A001인 장비의 최종상태코드와 직전일(상태변경이력의 변경일자가 장비의 최종상태변경일자보다 작은) 마지막 상태코드, 변경일자, 변경순번을 출력

-- 장비_PK : 장비번호
-- 장비_x1 : 장비구분코드
-- 상태변경이력_pk : 장비번호 + 변경일자 + 변경순번

-- 장비구분코드 = 'A001' 인 장비는 10건
-- 결과집합을 장비번호 순으로 정렬

select
p.장비번호, p.최종상태코드
from 장비 p, 상태변경이력 h
where p.장비구분코드 = 'A001'
and h.장비번호 = p.장비번호
and (h.변경일자, h.변경순번) =
(
    select 변경일자, 변경순번
    from (
      select 장비번호, 변경일자, 변경순번
      from 상태변경이력
      order by 변경일자 desc, 변경순번 desc
    )
    where 장비번호 = p.장비번호
    and 변경일자 < p.최종상태변경일자
    and rownum <= 1
)
order by p.장비번호 DESC

-- execution plan
-- select statement
--   sort
--     nested loops
--       nested loops
--         table access by index rowid of 장비
--           index range scan of 장비_x1
--         index unique scan of 상태변경이력_pk
--           count stopkey
--             view
--               index range scan descending of 상태변경이력_pk
--       table access by index rowid of 상태변경이력
```

59. 선분이력 쿼리작성

```sql
-- 장비구분코드가 A001인 장비의 최종상태코드와 변경일자를 출력하는 쿼리 작성

-- 장비_PK : 장비번호
-- 장비_x1 : 장비구분코드
-- 상태변경이력_pk : 장비번호 + 유효종료일시, 유효시작일시

-- 장비구분코드 = 'A001' 인 장비는 10건
-- 결과집합을 장비번호 순으로 정렬
-- 상태변경이력은 선분이력 테이블
-- 장비 테이블의 최종변경일시와 상태변경이력의 유효시작일시, 유효종료일시는 DATE형

select
p.장비번호, p.장비명, h.최종상태코드, to_char(h.유효시작일시, 'YYYYMMDD')
from 장비 p, 상태변경이력 h
where p.장비구분코드 = 'A001'
and h.장비번호 = p.장비번호
and (h.유효시작일시, h.유효종료일시) =
(
    select 변경일자, 변경순번
    from (
      select 장비번호, 유효시작일시, 유효종료일시, 상태코드
      from 상태변경이력
      order by 유효종료일시 desc, 유효시작일시 desc
    )
    where 장비번호 = p.장비번호
    and rownum <= 1
)
order by p.장비번호 DESC
```

상태변경이력은 선분이력 모델이력이다. 즉, 변경이 발생한 시점뿐만 아니라 해당 이력이 유효했던
종료 시점을 같이 관리하는 방식이다. 이 모델의 장점은 무엇보다 쿼리가 단순하다는데 있다.
쿼리가 단순해지면 성능도 좋아진다.

선분이력에서 최종(현재) 데이터를 조회할 때는 아래와 같이 Between 조건을 사용한다.

WHERE SYSDATE BETWEEN 유효시작일시 AND 유효종료일시

BETWEEN 조건을 분해하면 아래와 같다.

WHERE 유효시작일시 <= SYSDATE
AND 유효종료일시 >= SYSDATE

선분이력에서 최종 데이터으 ㅣ유효종료일시에는 9999년 12월 31일 23시 59분 59초를 입력하므로 아래와 같이
= 조건절을 사용할 수도 있다.

WHERE 유효종료일시 = TO_DATE('99991231 235959', 'YYYYMMDD HHH24MISS')

```SQL
select
p.장비번호, p.장비명, h.최종상태코드, to_char(h.유효시작일시, 'YYYYMMDD') AS 최종상태변경일자
from 장비 p, 상태변경이력 h
where p.장비구분코드 = 'A001'
and h.장비번호 = p.장비번호
and h.유효시작일시 <= sysdate
and h.유효종료일시 >= sysdate
order by p.장비번호 DESC

-- execution plan

select statement
  sort order by
    nested loops
      nested loops
        table access by index rowid of 장비
          index range scan of 장비_x1
        index range scan of 상태변경선분이력_pk
      table access by index rowid of 상태변경선분이력
```

60. 선분이력 쿼리작성

```sql
-- 장비구분코드가 A001인 장비의 최종상태코드와 변경일자, 직전(상태변경이력의 유효시작일시가 장비의 최종상태변경일시보다 작은)
-- 상태변경의 상태코드와 변경일잘르 출력하는 sql작성

-- 장비_PK : 장비번호
-- 장비_x1 : 장비구분코드
-- 상태변경이력_pk : 장비번호 + 유효종료일시, 유효시작일시

-- 장비구분코드 = 'A001' 인 장비는 10건
-- 결과집합을 장비번호 순으로 정렬
-- 장비테이블의 최종상태변경일시는 상태코드를 가장 마지막으로 변경한 일시
-- 상태변경이력은 선분이력 테이블
-- 장비 테이블의 최종변경일시와 상태변경이력의 유효시작일시, 유효종료일시는 DATE형

SELECT P.장비번호, p.장비명, p.최종상태코드
, to_char(p.최종상태변경일시, 'yyyymmdd')
, h.상태코드 직전상태코드
, to_char(h.유효종료일시, 'yyyymmdd')
FROM 장비 P, 상태변경이력 h
WHERE p.장비구분코드 = 'A001'
and p.장비번호 = H.장비번호
and (h.상태코드,  h.유효종료일시) = (
  select 상태코드, 유효종료일시
  from (
    select 장비번호, 상태코드, 유효종료일시
    from 상태변경이력
  )
  where 장비번호 = p.장비번호
  and 유효종료일시 < p.최종상태변경일시
  and rownum <= 1
)
```

상태변경이력은 '선분이력' 모델이다. 변경이 발생한 시점뿐만 아니라 해당이력이 유효했던 종료 시점을 같이 관리하는 방식이다.
선분이력에서 현재가 아닌 특정 시점 이력을 조회할 때는 = 조건을 사용할 수 없으며 between 조건ㅇ르 사용해야한다.

본 문제에서는 직전이력, 즉 유효시작일시가 장비의 최종상태변경일시보다 작은 이력을 찾아야 하므로 조인 조건을 아래와 같이 작성한다.

```sql
SELECT P.장비번호, p.장비명, p.최종상태코드
, to_char(p.최종상태변경일시, 'yyyymmdd')
, h.상태코드 직전상태코드
, to_char(h.유효종료일시, 'yyyymmdd')
FROM 장비 P, 상태변경이력 h
WHERE p.장비구분코드 = 'A001'
and p.장비번호 = H.장비번호
AND H.유효시작일시 < p.최종상태변경일시
AND H.유효종료일시 >= p.최종상태변경일시 - 1 /(60*60*24)
```
