# INDEX 기본 원리

1. B\*Tree 인덱스 구조

a. 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다. => ROWID
b. 브랜치 블록 각 로우의 키 값은 하위 블록 첫 번째 로우의 키 값과 일치한다. =>
브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다. 따라서 하위 블록 첫 번째 로우의 키 값과 일치하지 않을 수 있다.
c. 리프 블록 각 로우의 키 값은 테이블 로우의 키 값과 일치한다.
d. 리프 블록은 이중연결리스트 구조다

---

- 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다.
- 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다.
- LMC는 다음 로우의 키 값보다 작은 키값으로 구성된 하위 블록과 연결된다.
- 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
- 리프 블록의 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다.
- 리프 블록의 각 로우와 테이블 로우의 관계는 1:1이다.
- 리프 블록끼리는 이중연결리스트 구조이다.

2. 인덱스 ROWID

INDEX ROWID = DBA(데이터 오브젝트 번호 + 데이터 파일번호 + 블록 번호) + 로우번호

---

테이블스페이스는 인덱스 ROWID 구성요소가 아니다.

3. B\*Tree 인덱스 탐색 순서

```sql
select count(*) from cust where age betweeen 40 and 60
```

1-2-6-7-8

---

수직적 탐색을 통해 시작지점을 찾는다. 수직적탐색과정에서 1,2,6번 블록을 엑세스한다.

6번 리프 블록에서 스캔을 시작해 8번 블록에서 60보다 큰 키 값을 만나면 수평탐색을 중단한다.

4. Oracle 인덱스 힌트

```sql
-- cust_pk : custno
-- cust_x1 : regdt, sex, custnm

select /*+*/ custnom sex, regdt, pnum
from cust C
where custnm = :cust_nm
and regdt between :ent_dt1 and :ent_Dt2

-- SELECT STATEMENT
--  TABLE ACCESS BY INDEX ROWID
--    INDEX RANGE SCAN OF CUST_X1
```

A. INDEX(C)
B. INDEX(C CUST_X1)
C. INDEX(C (REGDT))
d. INDEX (c(가입일자, 고객명)) => 가입일자, 고객명을 선두로 갖는 인덱스 액세스가 없으므로 무시된다.

---

힌트가 무시되도 옵티마이저에 의해 적합한 인덱스가 선택될 수도 있고 Table Full Scan이 선택될 수도 있다.

5. SQL Server 인덱스 힌트

고객\_PK 인덱스로 고객번호를 검색 하는 힌트를 지정하는 방법은 다음과 같다.

```sql
-- 고객_PK : 고객번호(클러스터형 인덱스)
-- 고객_x1 : 고객명(비클러스터형 인덱스)

DECLARE @CUST_NO INT

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX(고객_PK))
WHERE 고객번호 = @CUST_NO

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX = 고객_PK)
WHERE 고객번호 = @CUST_NO

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(FORCESEEK(고객_PK(고객번호)))
WHERE 고객번호 = @CUST_NO

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객
WHERE 고객번호 = @CUST_NO
OPTION (TABLE HINT( 고객, INDEX(고객_PK)))
```

WITH 절에 INDEX(1)을 지정하면 고객번호로 클러스터형 인덱스를 검색한다.
만약 WITH 절에 INEX(0)을 지정하면 클러스형 인덱슬르 SCAN하면서 고객번호로 필터링한다.

```sql
-- 고객_PK : 고객번호(클러스터형 인덱스)
-- 고객_x1 : 고객명(비클러스터형 인덱스)

--  WITH(INDEX(0))
--  0번 인덱스 = 클러스터드 인덱스 또는 테이블 전체 스캔을 의미
--  클러스터드 인덱스가 있는 테이블이라면 → 해당 클러스터드 인덱스를 사용.
--  클러스터드 인덱스가 없다면 → 테이블 전체 스캔(Heap Scan) 수행.

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX(0))
WHERE 고객번호 = @CUST_NO

--  WITH(INDEX(1))
-- 힌트 의미: 1번 인덱스를 강제로 사용하라는 뜻.
-- 클러스터드 인덱스가 있는 테이블이라면 → 해당 클러스터드 인덱스를 사용.
-- 클러스터드 인덱스가 없다면 → 구문에러

SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX(1))
WHERE 고객번호 = @CUST_NO
```

아래와 같이 FORCESCAN을 지정하면 고객번호로 검색하지 않고 FULL SCAN 하게하려면 다음과 같이 힌트를 지정한다.

```sql
DECLARE @CUST_NO INT
SELECT *
FROM 고객 WITH( FORCESCAN)
WHERE 고객번호 = @CUST_NO
```

6. SQL Server TABLE FULL SCAN 유도

고객명으로 FULL 스캔하도록 유도하는 방법은 다음과 같다.

```sql
-- 고객_PK : 고객번호(비클러스터형 인덱스)
-- 고객_x1 : 고객명(비클러스터형 인덱스)

DECLARE @CUST_NO VAHRCHAR(10)

-- A
-- 클러스터형 인덱스가 없는 상황에서 WITH INDEX(0)을 지정하면 TABLE FULL SCAN 한다.
SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX(0))
WHERE 고객명 = @CUST_NM

-- B
-- 고객_PK로 인덱스 UNIQUE 스캔한다.
SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(INDEX(고객_PK))
WHERE 고객명 = @CUST_NM

-- C
-- WITH(FORSCAN) 으로 TABLE FULL SCAN을 유도한다.
SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객 WITH(FORCESCAN)
WHERE 고객명 = @CUST_NM

-- D
-- 인덱스 컬럼을 가공하면 테이블을 FULL SCAN 한다.
SELECT 고객번호, 성별, 가입일자, 연락처
FROM 고객
WHERE CONCAT(고객명, '') = @CUST_NM

```

7. INDEX RANGE SCAN

a. B\*TREE 인덱스의 가장 일반적이고 정상적인 형태의 스캔 방식이다.

b. Index RANGE SCAN 하려면, 인덱스 선두 컬럼에 대한 등치 조건이 반드시 있어야 한다.

=> INDEX RANGE SCAN 하려면, WHERE 절에 인덱스 선두컬럼에 대한 조건이 반드시 있어야 하지만 등치 조건일 필요는 없다. 부등호, BETWEEN LIKE 모두 가능하다.

c. 인덱스 루트에서 리프 블록까지 수직 탐ㅋㅋ색한후 리프 블록을 수평 탐색하는 방식이다.
d. 수평 탐색 범위는 인덱스 구성, 조건절 연산자에 따라 달라진다.

8. INDEX FULL SCAN 유도

a. 결과집합을 모두 출력한다면, 인덱스 리프 블록을 처음부터 끝까지 모두 스캔하게 된다.

b. 인덱스를 FULL SCAN 하면서 테이블 데이터를 액세스하는 방식으로 전체 결과집합을 추출해야하는 상황이라면, 인덱스 필터 조건을 만족하는 데이터가 적을수록 효과적이다.

c. 인덱스를 FULL SCAN 하면서 테이블 데이터를 액세스 하는 방식으로 부분범위처리하는 상황이라면, 인덱스 필터 조건을 만족하는 데이터가 많을수록 효과적이다.

d. INDEX_FS 힌트로 유도한다.
=> 오라클은 INDEX_FS 힌트를 제공하지 않는다. INDEX 힌트로 지정된 인덱스 선두 컬럼이 조건절에 없으면 INDEX FULL SCAN이 자동 선택되므로 별도 힌트가 필요하지 않다.

9. 인덱스 구조에 따른 옵티마이저의 스캔방식

```sql
-- 주문일자 + 고객ID + 상품ID

SELECT 상품id, 주문수량, 주문가격, 할인률
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND 고개id = :cust_no
```

Unique 인덱스 구성 컬럼을 모두 = 조건으로 검색하면 INDEX UNIQUE SCAN 하지만, 전체가 아닌 일부 컬럼을 등치조건으로 검색할 때는 RANGE SCAN이 선택된다.

10. ORACLE INDEX FAST FULL SCAN

a.인덱스 리프블록만 빠르게 스캔하므로 인덱스 정렬 순서대로 결과집합을 출력한다.

=> 인덱스 리프 블록들은 물리적으로 여러 익스텐트에 흩어진 상태로 저장된다. 하지만, 정렬순서에 따라 이중연결리스트 방식으로 서로 연결돼 있으므로 순서대로 스캔하면 결과집합의 순서를 보장한다.

INDEX FAST FULL SCAN은 리프블록끼리의 논리적 연결 순서를 따르지 않고 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.

TABLE FULL SCAN 처럼 HWM 아래 익스텐트 전체를 MULTIBLOCK I/O 방식으로 FULL SCAN 하므로 결과집합의 순서가 보장되지 않는다.

b.Multoblock I/O 방식을 사용한다.
c.병렬스캔도 가능하다.
d.인덱스에 포함된 컬럼만으로 조회할 때 사용할 수 있다.

11. INDEX SKIP SCAN

a. 인덱스 선두 컬럼이 조건절에 없을 때 사용할 수 있는 스캔 방식
b. 조건절에 누락된 인덱스 선두 컬럼에 대한 IN 조건절을 옵티마이저가 추가해 줌으로써 List Iterator 방식으로 인덱스를 스캔하는 방식이다. =>
c.인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
d.index_ss 힌트로 유도한다.

12. 인덱스 구성에 따른 인덱스 스캔방식

```sql
alter table cust add constraint cust_pk primary key (custno);
create index cust_x01 on cust(grade, age);

select custno, custnm, regdate, grade, age, contract
from cust
where age between 20 and 40
order by custno
```

---

INDEX FULL SCAN, INDEX SKIP SKAN

13. 인덱스 구성에 따른 인덱스 스캔방식

```sql
alter table cust add constraint cust_pk primary key (custno);
create index cust_x01 on cust(age, custnm);

select custno, custnm, regdate, grade, age, contract
from cust
where age between 20 and 40
and custnm = 'hong'
order by custno
```

---

INDEX RANGE SCAN, INDEX FULL SCAN

14. 인덱스 구성에 따른 인덱스 스캔방식

```sql
-- cust_x01(region, sex, regdate)
-- cust_x02(grade, birthdate)

-- a
select * from cust
where regdt between '20210201' and '20210228'

-- b
select * from cust
where region = 'chungcheng'
and regdt between '20210201' and '20210228'

-- c
select * from cust
where grade in ('A', 'B', 'C')
and birthdt = '0326'

-- d
select * from cust
where grade between 'A' and 'C'
and birthdt = '0326'
```

15. B\*Tree 인덱스에서 생길 수 있는 구조 이상

a. unbalanced index
b. index skew
c. index spare
d. index fragmentaion

16. 대용 DW 환경에 적합한 인덱스

a. b\*tree index
b. bitmap index =>
c. function base index
d. reverse key index

17. 함수기반 인덱스

```sql
select from cust where replace(phonenum, '-' , '') = :PHONE_NO
```

18. 리버스 키 인덱스

특정 테이블을 동시에 insert 하는 다중 트랜잭션에 의해 인덱스 맨 우측 리프 블록에

경합이 발생하는 경우. SQL 수정없이 인덱스 블록 경합을 해소하는데 도움을 주는 인덱스 이다.

19. 인덱스를 이용한 테이블 랜덤엑세스를 줄이는 오라클 기능

a. 리버스 키 인덱스
b. IOT
c. 클러스터
d. 테이블 파티션 =>

20. IOT 의 용도

a.PK 이외에 일반속성이 없는 테이블
b.테이블에 데이터가 일자 순으로 저장되지만, 주로 사원번호로 월간 또는 연간 실적을 조회하는 영업실적 테이블
c. 한 달 이상의 넓은 범위로 조회하는 영업통계 테이블
d. 주로 고객번호로 조회하는 고객 테이블 =>

21. SQL Server 클러스터형 인덱스

a. 인덱스에서 테이블로의 랜덤 액세스 부하를 줄이는 용도로 개발
b. 클러스터형 인덱스를 생성하는 기준은 PK 컬럼이어야한다.
C. 클러스터형 인덱스는 한 개만 생성할 수 있다.
d. 클러스터형 인덱스를 생성하면, 다른 비클러스터형 인덱스는 자동 재구성된다.

22. INDEX RANGE SCAN

A. SELECT _ FROM COR WHERE CORNAME LIKE '%KOREA%'
B. SELECT _ FROM COR WHERE CORNAME NOT LIKE 'KOREA%' =>
C. SELECT _ FROM COR WHERE SUBSTR(CORNAME, 1,2) = 'KOREA'
A. SELECT _ FROM COR WHERE CORNAME = NVL(:VAL, 'KOREA')

23. 오라클에서 INDEX RANGE SCAN이 불가능한 경우

```sql
-- 사원번호  number not null
-- 사원명    varchar2(20) not null
-- 성별     varchar2(1) not null
-- 입사일자   DATE NOT NULL
-- 휴대폰번호 varchar2(12) not null
-- 집전화번호 varchar2(12) null
-- 부서번호  varchar2(4)  null
-- 관리자번호 NUMBER NULL
-- PK : 사원번호
-- 사원_X1(집전화번호, 사원명)
-- 사원_X2(관리자번호, 부서번호)

```

a. select \* from 사원 where 집전화번호 is null
b. select \* from 사원 where 집전화번호 is null and 부서번호 = 'Z123'
c. select \* from 사원 where 관리자번호 is null
d. select \* from 사원 where 관리자번호 is null and 부서번호 = 'Z123'

24. 오라클에서 INDEX RANGE SCAN이 가능한 경우

```sql
-- 계좌번호  number not null
-- 계좌명    varchar2(50) not null
-- 지점코드   varchar2(3) null
-- 계설일시   DATE NULL
-- 고객번호 NUMBER not null

-- PK : 계좌번호
-- 계좌_X1(지점코드, 개설일시)
-- 계좌_X2(개설일시, 고객번호)

```

a. select \* from 계좌 where 지점코드 = 100
b. select \* from 계좌 where 계좌번호 like :acnt_no || '%'
c. select \* from 계좌 where 지정코드 IS NULL;
d. select \* from 계좌 where 개설일시 IS NULL;
e. select \* from 계좌 where 계좌번호 WHERE 고객번호 = 123456;

25. INDEX RANGE SCAN이 가능한 경우

```sql
-- index : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

-- a
where
기준연도 = :stdr_year
and substr(과세구분코드, 1, 4) = :Txtn_dcd
and 실명확인번호 = :rnm_cnfm_no

-- b
where
과세구분코드 = :txtn_dcd
and 보고회차 = :rot
and 실명확인번호 = :rnm_cnfm_no

-- c
where
(:stdr_year is null or 기준연도 = :stdr_year)
and substr(과세구분코드, 1, 4) = :Txtn_dcd
and 보고회차 = :rot

-- d
select /*+no_expand*/ from txa1234
where 기준연도 not between stdr_year1 and :stdr_yeae2
and 과세구분코드 = :Txtn_dcd
and 보고회차 = :rpt_tmrd

```

26. INDEX RANGE SCAN

```sql
-- cust_pk : custno
-- cust_x1 : custnm + regdt
-- cust_x2 : phonnm

--a
select *
from cust
where custnm = :cust_nm or birthdt = :birthdt

--b
select *
from cust
where custnm = :cust_nm or regdt = :regdt

--c
select *
from cust
where (:opt = 'A' and custno = :custno)
or (:opt = 'B' and phoneno = :mobile_no)

--d
select *
from cust
where :cust_no is null or birthdt = :birthdt
```

27. index range scan이 불가능한 경우

```sql
select *
from Vender
where vender like '대한%'

select *
from emp
where monsal >= 3600000 / 12;

select *
from order
where 주문수량 >= decode(주문수량, null )

select *
from order
where 일시 = TO_DATE(TO_CHAR(:dt),'YYYYMMDD')

SELECT *
FROM 주문
WHERE FLOOR(할인율) <:dcrt;

```

28. INDEX RANGES SCAN이 가능한 경우

```sql
SELECT 주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 <> 3
AND 주문일자 BETWEEN :DT1 and :DT2

SELECT 주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
FROM 주문
WHERE 주문상태코드 IN (0,1,2,4,5)
AND 주문일자 BETWEEN :DT1 and :DT2
```

29. INDEX RANGE SCAN이 가능하도록 재작성

```sql
--월말계좌상태_PK : 계좌번호 + 계좌일련번호 + 기준년월
--월말계좌상태_X1 : 기준년월 + 상태구분코드

UPDATE 월별계좌상태 SET 상태구분코드 = '02'
WHERE 상태구분코드 <> '01'
AND 기준년월 = :BAST_DT
AND (계좌번호, 계좌일렵번호) IN (
  SELECT 계좌번호, 계좌일련번호
  FROM 계좌원장
  WHERE 개설일자 LIKE :STD_YN || '%'
)
```

30. INDEX RANGE SCAN이 가능하도록 재작성

```sql
-- PK : 지수구분코드 + 지수업종코드 + 거래일자
-- X! : 거래일자

SELECT 거래일자
, SUM(DECODE(지수구부코드, '1', 지수종가 , 0))
, SUM(DECODE(지수구부코드, '1', 누적거래량 , 0))
, SUM(DECODE(지수구부코드, '1', 지수종가 , 0))
, SUM(DECODE(지수구부코드, '1', 누적거래량 , 0))
FROM 일별지수업종별거래 A
WHERE 거래일자 BETWEEN :startDd AND : endDd
AND (지수구분코드, 지수업종코드) IN (('10','01'), ('20','03'))
ORDER BY 거래일자
```

31. SQL 튜닝

```sql
-- 주문일자 + 주문번호
SELECT NVL(MAX(주문번호 + 1), 1)
FROM 주문
WHERE 주문일자 = :주문일자

-- SELECT STATEMENT
--  SORT (AGGREATE)
--    INDEX RANGE SCAN OF 주문_PK
```

32. INDEX ROWID를 활용한 테이블 액세스

a. INDEX ROWID는 테이블 레코드에 대한 포인터로서 물리적으로 직접 연결된 구조다. => 논리적인 주소값을 담고 있다.
b. INDEX ROWID에 포함된 데이터 블록 주소는 데이터 파일 상의 블록 위치를 가리킨다.
c. 데이터블록 주소로 버퍼 캐시에서 블록을 찾을때 해시 알고리즘을 이용한다
d. 버퍼 캐시에서 블록을 찾는 과정에서 Latch, Buffer Lock 등 경합이 발생한다.

33. 인덱스 클러스터링 팩터

a. 인덱스 컬럼을 기준으로 같은 값을 같는 데이터가 서로 모여있는 정도를 의미
b. 통계정보의 일종으로 인덱스를 경유해 테이블 전체 로우를 액세스 할때 읽을 것으로 예상되는 논리적 블록 수를 미리 구해놓은 값이다. =>
c. 인덱스 성능은 클러스터링 팩터가 테이블 블록 수에 가까울수록 좋고, 테이블 레코드 수에 가까울수록 나쁘다.
d. 인덱스를 재설정하면 클러스링 팩터가 좋아진다.

34. 인덱스 손익분기점

a. 인덱스 크러스터링 팩터가 좋을수록 손익분기점은 높아진다.
b. multoblock i/o 단위가 클수록 손익분기점은 내려간다.
c. 데이터양이 늘수록 테이블 스캔 비용은 기하급수적으로 증가한다. =>
d. 일정량 이상의 데이터를 읽을 때 인덱스 효용이 낮은 이유는 인덱스를 이용한 테이블 액세스가 랜덤 방식인 데다 Single Block I/O로 읽기때문이다.

35. OLTP와 BATCH

a. OLTP 프로그램에서는 인덱스와 NL 조인의 활용성이 높다.
b. BATCH 프로그램에서는 Full Scan과 해시조인의 활용성이 높다.
c. 배치프로그램에서도 부분범위 처리를 잘 활용하면 처리 성능을 높일 수 있다. =>
d. 배치 프로그램에서는 파티션과병렬처리가 효과적이다.

36. 인덱스 구성변경

```sql
-- N2 : 서비스번호 + 사용여부
SELECT
FROM 로밍렌탈
WHERE 서비스번호 Like '010%'
AND 사용여부 = 'Y'
AND 자동로밍여부 = 'N'

--- TABLE ACCESS BY INDEX ROWID
--    INDEX RANGE SCAN 로밍렌탈_N2
```

자동로밍여부를 N2 인덱스에 추가해서 TABLE ACCESS에서 버려지는 ROWS의 수를 줄인다.

37. 테이블 랜덤 액세스가 많아서 느린 경우 튜닝고려방안

a. 인덱스에 컬럼을 추가하는 방안 검토
b. IOT 로 인덱스 구조 변경
c. 인덱스 재생성
d. 인덱스 순으로 정렬되도록 테이블 재생성 =>

38. 인덱스 뒤쪽에 컬럼을 추가할때 나타나는 현상

a. 인덱스 높이가 증가
b. 인덱스 사이즈가 증가
c. 인덱스 리프블록이 많아짐으로 스캔 과정에서 i/o 발생량 증가
d. 인덱스 클러스터링 팩터가 좋아짐 =>

39. BATCH I/O

a. 결과집합의 데이터 정렬 순서가 달라진다.
b. 테이블 랜덤 액세스 과정에서 발생하는 디스크 I/O 성능이 좋아진다.
c. 디스크 I/O가 발생하지 않는다면 성능에는 차이가 없다.
d. 부분범위처리가 불가능해진다 =>

40. BATCH I/O

a. 결과집합의 데이터 정렬순서가 달라진다.
b. 테이블 랜덤 액세스 과정에서 발생하는 디스크 I/O 성능이 좋아진다.
c. 버퍼캐시에서 읽는 블록수는 동일하다.
d. 부분범위처리가 불가능해진다 =>

### 3. 인덱스 스캔 효율화

41. 인덱스 스캔 비효율

a. 테이블 액세스로 10
b. 인덱스 스캔으로 100000, 테이블 액세스로 100 =>
c. 인덱스 스캔으로 10, 테이블 엑세스로 10
d. 인덱스 스캔으로 100000, 테이블 액세스로 100000

42. 인덱스 스캔 비효율

```sql
-- index : 상품유형코드 + 업체코드 + 상품코드 + 할인구분코드

-- a
WHERE 상품유형코드 Like :a || '%'
-- b
WHERE 상품유형코드 Like :a AND 업체코드 = :b
-- c
WHERE 상품유형코드 Like :a AND 상품코드 = :b AND 할인구분코드 =:c
-- d
WHERE 상품유형코드 Like :a || '%' AND 상품코드 LIKE :c || '%'

```

43. 효율적인 인덱스 튜닝 방안

```sql
-- 인덱스 구성 : 할인구분코드 + 상품코드 + 업체코드 + 상품유형코드

SELECT
FROM 상품공급
WHERE 상품유형코드 = 'A'
AND 업체코드 = 'Z956'
AND 상품코드 = 'A0113509056'
AND 할인구분코드 BETWEEN 'A' AND 'C'
ORDER BY 주문일자 DESC
```

1. INDEX SKIP 스캔으로 유도한다.
2. 할인구분코드 조건절을 AND 할인구분코드 ('A', 'B', 'C') 로 변경한다.

3. 인덱스 튜닝 방안

```sql
-- 데이터 분포
-- 월별로 100만개 레코드 저장
-- 총 10년치 데이터 보관
-- 판매구분코드가 'A'로 시작하는 데이터는 2%

-- 인덱스 구성
-- 월별고객별판매집계_IDX2 : 판매월 + 판매구분코드

SELECT COUNT(*)
FROM 월별고객별판매집계
WHERE 판매구분코드 LIKE 'A%'
AND 판매월 BETWEEN '202001' AND '202012'

-- 1      SORT AGGREGATE (cr= 300000 pr= 8589)
-- 240000 INDEX RANGE SCAN 월별고객별판매집계_IDX2 (cr= 300000 pr= 8589)
```

a. INDEX SKIP SCAN으로 유도한다.
b. 판매월 BETWEEN 조건을 IN-LIST로 변경한다.
c. 인덱스를 판매구분코드 + 판매월 순으로 변경한다.
d. 판매구분 관리 코드 테이블을 이용해 조건절을 변경한다.

where 판매구분코드 IN (SELECT 판매구분코드 FROM 판매구분 WHERE 판매구분코드 LIKE 'A'%)

45. INDEX SKIP SCAN 성능

```sql
-- index : 승인요청일자 + 승인요청자ID
SELECT CONUT(*)
FROM 승인요청
WHERE 승인요청일자 >= to_char(sysdate -6, 'yyyymmdd')
AND 승인요청자ID = :reqr_id;
```

날짜형:문자형 비교시 문자형이 날짜형으로 치환되므로 인덱스를 정상적으로 이용할 수 있다.

46. 엔터티 구성에 따른 효과적인 인덱스 도출

고객번호 + 주문일자 + 주문순번 + 상품ID

47. 효과적인 인덱스 튜닝방안

```sql
-- 고객별 가입상품은 평균 10개

SELECT
FROM 고객별가입상품
WHERE 상품ID IN ('NH37', 'NH41', 'NH50')
AND 고객번호 = 1234
```

인덱스를 고객번호 + 상품ID로 하고 상품Id는 필터방식으로 처리

```sql
-- index : 증서번호 + 투입인출구분코드 + 이체사유발생일자 + 거래코드

SELECT NVL((DECODE(투입인출구분코드 , 'G', A.기본이체금액, 0)  + (DECODE(투입인출구분코드 , 'G', A.정산이자, 0))) - (DECODE(투입인출구분코드 , 'S', B.기본이체금액, 0)  + (DECODE(투입인출구분코드 , 'S', B.정산이자, 0))), 0)
FROM
(
  SELECT
  FROM 거래
  WHERE 증서번호 = :증서번호
  AND 이체사유발생일자 <= :일자
  AND 거래코드 NOT IN('7411', '7412', ...)
  AND 투입인출구분코드 IN ('G', 'S')
)

```

49. LIKE

```sql
SELECT * FROM 거래
WHERE 고객ID LIKE :CUST_ID || '%'
AND 거래일자 BETWEEN :DT1 AND :DT2
```

a. 고객ID가 Null 허용 컬럼일때 결과집합에 오류가 발생할 수 있다.
b. 고객ID 길이가 가변적일때 결과집합에 오류가 발생할 수 있다.
c. 고객ID 가 숫자형 컬럼일 때 고객ID가 인덱스 선두 컬럼이면 INDEX RANGE SCAN이 불가능하고 거래일자가 선두 컬럼이면 인덱스 스캔 비효율이 발생한다. =>
d. 고객ID가 문자형 컬럼이고 고객ID가 인덱스 선두 컬럼이면 INDEXRANGESCAN이 가능하다.

50. 선택조건절 구현

```sql
SELECT *
FROM 거래
WHERE 고객ID = NVL(#CUST_ID#, 고객ID)
AND 거래일자 BETWEEN #DT1# AND #DT2#
```

51. 인덱스 설계시 판단기준

a. SQL 조건절 순서 =>
b. SQL 수행빈도
c. SQL의 업무상 중요도
d. 데이터양과 DML 발생빈도

52. 효과적인 인덱스 구성

```sql
SELECT 이름, 성별, 전화번호, 부서
FROM 사원
WHERE 성별 = '남자'
AND 이름 = '홍길동'
```

이름 + 성별

53. 효과적인 인덱스 구성

```sql
SELECT *
FROM 거래
WHERE 상품코드 = :prd_cd
AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2;

SELECT *
FROM 거래
WHERE 상품코드 = :prd_cd
AND 공급업체코드 LIKE :supl_co_cd || '%'
AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2;
```

상품코드 + 거래일자 + 공급업체코드

54. 효과적인 인덱스 구성

```sql
SELECT 고객번호, 고객명, 등록일자, 전화번호, 고객등급
FROM 고객
WHERE 등록일자 BETWEEN :DT1 AND :DT2
AND 등록지점 = '마포'
AND 성별 = '남자'
```

- 등록일자 + 등록지점 + 성별
- 등록지점 + 등록일자 + 성별
- 등록지점 + 성별 + 등록일자
- 성별 + 등록지점 + 등록일자
- 성별 + 등록일자 + 등록지점 =>

55. 최적 인덱스 설계

```sql
-- 총 고객수 = 100만명
-- 월 등록고객수 = 2만명
-- 전화번호가 02로 시작하는 고객수 = 50만명

SELECT ...
FROM 고객
WHERE 등록일자 >= ADD_MONTHS(SYSDATE, -1)
AND 등록쇼필몰 IN ('ACT', 'CPN')
AND 전화번호 LIKE '02%'
```

등록쇼핑몰 + 등록일자 + 전화번호

56. 최적 인덱스 설계

```sql
SELECT *
FROM 거래
WHERE 고객번호 = :cust_no
AND 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) and SYSDATE;

SELECT *
FROM 거래
WHERE 고객번호 = :cust_no
AND 상품번호 =: prd_no
AND 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) and SYSDATE;

SELECT *
FROM 거래
WHERE 거래일자 BETWEEN ADD_MONTHS(SYSDATE, -3) and SYSDATE;
```

- 고객번호 + 거래일자 + 상품번호
- 거래일자

57. 조건에 따라 사용가능한 인데스

```sql
SELECT
FROM 조직별판매집계
WHERE 판매조직코드 =:ORG_CD
AND 판매월 BETWEEN '202101' AND '202106'

-- SORT AGGREGATE
--  TABLE ACCESS BY INDEX ROWID 조직별판매집계
--   INDEX RANGE SCAN ()
```

- 판매조직코드 + 판매월
- 판매조직코드 + 판매금액

58. 인덱스 후보군

```sql
SELECT
FROM EMP
WHERE DEPTNO = :DEPTNO
AND SAL > :SAL
ORDER BY JOB, ENAME

-- select statement
--    table access by index rowid of emp
--      index range scan of ()
```

- DEPTNO + JOB + ENAME
- DEPTNO + JOB + ENAME + SAL

59. 부분범위처리가능한 인덱스

```sql
SELECT
FROM 계약
WHERE 취급지점ID = :
AND 청약일자 >= TRUNC(SYSDATE -3)
AND 입력일자 >= TRUNC(SYSDATE -7)
AND 계약상태ㅗ드 IN (:, :, :)
ORDER BY 청약일자 , 입력자ID
```

- 취급지점ID + 계약상태코드 + 청약일자 + 입력자ID + 입력일자

60. 제거시 성능에 영향을 주는 인덱스

```sql
-- 거래일자 : 2356
-- 관리지점번호 : 127
-- 일련번호 : 1858
-- 계좌번호 : 5956
-- 종목코드 : 1715
-- 결제일자 : 2356

-- PK : 거래일자 + 관리지점번호 + 일련번호
-- X1: 계좌번호 + 거래일자
-- X2: 결제일자 + 관리지점번호
-- X3 : 거래일자 + 종목코드
-- X4 : 거래일자 + 계좌번호
```

x4 - x1과 중복되는데 효율떨어짐

61. 최적인덱스 설계

```sql
-- 고객 10만명
-- 연락처구분 ( 휴대전호, 집전화, 팩스, 이메일, 기타)
-- :BAST_DT 변수에 주로 최근일자입력
SELECT
FROM 고객연락처변경이력
WHERE 고객ID = 200
AND  연락처구분 IN ('휴대전화', '집전화', '회사전화')
AND :BAST_DT BETWEEN 시작일자 AND 종료일자
```

- 고객ID + 연락처구분 + 종료일자 + 시작일자
