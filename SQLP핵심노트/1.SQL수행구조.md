# 1. 데이터베이스 아키택쳐

1. 오라클 아키택처 구조

오라클에서는 디스크에 저장된 데이터 집합(Datafile, Redo log file, Control file 등) 을 'DATABASE' 라고 부르고
SGA 공유메모리 영역과 이를 엑세스 하는 프로세스 집합을 합쳐 'INSTANCE' 라고 부른다.

2. 오라클 백그라운드 프로세스

백그라운드 프로세스 역할

| 백그라운드 프로세스   | 역할                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| PROCESS MONITOR(PMON) | 비정상 종료된 세션(프로세스)이 사용하던 리소스를 복구                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| SYSTEM MONITOR(SMON)  | 장애가 발생한 시스템을 재기동할때 인스턴스 복구 수행, 임시 세그먼트 모니터링 및 정리                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| DATABASE WRITE(DBWn)  | 버퍼 캐시 데이터를 디스크에 기록                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| LOG WRITER(LGWR)      | 로그버퍼 엔트리를 REDO 로그 파일에 WRITE 한다. REDO LOG BUFFER에 데이터를 기록하는 것은 백그라운드 프로세스의 역할이 아닌 각각의 DML(사용자 프로세스)을 통해 이뤄진다. 사용자 프로세스가 로그버퍼에 로그를 기록하고 데이터 블록을 변경한 이후 LGWR가 주기적으로 로그버퍼 엔트리를 REDO 로그 파일에 기록한다. WRITE AHEAD LOGGING 방식 (데이터 변경전에 로그부터 남기는 메커니즘)을 사용하는 DBMS는 REDO 로그버퍼에 기록해둔 버퍼블록에 대한 변경사항 중 현재 어디까지를 데이터파일에 기록했는지 체크포인트 정보를 관리해야 한다.이는 버퍼캐시와 데이터 파일이 동기화된 시점이 되며, 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록하여 인스턴스 복구용으로 사용된다. |
| RECOVERY              | 분산 트랜잭션 과정에서 발생한 문제를 해결한다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

3. 파일구조

\- 블록

DMBS의 기본 입출력 단위이다.
대부분의 DBMS는 블록단위로 I/O 한다. 이는 하나의 레코드에서 하나의 컬럼만 읽더라도 그것이 속한 블록을 통체로 읽음을 의미한다.

\- 익스텐트

공간을 확장하는 단위이다.
세그먼트 공간 확장시 익스텐트로 설정된 크기 만큼 테이블스페이스로 부터 할당받아 세그먼트를 확장한다.
한 블록이 8KB이고 익스텐트가 64KB로 설정되있다면 8개의 블록 만큼 세그먼트를 확장한다.

\- 세그먼트

저장공간을 필요로하는 데이터 오브젝트이다. 저장공간이 필요하다는 것은 하나 이상의 익스텐트를 사용한다는 뜻이다.
테이블, 인덱스를 생성할때 내부적으로 세그먼트가 생성된다. 파티션 테이블은 다수의 세그먼트가 할당된다.
세그먼트는 자신이 속한 테이블스페이스 내의 여러 파일에 분산되어 저장될 수 있다.
세그먼트에 할당된 익스텐트가 여러 데이터베이스 파일에 분산되어 저장되는데 이를 통해 디스크 경합을 줄이고 i/o 분산 효과를 얻으 수 있다.

\- 테이블스페이스

세그먼트를 담는 컨테이너로 여러개의 데이터 파일로 이뤄진다.
하나의 세그먼트는 여러 데이터 파일에 분산되어 저장될 순 있지만 여러 테이블 스페이스에 나눠 저장될 순 없다.

---

세그먼트는 익스텐트의 집합이다. 하지만 익스텐트 끼리는 물리적으로 인접해있지 않다. 즉 인접한 익스텐트의 집한은 아니다.

4. 파일 구조

세그먼트는 익스텐트의 집합이다.

하나의 세그먼트는 하나의 테이블 스페이스에만 속하지만 여러 데이터 파일에 분산되어 저장된다. 하나의 테이블 스페이스가 여러 데이터 파일에 분산저장되기 때문이다.

한 테이블스페이스는 여러개의 세그먼트로 구성되어있다.

익스텐트는 연속된 블록의 집합이다.

한 익스텐트에 속한 블록은 물리적으로 연속해 있지만 세그먼트 내의 익스텐트는 논리적으로 하나의 구조이지만 물리적으로 서로 인접해 있지 않다.

---

한 테이블 스페이스에는 여러 세그먼트가 존재하므로 1:N 관계이다.
익스텐트에는 여러 블록이 존재하므로 1:N 관계이다.
세그먼트는 익스텐트의 집합이므로 1:N 관계이다.

5. UNDO

UNDO는 트랜잭션을 롤백함으로써 현재를 과거의 상태로 되돌리는 데 사용한다. 이를 위해 트랜잭션을 변경이전의 상태로 되돌리는데 필요한 정보를 저장한다.

DML을 수행할 때마다 UNDO를 생성해야 하므로 UNDO 로깅은 DML 성능에 영향을 미친다.

오라클은 데이터를 입력, 수정, 삭제 할 때마다 UNDO 세그먼트에 로그를 기록한다. UNDO 데이터를 기록한 공간은 해당 트렌젝션이 커밋하는 순간

다른 트랜잭션이 재사용할 수 있는 가장 오래전에 커밋한 UNDO 공간부터 재사용하므로 다른 트랜잭션으로 덮인 공간은 메모리에서 사라진다.

UNDO가 기록한 데이터는 아래 세 가지 목적에 사용된다.

첫째, 트랜잭션에 의한 변경사항을 최종 커밋하지 않고 롤백하고자 할때 UNDO 데이터를 이용한다.

둘째, INSTANCE CRASH 발생 후 REDO를 이용해 ROLL FORWARD 단계가 완료되면 최종 커밋되지 않은 변경사항까지 모두 복구한다.

따라서 시스템이 셧다운된 시점에 아직 커밋되지 않았던 트랜잭션들을 모두 롤백해야 하는데, 이때 UNDO 데이터를 사용한다.

마지막으로, UNDO 데이터는 읽기 일관성을 위해 사용한다. SQL 튜닝 관점에서 주목할 내용은 '읽기 일관성'이다. 읽기 일관성을 위해 CONSISTENT 모드로 데이터를 읽는
오라클에선 동시 트랜잭션이 많을수록 블록 I/O가 증가하면서 성능 저하로 이어진다.

---

UNDO 를 사용하는 목적은 다음과 같다.

\- TRANSACTION ROLLBACK
\- TRANSACTION RECOVERY
\- READ CONSISTENCY

6. REDO

DB 버퍼 캐시에 가해지는 모든 변경사항을 기록하는 파일을 REDO 로그라고 부른다. 로그 기록은 APPEND 방식으로 이뤄지기 때문에 상대적으로 빠르다.

대부분 DBMS는 버퍼 블록에 대한 변경사항을 건건이 데이터 파일에 기록하기보다 우선 로그파일에 빠르게 기록하는 방식을 사용한다. 그리고 나서 버퍼 블록과 데이터 파일 간 동기화는 적절한 수단을 이용해 나중에 배치 방식으로 일괄처리한다.

사용자의 갱신 내용을 메모리상의 버퍼 블록에만 기록한 채 아직 디스크에 기록하지 않아도 REDO 로그를 믿고 빠르게 커밋을 완료한다는 의미에서 이를 'FAST COMMIT' 메커니즘이라고 부른다

- ARCHIVED(OFFLINE) REDO (DATABASE RECOVERY)

ARCHIVED REDO 로그는 ORACLE에서 ONLINE REDO 로그가 재사용되기 전에 다른 위치로 백업해 둔 파일을 말한다.

물리적으로 디스크에 결함이 생기는 등의 MEDIA FAIL 이 발생하는 경우 데이버를 복구하기 위해 ARCHIVED REDO LOG를 사용된다.

- INSTANCE RECOVERY(onlie redo)

버퍼캐시는 휘발성으로 캐시에만 적용된 여러 변경사항들이 데이터 파일에 기록하지 않은 상태로 인스턴스가 비정상적으로 종료되면, 그때까지의 작업내용을 모두 잃게 된다.

이러한 데이터 유실에 대비하기 위해 REDO LOG 를 남긴다.

ONLICE REDO 로그는 최소 두 개 이상의 파일로 구성된다. 현재 사용중인 파일이 꽉 차면 다음 파일로 로그스위칭이 발생하며, 계속 로그를 써 나가다가 모든 파일이 차면 다시 첫 번째 파일부터 재사용하는 ROUND-ROBIN 방식을 사용한다.

\- FAST COMMIT

변경된 메모리 버퍼 블록을 데이터 파일에 기록하는 작업은 RANDOM 엑세스 방식으로 이루어지기 때문에 느리다. 반면에 로그는 APPEND 방식으로 기록하므로 빠르다.

따라서 트랜젝션에 의한 변경사항을 건건이 데이터 파일에 기록하기보다 APPEND 방식으로 로그파일에 빠르게 기록하고 버퍼캐시 블록과 데이터 파일의 동기화는 DBWR를 이용해 나중에 BATCH로 처리한다.

사용자가 요구한 갱신 사항을 버퍼캐시에만 기록한 채 아직 영구적으로 디스크에 기록하지 않았다고 해도 REDO 로그를 믿고 빠르게 커밋을 완료한다는 의미에서 FAST COMMIT 이라고 한다.
커밋 정보가 로그파일에 기록되 있기만 하면 인스턴스 CRASH 가 발생했더라도 rEDO 로그를 사용해 복구하기 때문에 사용자 프로세스는 안심하고 커밋할 수 있다.

---

REDO 를 사용하는 목적은 다음과 같다.

\- DATABASE RECOVERY(ARCHIVED REDO/OFFLINE REDO)
\- CACHE RECOVERY(INSTANCE REDO/ONLINE REDO)
\- FAST COMMIT

Online Redo 로그는 최소 두 개 이상의 파일로 구성해야 하며,
~~로그 스위치 주기는 빠를수록 좋다~~

동시에 많은 트랜잭션이 몰려 로그 스위치가 너무 자주 발생하면 백업이 완료되지 못한 ONLINE REDO LOG로 스위칭이 일어나면서 DB HANG이 발생할 수 있다.

이를 방지하기위해 적절한 크기와 수의 REDO로그 파일이 할당되야한다.

7. REDO 매커니즘

DB 버퍼 캐시에 가해지는 모든 변경사항을 로그 파일에 기록한다. 로그 엔트리도 로그파일에 곧바로 기록하는 것이 아니라 먼저 로그 버퍼에 기록한다.

서버 프로세스가 데이터 블록 버퍼에 변경을 가하기 전에 REDO 로그 버퍼에 먼저 기록해두면 주기적으로 LGWR 프로세스가 REDO 로그 파일에 기록한다.

```sql
-- DB 버퍼에변경사항 발생 - REDO LOG 버퍼에 기록 - WRITE AHEAD LOGGING  (REDO LOG 파일에 기록 - DATAFILE에 기록)
```

\- LOG FORCE AT COMMIT

DML을 수행하는 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한다. 이후 LGWR가 주기적으로 로그 버퍼 엔트리를 REDO LOG FILE에 기록한다.

메모리상의 로그는 휘발성으로 언제나 유실의 위험이 있다. 따라서 트랜잭션 영속성을 보장하기 위해선 최소한 커밋 시점에는 로그버퍼가 아닌 디스크 파일에 기록해야 한다.

이를 'LOG FORCE AT COMMIT' 이라 한다.

\- Fast commit

사용자프로세스 요청사항이 버퍼캐시에만 기록된 채 아직 디스크에 기록되지 않았더라도 REDO 로그를 믿고 빠르게 커밋을 완료한다는 의미이다.

커밋 정보가 로그파일에 기록되어있기만 하면, 인스턴스 CRASH가 발생하더라도 REDO로그를 이용해 언제든 복구할 수 있다.

\- WRITE AHEAD LOGGING

버퍼블록 캐시를 갱신하기 전에 먼저 REDO 엔트리를 REDO 로그버퍼에 기록해야 하며,

DBWR가 버퍼 캐시의 DIRTY 블록을 데이터파일에 기록하기 전에 먼저 LGWR가 해당 REDO 엔트리를 모두 REDO 로그 파일에 기록했음이 보장되어야한다.

\- SNAPSHOT TOO OLD

undo 데이터를 활용해 높은 수준의 동시성과 읽기 일관성을 유지하는 대신, 일반적인 LOCKING 메커니즘에는 없는 SHAPSHOT TOO OLD 에러가 MVCC 에서 발생한다.

대용량 데이터를 처리할 때 종종 개발자를 괴롭히는 이 에러는 UNDO 영역에 저장된 UNDO 정보가 다른 트랜잭션에 의해 재사용돼 필요한 CR COPY를 생성할 수 없을 때 발생한다.

---

~~Snapshot Too Old~~

오라클은 데이터를 읽는 도중에 다른 트랜잭션에 의해 변경되거나 변경이 진행중인 블록을 만나면 과거의 상태로 되돌린 CR COPY 블록을 만들어서 읽는다.

이때 UNDO 정보를 이용하는데 필요한 UNDO 블록이 다른 트랜잭션에 의해 재사용된 상태라면 CR COPY BLOCK 을 생성할 수 없다.

그럴 때 SNAPSHOT TOO OLD 에러가 발생한다. 그러므로 이는 undo 와 관련된 메커니즘이다.

8. SGA의 구성

\- SHARED AREA ( LIBRARY CACHE + DICTIONARY CACHE)
\- DATA BUFFER CACHE (버퍼케시)
\- REDO LOG BUFFER CACHE (로그버퍼)

---

SORT AREA는 SGA가 아닌 PGA에 할당된다.

9. ORACLE MEMORY CACHE

\- DB BUFFER CACHE

데이터 파일에서 읽은 데이터를 캐싱

DATA READ 시 서버 프로세스르 통해 DB BUFFER CACHE의 데이터를 읽음

\- LIBRARY CHACE

FULL TEXT SQL 문장, 실행계획 캐싱
Stored PROCEDURE, Trigger 캐싱

\- DICTIONARY CHACHE

테이블 정보, 인덱스 정보, 오브젝트, TABELSAPCE, 데이터 파일의 메타 정보

\-- Result Cache

\-- SQL 결과집합을 캐싱

---

SQL은 라이브러리 캐시에 캐싱된다.

10. 버퍼 블록

모든 버퍼캐시 블록은 3가지 상태 중 하나에 놓이게 된다.

\- FREE 버퍼

인스턴스 기동 후 아직 데이터가 읽히지않아 비어있는 상태의 버퍼이거나, 데이터가 담겼지만 데이터 파일과 서로 동기화돼 있는 상텨에서 언제든지 덮어 써도 무방한 버퍼블록을 말한다.

데이터 파일로부터 새로운 데이터 블록을 로딩하려면 먼저 FREE 버퍼를 확보해야한다. FREE 상태에서 변경이 발생하면 DIRTY 버퍼로 상태가 바뀐다.

\- Dirty 버퍼

버퍼에 캐시된 이후 변경이 발생했지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼블록을 말한다.

이 버퍼 블록이 다른 데이터 블록을 위해 재사용되려면 디스크에 먼저 기록돼야하며, 디스크에 기록되는 순간 Free 버퍼 상태로 바뀐다.

\- PINNED 버퍼

읽기 또는 쓰기 작업이 현재 진행 중인 버퍼 블록을 말한다.

---

# SQL 처리과정

11. SQL의 특징

SQL은 'Structured Query Language' 의 줄임말로 말 그대로 구조적 질의 언어이다.

원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과집합을 만드는 과정은 절차적이다. 즉, 프로시저가 팔요한데 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 바로 SQL 옵티마이저다.

하지만 SQL은 기본적으로 구조적이고 집합적이고 선언적인 질의 언어다.

---

~~절차적~~

결과집합을 만드는 과정은 절차적이지만 이는 프로시저의 역할로 SQL 자체의 특징과는 거리가 멀다.

12. SQL 최적화 과정

SQL을 처리하기전 최적화 과정을 세분화하면 다음과 같다.

\- SQL 파싱

SQL을 사용자로부터 전달받으면 가장 먼저 SQL 파서가 파싱을 진행한다.

\-- SQL 문을 이루는 개별 구성요소를 분석해 파싱 트리를 생성한다.

\-- 문법적 오류가 없는지 확인하는 SYNTAX CHECK를 실시한다. 사용할 수 없는 키워드나 순서가 바르지 않거나 누락된 키워드가 있는지 확인한다.

\-- 의미상 오류가 없는지 확인하이 위해 SEMACTIC CHECK를 실시한다. 존재하지 않는 테이블을 사용하거나 사용한 오브젝트에 권한이 있는지 확인한다.

\- SQL 최적화

옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 가장 효율적인 실행계획 하나를 선택한다.

\- 로우 소스 생성

SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅한다. 로우 소스 생성기가 그 역할을 맏는다.

---

SQL 처리과정 중 문법적 오류 또는 의미상의 오류를 확인하는 단계는 'SQL파싱' 이다.

13. SQL 최적화

\- SQL 옵티마이저

옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진이다.

최적화 단계는 다음과 같다.

\ 1. 사용자로부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획을 찾아낸다.
\ 2. 데이터 딕셔너리에 미리 수집해둔 오브젝트 통게 및 시스템 통계정보를 이용해 각 실행계획의 비용을 산정한다.
\ 3. 최저비용을 나타내는 실행계획을 선택한다.

14. 비용기반 옵티마이저

비용기반 옵티마이저는 사용자로 부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획을 찾아내서 각각의 예상 비용을 산정한 후 최저 비용을 나타내는 하나를 선택한다.

---

SQL 최적화 단계에서 옵티마이저는 실행계획 후보군을 많이 생성한 후 비용을 비교해 최종 하나를 선택한다.

15. 옵티마이저 힌트

프로그램이나 데이터 특성 정보를 정확히 알고 있는 개발자가 직접 인덱스를 지정하거나 조인 방식을 변경함으로써 더 좋은 실행 계획으로 유도하는 매커니즘을 '옵티마이저 힌트'라고 한다.

문법적, 의미적으로 맞지 않는 힌트, 잘못된 참조의 사용, 논리적으로 불가능한 액세스 경로에 대한 힌트는 옵티마이저가 무시한다.

무시되는 경우에 해당하지 않는 한 옵티마이저는 힌트를 우선적으로 따른다.

힌트를 잘못 기술하거나 잘못된 참조를 사용하더라도 에러가 발생하지 않는다.

\- 문법적으로 틀린 힌트를 기술
\- 의미적으로 틀린 힌트를 기술
\- 잘못된 참조 사용
\- 논리적으로 불가능한 액세스 경로

16. 옵티마이저 힌트가 무시되는 경우

index 힌트에 인덱스명을 지정하지 않으면,어떤 인덱스를 사용할지 옵티마이저가 결정한다.

leading 힌트에 나열하지 않은 테이블의 조인은 옵티마이저가 결정한다.

---

힌트를 느슨하게 기술한 경우, 예를들어 index 힌트에 인덱스명을 지정하면 옵티마이저가 사용할 인덱스를 지정한다.

leading 힌트에 테이블을 모두 나열하지 않고 앞쪽 일부만 지정한 경우 옵티마이저가 조인 순서를 결정한다.

17. 힌트 사용시 주의사항

\- 힌트 안에 인자를 나열할 땐 ',' 를 사용할 수 있지만 힌트와 힌트 사이에서 사용할 수 없다.

```sql
SELECT /*+INDEX(E, EMP_X01)*/ -- 유효
FROM EMP E, DEPT D

SELECT/*+INDEX(E), FULL(D)*/ -- 첫 번째 힌트만 유효
FROM EMP E, DEPT D


```

\- 테이블을 지정할 때 스키마명까지 명시해선 안된다.

```SQL
SELECT /*+FULL(SCOTT.EMP)*/ -- 무효
FROM EMP

```

\- FROM 절 테이블명 옆에 ALIAS를 지정했다면, 힌트도 반드시 ALIAS를 사용해야한다.

\- FROM 절에 ALIAS를 지정했는데 힌트에는 테이블명만을 사용하면, 그 힌트는 무시된다.

```SQL
SELECT /*+ FULL(EMP) */ -- 무효
FROM EMP E
```

18. 옵티마이저 힌트의 종류

\- DRIVING-SITE : DB LINK REMOTE 쿼리에 대한 최적화 및 실행 주체 지정

\- SWAP_JOIN_INPUTS : 조인 시, BUILD INPUT을 명시적으로 지정

\- UNNESTING : 중첩된 서브 쿼리를 풀어 메인쿼리와 같은 레벨로 만든다.

---

1. DRIVING-SITE 힌트는 ~~조인 드라이빙 테이블을 선택한다~~
2. SWAP_JOIN-INPUTS 힌트는 ~~NL 조인 순서를 변경한다.~~
3. UNNEST : 서브쿼리를 풀어서 조인으로 현환한다.
4. INPUT_FS : ~~INDEX FULL SCAND으로 유도한다~~

# 데이터베이스 IO 메커니즘

19. 블록단위 I/O

DBMS의 모든 I/O는 블록 단위로 이뤄진다.
블록 단위 I/O는 버퍼캐시와 데이터파일 모두에 적용된다.

\- 데이터 파일에서 DB 버퍼 캐시로 블록을 적재할 때
\- 데이터 파일에서 블록을 직접 읽고 쓸때 (DIRECT PATH I/O)
\- DB 버퍼 캐시에서 블록을 읽고 쓸 때
\- DB 버퍼 케시에서 변경된 블록을 다시 데이터 파일을 쓸 때

데이터 딕셔너리에 저장된 테이블 및 컬럼 정보를 딕셔너리 캐시에 저장할 때는 로우 단위로 I/O한다.

딕셔너리 캐시를 로우캐시로 부르는 이유이기도 하다.

---

테이블 및 컬럼 정보를 딕셔너리 캐시에 적재할때는 로우단위로 I/O 한다.

20. 블록단위 I/O

조회 조건은 같지만 조회하는 컬럼의 수가 다른 두 쿼리는 테이블 엑세스가 블록단위로 일어나기 때문에 읽는 블록수는 같다.

조회하는 컬럼의 수가 다르면 네트워크에서 클라이언트에게 전송되는 데이터의 크기나 소트영역에서 차지하는 메모리의 크기가 달라진다.

21. 메모리버퍼캐시 경유

DIRECT PATH I/O를 제외한 모든 블록 I/O는 메모리 버퍼케시를 경유한다.
구체적로 다음과 같은 경우 버퍼캐시 탐색과정을 거친다.

\- 인덱스 루트 블록을 읽을때
\- 인덱스 루트 블록에서 얻은 메모리 주소르 통해 브랜치 블록을 읽을떄
\- 브랜치 블록에서 얻은 메모리 주소를 통해 리프 블록을 읽을때
\- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
\- 테이블 블록을 FULL SCAN 할때

단, 병럴프로세스로 TABLE FULL SCAN 할때는 DIRECT PATH I/O 가 발생하므로 메모리버퍼캐시를 경유하지 않는다.

---

~~병렬프로세스로 테이블 블록을 FULL SCAN 할때~~

22. 버퍼 캐시 히트율

전체 읽은 블록 중에서 메모리 버퍼 캐시에서 찾은 비율을 나타낸다.
물리적 디스크 읽기를 수반하지 않고 곧바로 메모리에서 블록을 찾은 비율을 말한다.

```sql
--  DISK : PHYSICAL READ(DISK 에서 읽은 것)
--  QUERY :  CACHE BUFFER에서 읽은 것 + DISK
--  CURRENT : CURRENT 모드에서 읽은 것, 주로 UPDATE에서 발생

BCHR = (query - disk + current) / (query +  current)
BCHR = 1 - Disk / (query + current)
```

논리적 I/O는 수행과정에서 읽은 총 블록수를 말하며, query 항목 + current 항목을 더해서 만든다.

읽고자 하는 블록을 먼저 캐시에서 찾고, 못 찾으면 디스크에서 읽는다.

따라서 논리적 I/O 횟수에는 물리적 I/O 횟수가 포함되어있다.

23. LRU알고리즘

DB 버퍼 캐시의 크기는 유한하므로 모든 데이터를 캐싱해 둘 수 없다.
따라서 사용빈도가 높은 데이터 블록 위주로 버퍼 캐시가 구성되도록 알고리즘을 사용한다.

모든 버퍼 블록 해더를 LRU 체인에 연결해 사용빈도가 높은 순으로 옮겨가다 FREE 버퍼가 필요해지면 액세스 빈도가 낮은 쪽 데이터 블록부터 밀어낸다.

24. 시퀀셜 엑세스 vs 랜덤 액세스

랜덤 액세스는 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

인덱스 수직적 탐색 및 리프노드에서 테이블로 액세스하는 테이블 랜덤 액세스 방식에 쓰인다.

TABLE FULL SCAN/ INDEX FULL SCAN / INDEX RANGE SCAN 은 MULTIBLOCK I/O 로 시퀀셜 액세스 방식이다.

인덱스를 스캔하면서 얻은 ROWID로 테이블 블록을 액세스 하는 TABLE ACCESS BY INDEX ROWID 단계는 랜덤 엑세스에 해당한다.

25. SINGLEBLOCK I/O VS MULTIBLOCK I/O

I/O CALL을 할 때, 한 번에 한 블록씩 요청하기도 하고, 여러 블록씩 요청하기도 한다.

인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 SINGLE BLOCK I/O 방식을 이용한다.

\- 인덱스 루트 블록을 읽을때
\- 인덱스 루트 블록에서 얻은 메모리 주소르 통해 브랜치 블록을 읽을떄
\- 브랜치 블록에서 얻은 메모리 주소를 통해 리프 블록을 읽을때
\- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때

많은 데이터 블록을 읽을 때는 MULTIBLOCK I/O 방식이 효율적이다.

인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다.

읽고자 하는 블록을 DB 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O CALL을 한다.

그 동안 프로세스는 대기 큐에서 잠을 자는데 한번에 많은 블록을 요청해야 잠자는 횟수가 줄어든다.

오라클에서 한 번에 읽는 블록을 수는 DB_FILE_MULTIBLOCK_READ_COUNT 파라미터로 정한다.

26. MULTIBLOCK I/O

MULTIBLOCK I/O 는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O할때 디스크 상의 그 블록과 인접한 블록을 한 번에 읽어 캐시에 미리 적재하는 기능이다.

오라클에서 한 번에 읽는 블록을 수는 DB_FILE_MULTIBLOCK_READ_COUNT 파라미터로 정한다.

인접한 블록이란 같은 익스텐트에 속한 블록을 의미한다. MULTIBLOCK I/O 방식으로 읽더라도 익스텐트 경게를 넘지 못한다.

DB FILE SEQUENTIAL READ 는 SINGLE BLOCK I/O에서 발생하고 MULTI BLOCK I/O 시에는 DB FILE SCATTERED READ 대기 이벤트가 발생한다.

---

~~MULTIBLOCK I/O를 모니터링해 보면 DB File Sequantion read 대기 이벤트가 나타난다.~~

27. 데이터베이스 I/O 원리

한 쿼리에서 같은 테이블을 반복적으로 읽으면 BCHR은 올라간다.

MULTI BLOCK I/O는 익스텐트 단위로 이루어지므로 DB_FILE_MULTIBLOCK_READ_COUNT룰 채우지 못했더라도 다음 익스텐트를 추가로 읽지 않는다.

따라서 익스텐트 크기가 작으면 더 많은 BLOCK I/O가 발생한다.

인덱스를 통해 데이터를 액세스 할때는 SINGLE BLOCK I/O 방식을 이용하므로 익스텐트 크기와 I/O 횟수는 관련이 없다.

28. SQL 성능 고도화

대량 데이터 조회시 병렬 처리하면 CPU와 메모리 자원을 많이 사용하고, 잦은 체크포인트 수행으로 LGWR 작업량이 증가해 커밋 성능이 저하되는 등 온라인트랜잭션 환경에 악영향을 준다.
