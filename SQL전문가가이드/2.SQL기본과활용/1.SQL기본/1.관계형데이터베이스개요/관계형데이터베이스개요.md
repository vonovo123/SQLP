# 데이터베이스

관리 대상이 되는 데이터의 양이 점점 많아지고 같은 데이터를 여러 사람이 동시에 다양한 용도로 사용하게 되면서 개인이 관리하는 소프트웨어 만으로는 한계가 따른다. 경우에 따라서 개인의 사소한 실수로 기업의 중요 데이터가 손상되거나 유실되는 상황까지 발생할 수도 있다. 따라서 많은 사용자들이 더욱 효율적인 데이터 관리뿐 아니라 예기치 못한 사건으로 인한 데이터 손상을 피하고 필요한 데이터를 복구하기 위한 가역한 기능의 소프트웨어 필요로 하게 됐다. 이 기본적인 요구 사항을 만들어주는 시스템을 DBMS라고 한다.

\- 관계형 데이터베이스

현재 기업에서 사용하는 대부분의 데이터베이스는 기존 관계형 데이터베이스에 객체 지원 기능을 추가한 객체 관계형 데이터베이스이다. 하지만 현실적으로 기업의 핵심 데이터는 대부분 관계형 데이터베이스 구조로 저장되고, 관계형 데이터베이스를 유일하게 조작할 수 있는 SQL 문장에 의해 관리되므로 관계형 데이터베이스와 SQL은 매우 중요하다.

파일 시스템은 하나의 파일을 많은 사용자가 동시에 검색할 수 있지만 동시에 입력, 수정, 삭제 할 수 없기 때문에 정보의 관리가 어렵다. 하나의 파일을 여러 사용자나 애플리케이션에서 동시에 사용하기 위해 원래의 데이터 파일을 여러 개 복사해 사용하게 된다. 이 방식은 동일한 데이터가 여러 곳에 저장되는 문제점이 있다. 하나의 원본 파일에 대해 변경 작업이 발생했을 때 모든 복사본 파일에 변경 작업을 한꺼번에 병행처리 하지 않으면, 서로 다른 정보 파일이 존재하므로 데이터의 불일치가 발생한다.

결과적으로 파일 시스템은 분산된 데이터 간 정합성을 유지하는 데 과다한 노력이 필요하고 정합성을 보장하기가 힘들다. 단, 단일 사용자나 어플리케이션이 데이터를 이용하는 경우 파일 시스템이 데이터베이스보다 처리 성능이 뛰어나다.

관계형 데이터베이스는 정규화를 통한 합리적 테이블 모델링을 통해 이상현상을 제거하고 데이터 중복을 피할 수 있으며, 동시성 관리와 병행 제어를 통해 많은 사용자가 동시에 데이터를 공유 및 조작할 수 있는 기능을 제공한다. 관계형 데이터베이스는 메타 데이터를 총괄 관리할 수 있으므로 데이터의 성격, 속성, 또는 표현 방법 등을 체계화 할 수 있고 데이터 표준화를 통한 데이터 품질을 확보할 수 있다.

DBMS는 인증된 사용자만 참조할 수 있도록 보안 기능을 제공한다. 테이블 생성 시에 사용할 수 있는 다양한 제약조건을 이용해 사용자가 실수로 조건에 위배하는 데이터를 입력한다거나, 관계를 연결하는 중요 데이터 삭제를 방지해 데이터 무결성을 보장한다. DBMS는 시스템의 갑작스런 장애로부터 사용자가 입력, 수정, 삭제하던 데이터가 제대로 반영될 수 있도록 보장해주는 기능, 시스템 다운,재해 등의 상황에서도 데이터를 회복, 복구 할 수 있는 기능을 제공한다.

---

# SQL

관계형 데이터베이스에서 데이터 정의, 데이터 조작, 데이터를 제어하기 위해 사용하는 언어이다. SQL은 관계형 데이터베이스에 대한 전담 접속 용도로 사용되며 세미콜론으로 분리된 SQL 문장 단위로 독립돼 있다. 관계형 데이터베이스는 수학의 집합 논리에 입각하여 데이터를 집합으로 취급한다. SQL도 마찬가지이다. 검색 조건을 만족하는 요구 집합을 추출한다. 이렇게 특정 데이터들의 집합에서 필요로 하는 데이터를 꺼내서 조회하고 새로운 데이터를 입력, 수정, 삭제하는 행위를 통해 사용자는 데이터베이스와 대화하게 된다.

SQL은 이런 대화를 가능하도록 하는 매개 역할을 하므로 SQL 을 배우는 것이 곧 관계형 데이터베이스를 배우는 기본 단계라 할 수 있다.

![SQL 문장들의 종류](./SQL%EB%AC%B8%EC%9E%A5%EB%93%A4%EC%9D%98%EC%A2%85%EB%A5%98.png)

이들 SQL 명령어는 4가지 SAVEPOINT 그룹인 DDL, DML, DCL, TCL로 나눌 수 있다.

---

# STANDARD SQL

현재 기업형 DBMS는 순수 관계형 데이터베이스가 아닌, 객체 지원 기능이 포함된 객체 관계형 데이터베이스가 대부분이다. 많은 시스템의 두뇌 역할을 하는 관계형 데이터베이스를 유일하게 접속할 수 있는 언어가 바로 SQL 이다. 현재 사용되는 데이터베이스는 대부분 SQL:2003 표준을 기준으로 하고 있다.
ANSI/ISO SQL 표준을 통해 STANDARD JOIN을 포함한 많은 기능이 상호 벤치마킹되고 발전되면서 DBMS 간에 평준화를 이루어 가고 있다.
Oracle에서 표준 SQL에 포함된 CASE 기능과 FULL OUTER JOIN 기능을 추가했다.

대표적인 ANSI/ISO 표준 SQL 기능은 다음 내용을 포함한다.

- STANDARD JOIN 기능 추가(CROSS, OUTER JOIN 등 새로운 FROM 절 JOIN 기능들)
- SCALAR SUBQUERY, TOP-N QUERY 등의 새로운 SUBQUERY 기능들
- ROLLUP, CUBE, GROPING SETS 등 새로운 리포팅 기능
- WINDOW FUNCTION 같은 새로운 개념의 분석 기능들

## 일반 집합 연산자

1. UNION 연산

UNION은 수학적 합집합을 제공하고 공통 교집합의 중복을 없애기 위한 사전 작업으로 시스템에 부하를 주는 정렬 작업이 발생한다.
UNION 연산자를 이용한다. 이후 UNION ALL 기능이 추가됐는데, 특별한 요구 사항이 없다면 공통집합을 중복해 그대로 보여 주기 때문에 정렬 작업이 일어나지 않는 장점을 가진다. UNION 과 UNION ALL의 출력결과가 같다면, 응답 속도 향상이나 자원 효율화 측면에서 데이터 정렬 작업이 발생하지 않는 UNION ALL 사용을 권고한다.

2. INTERSECTION 연산

수학적 교집합으로써 두 집합의 공통집합을 추출한다.
INTERSECTION 연산자를 이용한다

3. DIRRERENCE 연산

수학적 차집합으로서 첫 번째 집합에서 두 번째 집합과의 공통집합을 제외한 부분이다.
EXCEPT(Oracle은 MINUS) 기능을 이용한다.

4. PRODUCT 연산

CROSS PRODUCT라고 불리는 곱집합으로, JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다. 양쪽 집합의 M\*N 건의 데이터 조합이 발생한다.

## 순수 관계 연산자

5. SELECT 연산

WHERE 절의 조건절 기능으로 구현됐다.
SELECT 연산과 SELECT 절은 의미하는 바가 다르다.

6. PROJECT 연산

SELECT 절의 칼럼 선택 기능으로 구현됐다.

7. NATURAL JOIN 연산

WHERE 절의 INNER JOIN 조건과 함께 FROM 절의 NATURAL JOIN, INNER JOIN, OUTER JOIN, USING 조건절, ON 조건절 등으로 발전했다.

8. DIVIDE 연산

나눗셈과 비슷한 개념으로 오른쪽 집합을 XZ로 나누었을 때, XZ를 모두 갖고 있는 A가 정답이 되는 기능으로 현재 사용하지 않는다

관계형 데이터베이스의 경우 요구 사항 분석, 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터모델링 단계를 거치게 된다.
이 단계에서 앤터티 확정 및 정규화, M:M 관계 분해 절차를 거친다.
정규화 과정의 경우 데이터 정합성과 데이터 저장 공간의 절약을 위해 엔터티를 최대한 분리하는 작업으로 3차 정규형 혹은 보이스코드 정규형 까지 진행한다.
정규화를 거치면 하나의 주제에 관련된 엔터티가 여러 개로 나뉜다. 이런 엔터티들이 주로 테이블이 되는데 흩어진 데이터를 연결해 원하는 데이터를 가져오는 것을 JOIN 이라한다.

---

# 테이블

데이터는 관계형 데이터베이스의 기본 단위인 테이블 형태로 저장된다. 모든 자료는 테이블에 등록되고, 우리는 테이블로부터 원하는 자료를 꺼내온다.
테이블은 어느 특정한 주제와 목적으로 만들어지는 일종의 집합이다.

테이블은 데이터를 저장하는 객체로서 관계형 데이터베이스의 기본 단위이다. 관계형 데이터베이스에서는 모든 데이터를 칼럼과 행이라는 2차원 구조로 나타낸다.
세로 방향을 칼럼, 가로로 방향을 행이라고 한다. 칼럼과 행이 겹치는 하나의 공간을 필드라고 한다.

\- 테이블 : 행과 칼럼의 2차원 구조를 가진 데이터 저장 장소, 데이터베이스의 가장 기본적인 개념
\- 칼럼,열 : 테이블에서 세로 방향으로 이루어진 하나 하나의 특정 속성
\- 행 : 테이블에서 가로방향으로 연결된 데이터

분할된 테이블은 칼럼의 값에 의해 연결된다. 이렇게 테이블을 분할해 데이터의 불필요한 중복을 줄이는 것을 정규화라고 한다. 데이터의 정합성 확보와 데이터 입력,수정,삭제 시 발생할 수 있는 이상현상을 방지하기 위해 정규화는 매우 중요한 프로세스이다.

각 행을 한 가지 의미로 특정할 수 있는 한 개 이상의 칼럼을 기본키라고 한다. 기본키로 사용되면서 테이블과의 관계를 연결하는 역할을 하는 칼럼을 외부키라고 한다.

---

## ERD

테이블 간에는 어떤 의미의 연관성이나 관계를 갖고 있다. Entity Relationship Diagram은 이와 같은 관계의 의미를 직관적으로 표현할 수 있는 좋은 수단이다.
테이블 간 서로의 상관관계를 그림으로 도식화 한 것을 E-R 다이어그램이라고 하며, 간략히 ERD라고 한다.

ERD는 엔터티, 관계, 속성 3가지로 구성된다.

예를 들어 케이리그 테이블 간의 양방향 관계는 다음과 같다.

\- 하나의 팀은 여러 명의 선수를 포함할 수 있다.
\- 한 명의 선수는 하나의 팀에 꼭 속한다
\- 하나의 팀은 하나의 전용 구장을 꼭 가진다.
\- 하나의 운동장은 하나의 홈 팀을 가질 수 있다.
\- 하나의 운동장은 여러 게임의 스케줄을 가질 수 있다.
\- 하나의 스케줄에는 하나의 운동장에 꼭 배정된다.

![케이리그 ERD](./%EC%BC%80%EC%9D%B4%EB%A6%AC%EA%B7%B8%20ERD.png)

앞으로 사용하게 될 부서-사원 테이블 간의 관계를 표현한 ERD 이다.

- 하나의 부서는 여러 명의 사원을 보유할 수 있다.
- 한 명의 사원은 하나의 부서에 꼭 소속된다.

![사원-부서 ERD](./%EC%82%AC%EC%9B%90-%EB%B6%80%EC%84%9C%20ERD.png)

---

# 데이터 유형

데이터 유형은 데이터베이스 테이블에 특정 자료를 입력할 때, 그 자료를 받아들일 공간을 자료의 유형별로 나누는 기준이다. 즉 특정 칼럼을 정의할때, 선언한 데이터 유형은 그 칼럼이 받아들일 수 있는 자료의 유형을 규정한다. 따라서 선언한 유형이 아닌 다른 종류의 데이터가 들어오려고 하면 데이터 베이스는 에러를 발생시킨다.
데이터 유형과 더불어 지정한 크기도 중요한 역할을 한다. 선언 당시에 지정한 데이터의 크기를 넘어가는 자료가 입력되면 에러를 발생시킨다.

데이터베이스에서 사용하는 데이터 유형은 다양한 형태로 제공된다.

ANSI/ISO 기준에서는 NUMERIC, NUMERIC의 하위 개념인 NUMERIC, DECIMAL, DEC, SMALLINT, INTEGER, INT, BIGINT, LOAT, REAL, DOUBLE PRECISONdmf throgksek.
반면 ORACLE은 NUMBER 한 가지 숫자 데이터 유형만 지원한다.

테이블 칼럼이 갖고 있는 대표적인 4가지 데이터 유형을 정리하면 다음과 같다.

## CHARACTER(s)

- 고정길이 문자열 정보(CHAR 로 표현)
- s는 기본 길이 1바이트, 최대 길이 Oracle 2000바이트, SQL Server 8000 바이트
- s만큼 최대 길이, 고정 길이를 갖고 있으므로 할당된 변수 값의 길이가 s보다 작을 경우 그 차이 길이 만큼 공간으로 채워진다.

## VARCHAR(s)

- 가변길이 문자열 정보(Oracle은 VARCHAR2로 표현)
- s는 최소 길이 1바이트, 최대 길이 Oracle 4000바이트, SQL Server 8000 바이트
- s만큼의 최대 길이를 갖지만 가변 길이로 조정이 되기때문에 할당된 변수값의 바이트만 적용된다.

## NUMERIC

- 정수, 실수 등 숫자정보(Oracle Number, SQL Server는 10가지 이상의 숫자 타입)
- Oracle은 처음에 전체 자리 수를 지정하고, 그 다음 소수 부분의 자리 수를 지정한다.
- 예를들어, 정수 부분이 6자리이고 소수점 부분이 2자리인 경우 NUMBER(8,2)로 지정한다.

## DATETIME

- 날짜와 시각 정보(Oracle은 DATE로 표현, SQL Server는 DATETIME으로 표현)
- ORACLE은 1초 단위, SQL Server는 3.33ms 단위로 관리

문자열 유형의 경우, CHAR 유형과 VARCHAR 유형 중 어느 유형을 지정하는지에 대한 문제가 자주 논의된다.
중요한 것은 저장 영역과 문자열의 비교방법이다. VARCHAR 유형은 가변 길이이므로 필요한 영역은 실제 데이터 크기뿐이다. 그렇기 때문에 길이가 다양한 칼럼과, 정의된 길이와 실제 데이터 길이에 차이가 있는 칼럼에 적합하다.
저장 측면에서도 CHAR 유형보다 작은 영역에 저장할 수 있으므로 장점이 있다.

또 하나는 비교 방법의 차이이다. CHAR에서는 문자열을 비교할 때 공백을 채워 비교하는 방법을 사용한다.
공배 채우기 비교에서는 우선 짦은 쪽의 끝에 공백을 추가해 2개의 데이어타 같은 길이가 되도록 한다. 그리고 앞에서 부터 한 문자씩 비교한다. 그러므로 끝의 공백만 다른 문자열은 같다고 판단된다. 그에 반해 VARCHAR 유형에서는
맨 처음부터 한 문자씩 비교하고 공백도 하나의 문자로 취급하므로 끝의 공백이 다르면 다른 문자로 판단한다.

가장 많이 사용하는 VARCHAR 유형에 대해 예를 들어 알아보자. 영문 이름이 VARCHAR(40) 으로, 40 바이트가 지정되더라도 실제 데이터가 11자 인 경우 11바이트 공간만을 차지한다. 주민번호나 사번처럼 고정길이 값을 같는 문자열
열을 갖지 않는 데이터 유형은 VARCHAR 유형을 적용하는 것이 바람직하다.
CHAR가 아닌 VARCHAR, NUMERIC 유형에서 정의한 길이나 자릿수의 의미는 해당 데이터 유형이 가질 수 있는 최대 한계값을 정의한 것으로 봐야한다. 문자열에 대한 최대 길이와 NUMBER 칼럼의 정밀도를 지정하는 것은 테이블 설계 시 반드시 고려해야할 중요 요소이다.

잘못된 판단은 추후 ALTER TABLE 명령으로 정정할 수 있지만, 데이터가 입력된 상황이라면 처리가 쉽지않다.
