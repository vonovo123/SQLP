# 데이터 분석 개요

ANSI/ISO SQL 표준은 데이터 분석을 위해 다음의 세 가지 함수를 정의하고 있다.

## AGGREGATE FUNCTION

그룹함수의 한 부분으로 분류할 수 있다. COUNT, SUM, AVG, MAX, MIN 외 각종 집계 함수들이 포함돼 있다.

## GROUP FUNCTION

그룹 함수는 집계함수를 제외하고, 소그룹 간의 소계를 계산하는 ROLLUP 함수, GROUP BY 항목 간 다차원적인 소계를 할 수 있는 CUBE 함수,
특정 항목에 대한 소계를 계산하는 GROUPING SETS 함수가 있다.

ROLLUP은 GROUP BY의 확장된 형태로 사용하기가 쉬워 병렬로 수행할 수 있어 매우 효과적일 뿐 아니라 시간 및 지역 처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합하다.

CUBE는 결합 가능한 모든 값에 대해 다차원적인 집계를 생성하게 되므로 ROLLUP에 비해 다양한 데이터를 얻는 장점이 있는 반면, 시스템에 부하를 많이 주는 단점이 있다.

GROUPING SETS는 원하는 부분의 소계만 손쉽게 추출할 수 있는 장점이 있다.

ROLLUP, CUBE, GROUPING SETS 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 정렬 칼럼을 명시한다.

## WINDOW FUNCTION

분석함수나 순위함수로도 알려진 윈도우 함수는 데이터 하우스에서 발전한 기능이다.

---

# ROLLUP 함수

ROLLUP에 지정된 GROUPING COLUMNS의 LIST 는 SUBTOTAL을 생성하기 위해 사용되며, GROUPING COLUMNS의 수를 N이라고 했을 때 N + 1 LEVEL의 SUBTOTAL이 생성된다.
소계, 중계, 합계 처럼 계층적 분류를 포함하고 있는 데이터 집계에 적합하다.

중요한 것은 ROLLUP의 인수는 계층 구조이므로 인수 순서가 바뀌면 수행 결과도 바뀌게 되므로 순서에 유의해야한다.

```sql

-- 일반적인 GROUP BY 절 사용
SELECT B.DNAME, A.JOB, COUNT(*) AS EMP_CNT, SUM(A.SAL) AS SAL_SUM
FROM EMP A, DEPT B
WHERE B.DEPTNO = A.DEPTNO
GROUP BY B.DNAME, A.JOB;

-- GROUP BY 절 + ORDER BY 절 사용
-- DEPTNO 과 JOB을 기준으로 집계한 일반적인 GROUP BY SQL 문장에 ORDER BY 절을 사용함으로써 부서,업무별로 정렬이 이루어진다.
SELECT B.DNAME, A.JOB, COUNT(*) AS EMP_CNT, SUM(A.SAL) AS SAL_SUM
FROM EMP A, DEPT B
WHERE B.DEPTNO = A.DEPTNO
GROUP BY B.DNAME, A.JOB
ORDER BY B.DNAME, A.JOB;

-- ROLLUP 함수 사용
-- 부서명과 업무명을 기준으로 집계한 일반적인 GROUP BY SQL 문장에 ROLLUP 함수를 사용한다.
-- 실행 결과에서 2개의 GROUPING COLUMNS(DNAME, JOB)에 대한 다음과 같은 추가 LEVEL의 집계가 생성 된다.
-- L1 : GROUP BY 수행 시 생성되는 표준 집계
-- L2 : DNAME 별 모든 JOB의 SUBTOTAL
-- L3 : GRAND TOTAL
-- ROLLUP의 경우 계층 간 집계에 대해서 LEVEL별 순서를 정렬하지만, 계층 내 GROUP BY 수행 시 생성되는 표준 집계에는 별도의 정렬을 지원하지 않는다.
-- L1, L2, L3 계층내 정렬을 위해서는 별도의 ORDER BY 절을 사용해야 한다.

SELECT B.DEPARTMENT_NAME , A.JOB_ID , COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME ,A.JOB_ID )

-- ROLLUP 함수 + ORDER BY 절 사용
-- 부서명과 업무명을 기준으로 집계한 일반적인 GROUP BY SQL 문장에 ROLLUP 함수를 사용한다.
-- 추가로 ORDER BY 절을 사용해서 부서, 업무별로 정렬한다.
SELECT B.DEPARTMENT_NAME , A.JOB_ID , COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME ,A.JOB_ID )
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID

-- GROUPING 함수 사용
-- ROLLUP, CUBE, GROUPING SETS 등 새로운 그룹 함수를 지원하기 위해 GROUPING 함수가 추가됐다.
-- ROLLUP 이나 CUBE에 의해 소계가 계산된 결과에는 GROUPING(EXPR) = 1 이 표시된다.
-- 그 외의 결과에는 GROUPING(EXPR) = 0이 표시된다.
-- GROUPING 함수와 CASE/DECODE를 이용해, 소계를 나타내는 필드에 원하는 문자열을 지정할 수 있어 보고서 작성시 유용하다.

-- ROLLUP 함수를 추가한 집계 보고서에서 집계 레코드를 구분할 수 있는 GROUPING 함수가 추가된 SQL 문장이다.
-- 부서별, 업무별과 전체 집계를 표시한 레코드에서는 GROUPING 함수가 1을 반환한 것을 확인할 수 있다.
--  그리고 전체 합계를 나타내는 결과 라인에서는 부서별 GROUPING 함수와 업무별 GROUPING 함수가 둘 다 1인 것을 알 수 있다.

SELECT B.DEPARTMENT_NAME , GROUPING (B.DEPARTMENT_NAME) AS DNAME_GRP
, A.JOB_ID , GROUPING (A.JOB_ID) AS JOB_GRP
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME ,A.JOB_ID )
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID

-- GROUPING 함수 + CASE 사용
-- ROLLUP 함수를 추가한 집계 보고서에서 집계 레코드를 구분할 수 있는 GROUPING 함수와 CASE 함수를 함께 사용한 SQL 문장을 작성한다.
SELECT CASE GROUPING (B.DEPARTMENT_NAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE B.DEPARTMENT_NAME END AS DNAME
, CASE GROUPING (A.JOB_ID) WHEN 1 THEN 'ALL JOBS' ELSE A.JOB_ID END AS JOB
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME ,A.JOB_ID )
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- ORACLE의 경우는 DECODE 함수를 사용해 좀 더 간결하게 표현할 수 있다.
-- 부서별 전체 집계를 표시한 레코드에서 'ALL DEPARTMENT' 와 'ALL JOBS' 라는 사용자 정의 텍스트를 확인할 수 있다.
SELECT DECODE (GROUPING (B.DEPARTMENT_NAME), 1 , 'ALL DEPARTMENTS', B.DEPARTMENT_NAME) AS DNAME
, DECODE (GROUPING (A.JOB_ID), 1 ,'ALL JOBS' , A.JOB_ID) AS JOB
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME ,A.JOB_ID )
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- ROLLUP 함수 일부 사용
-- GROUP BY ROLLUP(DNAME, JOB) 조건에서 GROUP BY DNAME, ROLLUP(JOB) 조건으로 변경한 경우
-- 마지막 ALL DEPARTMENT & ALL JOBS 줄이 계산이 되지 않는다. ROLLUP이 JOB 칼럼에만 사용되 DNAME에 대한 집계는 필요하지 않기 때문이다.

SELECT CASE GROUPING (B.DEPARTMENT_NAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE B.DEPARTMENT_NAME END AS DNAME
, CASE GROUPING (A.JOB_ID) WHEN 1 THEN 'ALL JOBS' ELSE A.JOB_ID END AS JOB
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY B.DEPARTMENT_NAME , ROLLUP(A.JOB_ID )
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- ROLLUP 함수 결합 컬럼 사용
-- JOB과 MGR은 하나의 집합으로 간주하고 부서별, JOB & MGR에 대한 ROLLUP 결과를 출력한다.
-- JOB과 MGR의 경우 하나의 집합 칼럼으로 간주해 괄호 내 칼럼별 집계를 구하지 않는다.
SELECT B.DEPARTMENT_NAME , A.JOB_ID , A.MANAGER_ID
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY ROLLUP(B.DEPARTMENT_NAME, (A.JOB_ID, A.MANAGER_ID))
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID, A.MANAGER_ID ;
```

---

# CUBE 함수

ROLLUP 에서는 단지 가능한 SUBTOTAL 만을 생성하지만, CUBE는 결합 가능한 모든 값에 대해 다차원 집계를 생성한다. CUBE를 사용할 때는 내부적으로는 GROUPING COLUMNS의 순서를 바꿔 또 한번의 쿼리를 추가로 수행한다.
그 뿐만 아니라 GRAND TOTAL이 양쪽의 쿼리에서 모두 생성되므로 한 번의 쿼리에서는 제거되야만해 ROLLUP에 비해 시스템의 연산 대상이 많다.
이처럼 GROUPING 칼럼이 가질 수 있는 모든 경우에 대해 SUBTOTAL을 생성해야하는 때는 CUBE를 사용하는 것이 바람직하지만 시스템의 많은 부담을 주므로 사용에 주의해야한다.

CUBE 함수의 경우 표시된 인수들에 대한 계층별 집계를 구할 수 있으며, 이때 표시된 인수 간에는 계층 구조인 ROLLUP과는 달리 평등한 관계이므로 인수의 순서가 바뀌는 경우 행간에 정렬 순서는 바뀔 수 있어도 데이터 결과는 같다.
그리고 CUBE도 결과에 대한 정렬이 필요한 경우 ORDER BY 절에 명시적으로 정렬 칼럼이 표시된다.

```sql

-- CUBE 함수의 이용
-- GROUP BY ROLLUP (DNAME, JOB) 조건에서 GROUP BY CUBE(DNAME, JOB) 조건으로 변경해 수행한다.
-- CUBE는 GROUPING 칼럼이 가질수 있는 모든 경우의 수에 대해 SUBTOTAL을 생성하므로 GROUPING COLUMNS의 수가 N이라고 가정하면, 2의 N승 Level의 subtotal을 생성하게 된다.
-- 실행결과에서 CUBE 함수 사용으로 ROLLUP 함수의 결과에다 업무별 집계까지 추가해서 출력할 수 있는데, ROLLUP 함수와 비교하면 업무별 집계를 표시한 5건의 레코드가 추가된 것을 확인할 수 있따.

SELECT CASE GROUPING (B.DEPARTMENT_NAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE B.DEPARTMENT_NAME END AS DNAME
, CASE GROUPING (A.JOB_ID) WHEN 1 THEN 'ALL JOBS' ELSE A.JOB_ID END AS JOB
, COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES  A, HR.DEPARTMENTS B
WHERE A.DEPARTMENT_ID  = B.DEPARTMENT_ID
GROUP BY CUBE(B.DEPARTMENT_NAME, A.JOB_ID)
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- UNION ALL 사용 SQL
-- UNION ALL 은 SET OPERATION 내용으로, 여러 SQL 문장을 연결하는 역할을 수행할 수 있다.
-- SQL은 첫 번째 SQL 모듈부터 차례대로 결과가 나오므로 위 CUBE SQL과 결과 데이터는 같으나 행들의 정렬을 다를 수 있다.
-- CUBE 함수를 사용하면 가장 크게 개선되는 부분은 CUBE 사용 전 SQL에서 EMP, DEPT 테이블을 네 번이나 반복 액세스 하는 부분을 CUBE 사용으로 한 번으로 줄일 수 있는 부분이다.
-- 결과적으로 수행속도 및 자원 사용률을 개선할 수 있으며, SQL 문장도 더 짧아져 가독성이 높다.

SELECT B.DEPARTMENT_NAME AS DNAME , A.JOB_ID AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY B.DEPARTMENT_NAME , A.JOB_ID
UNION ALL
SELECT B.DEPARTMENT_NAME AS DNAME , 'ALL JOBS' AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A,  HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY B.DEPARTMENT_NAME
UNION ALL
SELECT 'ALL DEPARTMENTS' AS DNAME, A.JOB_ID AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY A.JOB_ID
UNION ALL
SELECT 'ALL DEPARTMENTS' AS DNAME, 'ALL JOBS' AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID

```

---

# GROUPING SETS 함수

GROUPING SETS을 이용해 더욱 다양한 소계 집합을 만들 수 있다. GROUP BY SQL 문장을 여러 번 반복하지 않아도 원하는 결과를 쉽게 얻을 수 있게 된다.
GROUPING SET에 표시된 인수들에 대한 개별 집계를 구할 수 있으며, 이때 표시된 인수 간에는 계층 구조인 ROLLUP 과 달리 평등한 관계이므로 순서 상관없이 결과는 같다.
GROUPING SETS 함수도 결과에 대한 정렬이 필요한 경우는 ORDER BY 절에 명시적으로 정렬 칼럼이 표시돼야 한다.

```sql
-- 일반 그룹 함수를 이용한 SQL
-- 실행 결과는 별도의 ORDER BY 조건을 명시하지 않았기 때문에 DNAME이나 JOB에 대해 정렬돼 있지 않다.

SELECT B.DEPARTMENT_NAME  AS DNAME, 'ALL JOBS' AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY B.DEPARTMENT_NAME
UNION ALL
SELECT 'ALL DEPARTMENTS'  AS DNAME, A.JOB_ID  AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY A.JOB_ID

-- GROUPING SETS 사용 SQL
-- 일반 그룹 함수를 GROUPING SETS 함수로 변경해 부서별, JOB 별 인원수와 급여 합을 구하라
-- GROUPING SETS 함수 사용 시 UNION ALL 을 사용한 SQL과 같은 결과를 얻을 수 있으며, 괄호로 묶은 집합 별로 집계를 구할 수 있다.
-- GROUPING SETS 은 일반 그룹함수를 이용한 SQL과 결과 데이터는 같으나 행들의 정렬 순서는 다를 수 있다.

SELECT
 CASE GROUPING(B.DEPARTMENT_NAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE B.DEPARTMENT_NAME  END AS DNAME
, CASE GROUPING(A.JOB_ID) WHEN 1 THEN 'ALL JOBS' ELSE A.JOB_ID  END AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY GROUPING SETS (B.DEPARTMENT_NAME , A.JOB_ID)
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- GROUPING SETS 사용 SQL - 순서 변경
-- 일반 그룹 함수를 GROUPING SETS 함수로 변경해 부서별, JOB별 인원수와 급여 합을 구할 때 GROUPING SETS의 인수 순서를 바꿔본다.
--  GROUPING SETS의 인수들은 평등한 관계이므로 인수의 순서가 바뀌어도 결과는 같다.
SELECT
 CASE GROUPING(B.DEPARTMENT_NAME) WHEN 1 THEN 'ALL DEPARTMENTS' ELSE B.DEPARTMENT_NAME  END AS DNAME
, CASE GROUPING(A.JOB_ID) WHEN 1 THEN 'ALL JOBS' ELSE A.JOB_ID  END AS JOB
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY GROUPING SETS (A.JOB_ID , B.DEPARTMENT_NAME)
ORDER BY B.DEPARTMENT_NAME , A.JOB_ID;

-- 3개의 인수를 이용한 GROUPING SETS 이용
-- 부서-JOB-매니저별 집계, 부서-job별 집계, JOB-매니저별 집계를 GROUPING SETS 함수를 이용해 구해본다.
-- GROUPING SETS 함수 사용 시 괄호로 묶은 집합별로 집계를 구할 수 있다.(괄호 안은 계층 구조가 아닌 하나의 데이터로 간주함)

SELECT B.DEPARTMENT_NAME, A.JOB_ID, A.MANAGER_ID
,COUNT(*) AS EMP_CNT, SUM(A.SALARY) AS SAL_SUM
FROM HR.EMPLOYEES A, HR.DEPARTMENTS B
WHERE B.DEPARTMENT_ID  = A.DEPARTMENT_ID
GROUP BY GROUPING SETS ((A.JOB_ID , B.DEPARTMENT_NAME, A.MANAGER_ID), (B.DEPARTMENT_NAME, A.JOB_ID), (A.JOB_ID,A.MANAGER_ID))
```
