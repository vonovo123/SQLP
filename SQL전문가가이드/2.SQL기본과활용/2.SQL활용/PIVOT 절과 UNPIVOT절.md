# 개요

PIVOT 은 회전시킨다는 의미를 갖고 있다. PIVOT 절은 행을 열로 회전시키고, UNPIVOT 절은 열을 행으로 회전시킨다.

## PIVOT 절

```sql
PIVOT[XML]

-- AGGREGATE_FUNCTION 은 집계할 열을 지정한다.
-- FOR 절은 PIVOT 할 열을 지정한다.
-- IN 절은 PIVOT 할 열 값을 지정한다.

  (AGGREGATE_FUNCTION (EXPR) [[AS] ALIAS]
  [, AGGREGATE_FUNCTION (EXPR) [[AS] ALIAS]]...
  FOR {COLUMN | (COLUMN [, COLUMN]...)}
  IN ({{{EXPR | (EXPR [,EXPR]...)} [[AS] ALIAS]}...
    | SUBQUERY
    | ANY [,ANY]...
  })
  )

-- 다음은 PIVOT 절을 사용한 쿼리다. PIVOT 절은 집계함수와 FOR 절에 지정되지 않은 열을 기준으로 집계되기 때문에 인라인 뷰를 통해 사용할 열을 지정해야 한다.
SELECT *
FROM (
	SELECT JOB_ID, DEPARTMENT_ID, SALARY FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) FOR DEPARTMENT_ID IN (90,60, 100))

-- 다음 쿼리는 인라인 뷰에 yyyy 표현식을 추가한 것이다. 행 그룹에 yyyy 표현식이 추가된 것을 확인할 수 있다.
SELECT *
FROM (
	SELECT
	TO_CHAR(HIRE_DATE, 'YYYY') AS YYYY, JOB_ID, DEPARTMENT_ID, SALARY
	FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) FOR DEPARTMENT_ID IN (90,60, 100))

-- 다음 쿼리는 집계함수와 IN 절에 별칭을 지정했다. 별칭을 지정하면 결과 집합의 열 명이 변경된다.

SELECT *
FROM (
	SELECT
	JOB_ID, DEPARTMENT_ID, SALARY
	FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) FOR DEPARTMENT_ID IN (90 AS D90, 60 AS D60, 100 AS D100))

-- 집계함수와 IN 절에 지정한 별칭에 따라 아래와 같은 규칙으로 열 명이 부여된다. 집계함수와 IN 절 모두 별칭을 지정하는 편이 바람직하다.

-- SUM(SALARY)            | 10  | D10
-- SUM(SALARY) AS SAL     | 10_SAL | D10_SAL

-- SELECT 절에 부여된 열 명을 지정하면 필요한 열만 조회할 수 있다.
SELECT JOB_ID , D100_SAL
FROM (
	SELECT
	JOB_ID, DEPARTMENT_ID, SALARY
	FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) AS SAL FOR DEPARTMENT_ID IN (90 AS D90, 60 AS D60, 100 AS D100))

-- PIVOT 절은 다수의 집계함수를 지원한다. 다음 쿼리는 SUM 함수와 COUNT 함수를 함께 사용한다.
SELECT *
FROM (
	SELECT
	JOB_ID, DEPARTMENT_ID, SALARY
	FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) AS SAL, COUNT(*) AS CNT FOR DEPARTMENT_ID IN (90 AS D90, 60 AS D60, 100 AS D100))

-- FOR 절에도 다수의 열을 기술할 수 있다. 다음과 같이 IN 절에 다중 열을 사용해야한다.
SELECT *
FROM (
	SELECT
	TO_CHAR(HIRE_DATE, 'YYYY') AS YYYY, JOB_ID, DEPARTMENT_ID, SALARY
	FROM HR.EMPLOYEES
)
PIVOT (SUM(SALARY) AS SAL, COUNT(*) AS CNT
		FOR (DEPARTMENT_ID, JOB_ID) IN ((90,'AD_VP') AS D90A ,(60, 'IT_PROG') AS D60A, (100,'FI_MGR')AS D100A))
ORDER BY 1;

-- PIVOT 절을 사용할 수 없는 경우 집계함수와 CASE 표현식으로 PIVOT을 수행할 수 있다.

SELECT JOB_ID
, SUM(CASE DEPARTMENT_ID WHEN 90 THEN SALARY END) AS D90_SAL
, SUM(CASE DEPARTMENT_ID WHEN 60 THEN SALARY END) AS D60_SAL
, SUM(CASE DEPARTMENT_ID WHEN 100 THEN SALARY END) AS D100_SAL
FROM HR.EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID
```

## UNPIVOT 절

UNPIVOT 절은 PIVOT 절과 반대로 동작한다. 열이 행으로 전환된다.

```sql

  -- UNPIVOT column 절은 UNPIVOT 값이 들어갈 열을 지정한다.
  -- FOR 절은 UNPIVOT 된 값을 설명할 값을 들어갈 열을 지정한다.
  -- IN 절은 UNPIVOT할 열과 설명할 값을 리터럴 값을 지정한다.
  UNPIVOT [{INCLUDE | EXCLUDE} NULLS]
  (
    { COLUMN | (COLUMN[, COL]...)}
    FOR { COLUMN | (COLUMN[, COL]...)}
    IN ({ COLUMN | (COLUMN[, COL]...)}[AS {LETERAL|(LITERAL[, LITERAL]...)}]
    [, { COLUMN | (COLUMN[, COL]...)}[AS {LETERAL|(LITERAL[, LITERAL]...)}]]...
    )
  )

-- 테이블 생성
DROP TABLE T1 PURGE;

CREATE TABLE T1 AS
SELECT JOB_ID, D100_SAL, D60_SAL, D100_CNT, D60_CNT
FROM(
	SELECT JOB_ID, DEPARTMENT_ID, SALARY
	FROM  HR.EMPLOYEES
	WHERE JOB_ID IN ('IT_PROG', 'FI_ACCOUNT')
)
PIVOT(SUM(SALARY) AS SAL, COUNT(*) AS CNT FOR DEPARTMENT_ID IN
(100 AS D100, 60 AS D60))

-- 생성한 테이블 조회
SELECT * FROM T1 ORDER BY JOB_ID

-- UNPIVOT 절을 사용한 쿼리이다.
SELECT JOB_ID, DEPARTMENT_ID, SAL
FROM T1
UNPIVOT(SAL FOR DEPARTMENT_ID IN (D100_SAL, D60_SAL))
ORDER BY 1,2;

-- IN 절에 별칭을 지정하면 FOR 절에 지정한 열의 값을 변경할 수 있다.
SELECT JOB_ID, DEPARTMENT_ID, SAL
FROM T1
UNPIVOT(SAL FOR DEPARTMENT_ID IN (D100_SAL AS 100, D60_SAL AS 60))
ORDER BY 1,2;

-- 다음과 같이 INCLUDE NULLS 키워드를 기술하면 UNPIVOT 된 열의 값이 널인 행도 결과에 포함된다.
SELECT JOB_ID, DEPARTMENT_ID, SAL
FROM T1
UNPIVOT INCLUDE NULLS (SAL FOR DEPARTMENT_ID IN (D100_SAL AS 100, D60_SAL AS 60))
ORDER BY 1,2;

-- FOR 절에 다수의 열, IN 절에 다수의 별칭을 지정할 수 있다.
SELECT *
FROM T1
UNPIVOT ((SAL, CNT) FOR DEPARTMENT_ID IN ((D100_SAL, D100_CNT) AS 100, (D60_SAL, D60_CNT)  AS 60))
ORDER BY 1,2;

-- FOR 절에 다수의 열, IN 절에 다수의 별칭을 지정할 수 있다.
SELECT *
FROM T1
UNPIVOT ((SAL, CNT) FOR (DEPARTMENT_ID, DEPARTEMT_NAME) IN ((D100_SAL, D100_CNT) AS (100, 'PROG'), (D60_SAL, D60_CNT)  AS (60, 'ACCOUNT')))
ORDER BY 1,2;

-- UNPIVOT 절을 사용할 수 없는 경우 카티션 곱을 사용해 대체할 수 있다.
-- UNPIVOT할 열의 개수만큼 행을 복제하고, CASE 표현식으로 UNPIVOT 할 열을 선택하는 방식이다.

SELECT A.JOB_ID
, CASE B.LV WHEN 1 THEN 100 WHEN 2 THEN 60 END AS DEPTNO
, CASE B.LV WHEN 1 THEN A.D100_SAL WHEN 2 THEN A.D60_SAL END AS SAL
, CASE B.LV WHEN 1 THEN A.D100_CNT WHEN 2 THEN A.D60_CNT END AS CNT
FROM T1 A
, (SELECT LEVEL AS LV FROM DUAL CONNECT BY LEVEL <=2) B
ORDER BY 1,2;

-- 다음 실행 결과에서 강조한 부분이 CASE 표현식으로 선택한 값이다.

SELECT A.JOB_ID, B.LV, A.D100_SAL, A.D60_SAL, A.D100_CNT, A.D60_CNT
FROM T1 A
, (SELECT LEVEL AS LV FROM DUAL CONNECT BY LEVEL <=2) B
ORDER BY A.JOB_ID, B.LV;
```
