# 메커니즘

해시조인은 NL Join 이나 SORT MERGE JOIN 이 효과적이지 못한 상황을 해결하고자 나온 방식이다.

```sql
-- 해시 조인으로 유도했을 때의 실행계획이다.

SELECT /*+ordered use_hash(E)*/ D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME
FROM SCOTT.DEPT D, SCOTT.EMP E
WHERE D.DEPTNO = E.DEPTNO

Execution Plan
----------------------------------------------------------
Plan hash value: 615168685

---------------------------------------------------------------------------
| Id  | Operation	   | Name | Rows  | Bytes | Cost (%CPU)| Time	  |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |	  |    14 |   364 |	7  (15)| 00:00:01 |
|*  1 |  HASH JOIN	   |	  |    14 |   364 |	7  (15)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| DEPT |	4 |    52 |	3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| EMP  |    14 |   182 |	3   (0)| 00:00:01 |
---------------------------------------------------------------------------

```

해시 조인은 둘 중 작은 집합을 읽어 해시 영역에 해시 테이블을 생성하고 반대쪽 큰 집합을 읽어 해시테이블을 탐색하면서 조인하는 방식이다.
해시 함수는 출력값을 미리 알 순 없지만, 같은 입력값에 대해 같은 출력값을 보장하는 함수다.
다른 입력값에 대한 출력값이 같을 수 있는데 이를 '해시 충돌' 이라고 한다. 해시 테이블을 만들 때 해시 충돌이 발생하면, 입력값이 다른 엔트리가 같은 해시버킷에 담길 수 있다.

- 1단계 : 해시 테이블 생성도 집합 중 작다고 판단되는 집합을 읽어 해시 테이블을 만듣나. 해시 테이블을 만들 때 해시 함수를 사용한다. 해시 테이블은 해시 버킷으로 구성되 배열이라고 생각하면 된다.
  해시 함수에서 리턴받을 해시 값이 같은 데이터를 같은 해시 버킷에 체인으로 연결한다.

- 2단계 : PROBE INPUT을 스캔해시 테이블 생성을 위해 선택되지 않은 나머지 데이터 집합을 스캔한다.

- 3단계: 해시 테이블 탐색 PROBE INPUT에서 읽은 데이터로 해시 테이블을 탐색할 때도 해시 함수를 사용한다. 즉 해시 함수에서 리턴받은 버킷 줏소로 찾아가 해시 체인을 스캔하며넛 데이터를 찾는다.

해시 조인은 조인과정에서 발생하는 랜덤 액세스나 정렬에 대한 부담이 없다. 다만 해시 테이블을 생성하는 비용이 수반된다. 따라서 BUILD INPUT이 작을 때라야 효과적이다.
만약 HASH BUILD를 위해 가용한 메모리 공간을 초과할 정도로 BUILD INPUT이 대용량 테이블이면 디스크에 썼다가 다시 읽어 들이는 과정을 거치기 때문에 성능이 많이 저하된다.

BUILD INPUT으로 선택된 테이블이 작은 것도 중요하지만 해시 키 값으로 사용되는 칼럼에 중복 값이 거의 없어야 효과적이다.

해시테이블 을 만드는 단계는 전체범위처리가 불가피하지만, 반대쪽 probe input을 스캔하는 단계는 nl 조인처럼 부분범위처리가 가능하다.

---

# BUILD INPUT 이 가용 메모리 공간을 초과할 때 처리 방식

IN-MEMORY 해시 조인이 불가능할 때 DBMS는 GRACE 해시 조인이라고 알려진 조인 알고리즘을 사용한다.

- 파티션 단계

  조인되는 양쪽 집합 모두 조인 칼럼에 해시 함수를 적용하고 반환된 해시 값에 따라 동적으로 파티셔닝을 생성한다. 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합을 분할함으로써 파티션 짝을 생성한다.
  파티션 단계에서 양쪽 집합을 모두 읽어 디스크 상의 임시 공간에 일단 저장해야 하므로 IN-MEMORY 해시조인보다 성능이 떨어진다.

- 조인 단계

  파티션 단계가 완료되면 각 파티션 짝에 대해 하나씩 조인을 수행한다. 이때 각각에 대한 BUILD INPUT과 PROBE INPUT이 독립적으로 결정된다.
  즉, 파티션하기 전 어느 쪽이 작은 테이블이었는지 상관없이 각 파티션 짝 별로 작은 쪽 파티션을 BUILD INPUT으로 선택해서 해시 테이블을 생성한다.
  테이블이 생성되면 반대 쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색하며, 모든 파티션 짝에 대한 처리가 완료될 때까지 과정을 반복한다.

- RECURSIVCE 해시 조인

  디스크에 기록된 파티션 짝 끼리 조인을 수행하려고 작은 파티션을 메모리에 로드하는 과정에서 또다시 가용 메모리를 초과하는 겨우가 발생할 수 있다.
  그럴때는 추가적인 파티셔닝 단계를 거치는데, 이를 RECURSIVCE 해시 조인이라고 한다.

---

# BUILD INPUT 해시 키 값에 중복이 많을 때 발생하는 비효율

해시 알고리즘의 성능은 충돌을 얼마나 최소화할 수 있느냐에 달렸다. 이를 방지하려면 그 만큼 많은 해시 버킷을 할당해야만 한다.
DBMS는 가능하면 충분히 많은 개수의 버킷을 할당함으로써 버킷 하나당 하나의 키 값만 갖게 하려고 노력한다,

---

# 해시 조인 사용기중

해시 조인 성능을 좌우하는 두 가지 키 포인트는 다음과 같다.

- 한 쪽 테이블이 가용 메모리에 담길 정도로 충분히 작아야함
- BUILD INPUT 해시 키 칼럼에 중복 값이 없어야함.

해시 조인을 언제 사용하는ㄴ 것이 가장 효과적인지 그 선택 기준을 살펴보자

- 조인 칼럼이 적당한 인덱스가 없어 NL 조인이 비효율적일 때
- 조인 칼럼에 인덱스가 있더라도 NL 조인ㄴ 드라이빙 집합에서 inner 쪽 집합으로의 조인 엑세스량이 많아 랜덤 엑세스 부하가 심할 때
- 소트 머지 조인 하기에는 두 테이블이 너무 커 소트 부하가 심할때
- 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할 때

해시 조인이 등장하면서 소트 머지 조인의 인기가 많이 떨어졌다.
다만, 모든 조인을 해시 조인으로 처리하려는 유횩에 빠지기 쉬운데 이는 매우 위험하다.
해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조이다. 따라서 CPU와 메모리 사용률을 크게 증가시킴은 물론, 메모리 자원 확보를 위해 시스템 동시성이 떨어질 수 있다.
