# 인라인뷰 활용

대부분의 조인은 1:M 관계인 테이블끼리의 조인이다. 조인 결과는 M 쪽 집합과 같은 단위가 된다.
이를 다시 1 쪽 집합 단위로 그룹핌해야 한다면, M쪽 집합을 먼저 1쪽 단위로 그룹핑하고나서 조인하는 것이 유리하다.
조인 횟수를 줄여주기 때문이다. 이런 처리를 위해 인라인 뷰를 사용할 수 있다.

```sql
-- T1 일별 상품판매
-- T2 상품
-- 2009년도 상품별 판매수량과 판매금액을 집계하는 쿼리

SELECT  MIN(T2.T_NAME) T_NAME, SUM(T1.T_COUNT) T_COUNT, SUM(T1.T_AMOUNT) T_AMOUNT
FROM T1, T2
WHERE T1.T_DATE BETWEEN '20090101' AND '20091230'
AND T1.P_CODE = T2.P_CODE
GROUP BY T2.P_CODE

```

ROW SOURCE OPERATION을 분석해 보면, 일별상품판매 테이블로부터 읽힌 365,000개 레코드마다 상품 테이블과 조인을 시도 했다.
조인과정에서 730,002 개의 블록 I/O가 발생했고 총 소요시간은 13.8초이다.

다음과 같이 상품코드별로 먼저 집계하고 조인을 하도록 바꾸고 다시 수행한다.

```sql

-- T1 일별 상품판매
-- T2 상품
-- 2009년도 상품별 판매수량과 판매금액을 집계하는 쿼리

SELECT T2.T_NAME, T1.T_COUNT, T1.T_AMOUNT
FROM (
SELECT  MIN(T2.T_NAME) T_NAME, SUM(T1.T_COUNT) T_COUNT, SUM(T1.T_AMOUNT) T_AMOUNT
FROM T1
WHERE T_DATE BETWEEN '20090101' AND '20091230'
GROUP BY P_CODE
) T1, T2
WHERE T1.P_CODE = T2.P_CODE

```

상품코드별로 먼저 집계한 결과건수가 1000건이므로 상품테이블과의 조인도 1000번만 발생했다.
조인 과정에서 발생 BLOCK I/O 또한 2101개에 불과하고 수행시간도 5.5초 이다.

---

# 배타적 관계의 조인

어떤 엔터티가 두 개 이상의 다른 엔터티의 합집합과 관계를 갖는 것을 상호 배타적 관계라고 한다

예를 들어 고객으로부터 개통이나 장애처리 요청을 받으면 작업기사에게 작업지시서를 발행한다. 한 작업자에게만 작업지시를 내릴때가 많지만, 작업 내용에 따라서는 여러 작업자가 필요할 수도 있다.
또한 여러 작업자가 동시에 출동하는가 하면 시간 간격을 두고 따로 출동하기도 한다.
개통신청과 장애접수는 관리하는 속성이 상당히 달라 별도의 테이블로 설계한다,
반만 작업지시는 개통 신청이든 장애 접수든 거의 같은 속성을 관리하므로 한 테이블로 설계한다.
한 테이블로 통합하더라도 개통신청이나 장애접수 중 어느 것과 관계를 갖는지 구분할 수 있어야한다.

데이터 모델을 실제 데이터베이스로 구현할 때, 작업지시 테이블에는 아래 두 가지 방법중 하나를 사용한다

- 개통신청번호와 장애접수번호 두 칼럼을 따로 두고 레코드별로 둘중 하나의 칼럼에만 값을 입력한다.

- 작업구분과 접수번호 칼럼을 두고, 작업구분이 1일 때는 개통신청번호를입력하고 2일대는 장애접수번호를 입력한다.

```sql
-- 1번 처럼 설계할 때는 다음과 같이 outer 조인으로 간단하게 쿼리를 작성할 수 있다.
SELECT /*+ordered use_nl(b) use_nl(c)*/
a.작업일련번호, a.작업일자id, a.작업상태코드
, nvl(b.고객번호, c.고객번호) 고객번호
, nvl(b.주소, c.주소) 주소
FROM 작업지시 a, 개통신청 b, 장애접수 c
where a.방문예정일시 Between :방문예정일시1 and :방문예정일시2
And b.개통신청번호(+) = a.개통신청번호
and C.장애접수번호(+) = a.장애접수번호

-- 2번처럼 설계했을때는 union all을 이용할 수 있다.
SELECT
a.작업일련번호, a.작업일자id, a.작업상태코드
, a.고객번호, a.주소
FROM 작업지시 a, 개통신청 b
where a.방문예정일시 Between :방문예정일시1 and :방문예정일시2
and a.작업구분 = '1'
And b.개통신청번호 = a.개통신청번호
union all
a.작업일련번호, a.작업일자id, a.작업상태코드
, a.고객번호, a.주소
FROM 작업지시 a, 장애접수 b
where a.방문예정일시 Between :방문예정일시1 and :방문예정일시2
and a.작업구분 = '2'
And b.장애접수번호 = a.개통신청번호
```

UNION ALL을 중심으로 쿼리를 위아래 두 번 수행했지만, 만약 [작업구분 + 방문예정일시] 순으로 구성된 인덱스를 이용한다면 읽는 범위에 중복은 없다.
하지만 [방문예정일시 + 작업구분 ] 순으로 구성된 인덱스를 이용하면 인덱스 스캔범위에 중복이 생긴다.
[방문예정일시] 만으로 구성된 인덱스를 이용한다면 작업구분을 필터링하기 위한 테이블 랜덤 엑세스까지 중복해서 발생한다.

다음과 같이 쿼리함으로서 중복 엑세스에 의한 비효율을 해소할 수 있다.

```sql
SELECT /*+ordered use_nl(b) use_nl(c)*/
a.작업일련번호, a.작업일자id, a.작업상태코드
, nvl(b.고객번호, c.고객번호) 고객번호
, nvl(b.주소, c.주소) 주소
FROM 작업지시 a, 개통신청 b, 장애접수 c
where a.방문예정일시 Between :방문예정일시1 and :방문예정일시2
And b.개통신청번호(+) = decode(a.작업구분, '1', a.접수번호)
and C.장애접수번호(+) = decode(a.작업구분, '2', a.접수번호)
```

---

# 부등호 조인

일반적으로 '=' 연산자 조인에만 익숙하더라도 업무에 따라서는 between,like,부등호 같은 연산자로 조인해야할 때가 있다.

```sql
-- 월별지점매출 테이블을 이용해 지점별로 판매월과 함께 증가하는 누적매출을 구한다.
-- 윈도우 함수를 이용해 다음과 같이 간단히 원하는 결과를 얻을 수 있다
SELECT 지점, 판매월, 매출, sum(매출) over(partition by 지점 order by 판매월
range between unbounded preceding and current row) 누적 매출
from 월별지점매출

-- 다음과 같이 부등호 조인을 이용해 같은 결과를 얻을 수 있다.
SELECT t1.지점, T1.판매월, min(t1.매출), sum(t2.매출)
FROM 월별지점매출 t1, 월별지점매출 t2
where t2.지점 = T1.지점
and t2.판매월 <= t1.판매월
group by t1.지점, t2.판매월
order by t1.지점, t2.판매월
```

# between 조인

## 선분이력이란?

고객별연체금액 변경을 관리할 때 이력의 시작점만 관리하는 것을 '점이력' 모델이라고 하고
시작시점과 종료시점을 함께 관리하는 것을 '선분이력' 모델이라고 한다.
선분이력 모델에서 가장 마지막 이력의 종료일자는 항상 '99991231' 혹은 시간까지 관리할때는 '99991231235959'로 입력해둬야한다.

이력을 이처럼 선분형태로 관리하면 무엇보다 쿼리가 간단해진다는 것이 장점이다.

```sql
-- 예를 들어 123번 고객의 2004년 8월 15일 시점 이력을 조회하고자 할때 다음과같이 between 조인을 이용해 간편하게 조회할 수 있다.

SELECT 고객번호, 연체금액, 연체개월수
FROM  고객별연체금액
WHERE 고객번호 = '123'
AND '20040815' between b.시작일자 and b.종료일자;

-- 데이터를 일반적인 점이력으로 관리할 때 아래처럼 서브쿼리를 이용해 복잡하게 쿼리하던 것과 비교된다.

SELECT 고객번호, 연체금액, 연체개월수
FROM  고객별연체금액 a
WHERE 고객번호 = '123'
And 연체변경일자 = (
  select max(연채변경일자)
  from 고객별연체금액
  where 고객번호 = a.고객번호
  and 변경일자 < '20040815';
)

```

쿼리가 간단하면 아무래도 성능상 유리하지만 선분이력에 장정만 있는 것은 아니다.
우선 이력이 추가될 때마다 기존 최종 이력의 종료일시도 같이 변경해줘야하는 불편함과, 이때문에 발생하는 DML 부하를 고려해야한다.

PK를 어떻게 구성하느냐에 따라 다르지만 성능을 고려해 일반적으로 [마스터 키 + 종료일자 + 시작일자] 순으로 구성하곤 한다.
이럴 경우 이력을 변경할 때마다 pk 값을 변경하는 셈이어서 설계 사상과 맞지않다는 지적도 있다.
무엇보다 개체 무결성을 완벽히 보장하기 어렵다는 단점이 있다.

---

## 선분이력 기본 조회 패턴

선분이력이 자주 사용되는 기본조회 패턴을 정리해보자. 단일 테이블 조회만을 기준으로 한다.
가장 기본적인 패턴으로 과거,현재,미래 임의 시점을 모두 조회할 수 있도록 하려면 아래처럼 쿼리를 작성한다.

```sql
SELECT 연체개월수, 연체금액
FROM 고객별연체금액
WHERE 고객번호 = :cust_num
AND :dt between 시작일자 and 종료일자

-- 현재 시점을 조회할 때는 '99991231' 상수 조건을 이용해 등차조건으로 검색하는 것이 성능상 유리하다

SELECT 연체개월수, 연체금액
FROM 고객별연체금액
WHERE 고객번호 = :cust_num
AND 종료일자 = '99991231'

-- 주의할 것은 선분이력 테이블에 정보를 미리 입력해두는 경우가 종종 있고 그럴때는 현재 시점을 위와 같이 조회해서는 안된다.
-- 그럴 때는 현재이력을 다음과 같이 조회해야한다.

SELECT 연체개월수, 연체금액
FROM 고객별연체금액
WHERE 고객번호 = :cust_num
AND to_char(sysdate, 'yyymmdd') between 시작일자 and 종료일자
```

---

## 선분이력 조인

2개 이상의 선분이력을 조인하는 경우를 살펴보자

```sql

-- 과거,현재,미래의 임의 시점 조회
-- 고객등급과 전화번호 변경이력을 관리하는 두 선분이력 테이블이 있다.
-- 고객과 두 선분이력 테이블을 조인해서 2004년 8월 15일 시점 데이터를 조회할때는 다음과 같이 쿼리한다.

SELECT C.고객번호, C.고객명, c1.고객등급, c2.전화번호
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
where c.고객번호 = :cust_num
and c1.고객번호 = c.고객번호
and c2.고객번호 = c.고객번호
and :dt between C1.시작일자 and C1.종료일자
and :dt between C2.시작일자 and C2.시작일자

-- 현재시점조회
-- 위 쿼리를 이용해 과거,현재,미래 어느 시점이든 조회할 수 있지만, 만약 미래 시점 데이터를 미리 입력하는 예약기능이 없다면 현재시점조회는 다음과 같이 = 조건으로 만들어 주는 것이 효과적이다.

SELECT C.고객번호, C.고객명, c1.고객등급, c2.전화번호
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
where c.고객번호 = :cust_num
and c1.고객번호 = c.고객번호
and c2.고객번호 = c.고객번호
AND C1.종료일자 = '99991231'
AND C2.종료일자 = '99991231'

-- 미래시점데이터를 미리 입력하는 기능이 있다면, 현재 시점을 조회할 때 다음과 같이 조회해야 한다.
SELECT C.고객번호, C.고객명, c1.고객등급, c2.전화번호
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
where c.고객번호 = :cust_num
and c1.고객번호 = c.고객번호
and c2.고객번호 = c.고객번호
AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN C1.시작일자 AND C1.종료일자
AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN C2.시작일자 AND C2.종료일자
```

---

## BETWEEN 조인

지금까지는 선분이력 조건이 상수였다. 즉 조회 시점이 정해져있었다.
만약 우측과 같은 일별 거래 테이블로부터 읽히는 미지의 거래일자 시점으로 선분이력을 조회할 때는 BETWEEN 조인을 이용하면 된다.

```sql
-- 다음은 주식시장에서 과거 20년 동안 당일 최고가로 장을 마친 종목을 조회하는 쿼리다.
-- 일별종목거래및시세 테이블로부터 시가, 종가, 거래 데이터를 읽고 그 당시 종목명과 상장주식수는 종목이력으로부터 가져오는데
-- 조인 연산자가 '='이 아니라 between 이라는 점이 특이하다.
-- 이런 식으로 조회하면 현재 시점의 종목명을 가져오는 것이 아니라 거래가 일어난 바로 그 시점의 종목명을 읽게된다.
SELECT *
FROM 일별종목거래및시세 A, 종목이력 B
WHERE A.거래일자 between to_char(add_months(sysdate, -20*12, 'yyyymmdd'))
AND to_char(sysdate, -1, 'yyyymmdd')
AND A.종가 = A.최고가
AND B.종목코드 = A.종목코드
AND A.거래일자 BETWEEN B.시작일자 AND B.종료일정

-- 거래 시점이 아니라 현재 시점의 종목명과 상장지수를 출력하려면 BETWEEN 조인 대신 다음과 같이 상수 조건으로 입력해야한다.
-- 종목 테이블을 종목이력과 통합해 하나로 설계했을 때 사용가능한 방식이다.
-- 종목과 종목이력을 따로 설계했을 때는 최종 시점을 위해 종목 테이블과 조인하면 된다.

SELECT *
FROM 일별종목거래및시세 A, 종목이력 B
WHERE A.거래일자 between to_char(add_months(sysdate, -20*12, 'yyyymmdd'))
AND to_char(sysdate, -1, 'yyyymmdd')
AND A.종가 = A.최고가
AND B.종목코드 = A.종목코드
AND to_char(sysdate, 'yyyymmdd') BETWEEN B.시작일자 AND B.종료일정


```

---

# ROWID 활용

선분이력과 대비해, 데이터 변경이 발생할 때마다 변경일자와 함께 새로운 이력 레코드를 쌓는 방식을 '점이력' 이라고 한다.

```sql
-- 점이력 모델에선 일반적으로 서브쿼리를 이용해 다음과 같이 조회한다. 즉 찾고자하는 시점보다 앞선 변경일자 중 가장 마지막 레코드를 찾는 것이다.
SELECT *
FROM 고객 A, 고객별연체이력 B
WHERE A.가입회사 = 'C70'
AND B.고객번호 = A.고객번호
AND B.변경일자 = (
  SELECT MAX(변경일자)
  FROM 고객별연체이력
  WHERE 고객번호 = A.고객번호
  AND 변경일자 <= a.서비스만료일
)
```

고객별 연체이력을 두 번 액세스하고 있다. 다행스럽게도 옵티마이저가 서브쿼리내에서 서비스만료일보다 작은 레코드를 모두 스캔하지 않고, 인덱스를 거꾸로 스캔하면서 가장 큰 값 하나만을 찾는 실행계획을 수립했다.

만약 위 쿼리가 빈번하게 수행되어 단 한 블록 엑세스라도 줄여야한다면 ROWID를 이용해 조인하는 다음과 같은 튜닝 기법을 적용해 볼 수 있다.

```SQL
SELECT *
FROM 고객 A, 고객별연체이력 B
WHERE A.가입회사 = 'C70'
AND B.고객번호 = A.고객번호
AND B.ROWID = (
  SELECT /*+ INDEX(C 고객별연체이력_ㅑㅇㅌ01) */ rowid
  FROM 고객별연체이력
  WHERE 고객번호 = A.고객번호
  AND 변경일자 <= a.서비스만료일
  AND rownum <= 1
)
```

고객 a에서 읽은 고객번호로 서브쿼리 쪽 고객별연체이력과 조인하고, 거기서 얻은 rowid 값으로 고객별연체이력 b를 바로 액세스한다.
쿼리에 고객별연체이력을 두 번 참조했지만. 실행계획 상에는 한 번만 조인한 것과 일략이 같다.
위 쿼리가 제데로 작동하려면 고객별연체이력\_idx01 인덱스가 반드시 [고객번호 + 변경일자] 순으로 구성돼 있어야 한다. 혹시라도 인덱스 구성이 변경되면 그때부터 쿼리 결과가 달라질 수 있음을 반드시 기억해야한다.
First row(min/max) 알고리즘이 작동한다면 일반적으로 그것만으로도 충분한 성능을 내므로 굳이 위와 같은 기법을 적용하지 않는 것이 좋다.
그럼에도 성능이 아주 중요한 프로그램이어서 어쩔 수 없이 위 방식을 쓰게 될 때는, 프로그램 목록을 관리했다가 인덱스 구성 변경시 확인하는 프로세스를 거쳐야한다.
