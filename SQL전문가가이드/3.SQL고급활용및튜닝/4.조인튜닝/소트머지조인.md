NL 조인은 조인 컬럼을 선두로 갖는 인덱스가 있는지가 매우 중요하다. 만약 조인 칼럼을 선두로 갖는 인덱스가 없으면 OUTER 테이블에서 읽히는 것마다 INNER 테이블 전체를 스캔하기 때문이다.
그럴 때 옵티마이저는 소트머지 조인이나 다음 절에서 설명할 해시 조인을 고려한다.

소트머지 조인은 이름이 의미하는 것 처럼 두 테이블을 각각 정렬한 다음 두 집합을 머지하면서 조인을 수행한다.

- 소트단계 : 양쪽 집합을 조인 칼럼 기준으로 정렬한다.
- 머지단계 : 정렬된 양쪽 집합을 서로 머지 한다.

조인 칼럼에 인덱스가 있으면(ORACLE의 경우 OUTER 테이블에만 해당) 소트 단계를 거치지 않고 곧바로 조인할 수도 있다.
ORACLE은 조인 연산자가 부등호이거나 아예 조인 조건이 없어도 소트머지 조인으로 처리할 수 있지만, SQL server는 조인 연산자가 = 일 때만 소트 머지 조인을 수행한다.

# 메커니즘

```sql
-- 아래 sql은 DEPT 테이블을 기준으로 EMP 테이블과 조인할 때 소트 머지 조인 방식을 사용하라고 지시하고 있다.

SELECT /*+ORDER USE_MERGE(E)*/ D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME
FROM SCOTT.DEPT D, SCOTT.EMP E
WHERE D.DEPTNO = E.DEPTNO

Execution Plan
----------------------------------------------------------
Plan hash value: 3381633735


--------------------------------------------------------------------------------
--------

|   0 | SELECT STATEMENT	     |	       |    14 |   364 |     6	(17)| 00
:00:01 |

|   1 |  MERGE JOIN		     |	       |    14 |   364 |     6	(17)| 00
:00:01 |

|   2 |   TABLE ACCESS BY INDEX ROWID| DEPT    |     4 |    52 |     2	 (0)| 00
:00:01 |

|   3 |    INDEX FULL SCAN	     | PK_DEPT |     4 |       |     1	 (0)| 00
:00:01 |

|*  4 |   SORT JOIN		     |	       |    14 |   182 |     4	(25)| 00
:00:01 |

|   5 |    TABLE ACCESS FULL	     | EMP     |    14 |   182 |     3	 (0)| 00
:00:01 |

--------------------------------------------------------------------------------
--------

```

주목할 점은 INNER 집합인 emp table이 정렬돼 있기 때문에 조인에 실패하는 레코드를 만나는 순간 멈출 수 있다는 사실이다.
또 한 가지는 정렬된 EMP 에서 스캔 시작점을 찾으려고 매번 탐색하지 않아도 된다는 점이다.
OUTER 집합인 Dept 테이블도 같은 순서로 정렬돼 있으므로 가능한 일이다.

다음은 소트 머지 조인이 머지하는 방식을 PSEUDO 코드로 작성한 것이다

```
OUTER 집합(정렬된 dept) 에서 첫 번째 로우 o를 가져온다.
INNER 집합 (정렬된 emp) 에서 첫 번째 로우 i를 가져온다.
LOOP
  양쪽 집합 중 어느 것이든 끝에 도달하면 Loop를 빠져나간다
  IF O = I
    조인에 성공한 로우를 리턴한다
    inner 집합에서 다음 로우 i 를 가져온다.
  ELSE IF O < I
    outer 집합에서 다음 로우 o를 가져온다.
  ELSE
    INNER 집합에서 다음 로우 I를 가져온다
  END IF
END LOOP
```

---

# 소트 머지 조인의 특징

- 조인 하기 전에 양쪽 집합을 정렬한다.

NL조인은 정렬없이 OUTER 집합을 한 건씩 차례로 조인을 진행하지만, 소트 머지 조인은 양쪽 집합을 조인 칼럼 기준으로 정렬할 후 조인을 시작한다.
대량 집합 조인으 랜덤 액세스 위주의 NL 조인의 경우 비효율이 있다. 이 비효율을 줄이고자 나온 조인 방식이 소트 머지 조인이다.
만약 정렬해야 할 집합이 초대용량 테이블이면 정렬자체가 큰 비용을 수반하기 때문에 성능 개선 효과를 얻지 못할 수 있다. 하지만 일반 인덱스나 클러스터형 인덱스처럼 미리 정렬된 오브젝트를 이용하면
바로 조인을 수행할 수 있어 소트 머지 조인이 조흥ㄴ 대안이 된다.

- 부분적으로 부분범위처리가 가능하다

소트 머지 조인은 양쪽 집합을 정렬해야 함으로 부분처리가 불가능할 것 같지만 가능하다.
일부로우만 FETCH 하다가 멈춘다면 OUTER 집합은 끝까지 읽지 않아도 되기 때문이다.

- 테이블별 검색 조건에 의해 전체 일량이 좌우된다.

NL 조인은 OUTER 집합의 건마다 INNER 집합을 탐색한다. 이 때문에 OUTER 집합에서 조인 대상이 되는 건수에 의해 전체 일량이 좌우된다.
그러나 소트머지 조인은 두 집합을 각각 정렬 후에 조인함으로 각 집합의 크기, 즉 테이블별 검색 조건에 의해 일량이 좌우된다.

- 스캔 위주의 조인 방식이다.
  NL 조인이 랜덤 액세스 위주의 조인방식이라면 소트 머지 조인은 스캔 위주의 조인방식이다. INNER TABLE은 반복 액세스하지 않응므로 머지 과정에서 랜덤 액세스가 발생하지 않는다,.
  각 테이블의 검색 조건에 해당하는 대상 집합을 찾을 때 인덱스를 이용한 렌덤 액세스 방식으로 처리 될 수 있고, 이때 발생하는 랜덤 엑세스량이 많다면 소트머지 조인의 이점이 사라질 수 있다,.
