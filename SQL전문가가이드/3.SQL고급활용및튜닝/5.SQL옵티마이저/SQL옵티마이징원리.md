# 옵티마이저 소개

## 옵티마이저 종류

- 규칙기반 옵티마이저
  규칙기반 옵티마이저는 다른 말로 휴리스틱 옵티마이저라고 불리며, 미리 정해 놓은 규칙에 따라 엑세스 경로를 평가하고 실행계획을 선택한다.
  여기서 규칙이란엑세스 경로별 우선순위로서, 인덱스 구조, 연산자, 조건절 형태가 순위를 결정짓는 주요인이다.

- 비용기반 옵티마이저
  비용기반 옵티마이저(CBO)는 말 그대로 비용을 기반으로 최적화르 수행한다.
  비용이란 쿼리를 수용하는데 소요되는 일량 또는 시간을 뜻한다.
  CBO가 실행계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치이다.

---

## 최적화 목표

- 전체 처리속도 최적화

쿼리 최종 결과 집합을 끝까지 읽는 것을 전제로, 시스템 리소스를 가장 적게 사용하는 실행계획을 선택한다.
대부분의 DBMS 기본 옵티마이저 모드는 전체 처리속도 최적화에 맞춰져 있다.

```sql
ALTER SYSTEM SET OPTIMIZER_MODE = ALL_ROWS; -- 시스템 레벨 변경
ALTER SESSION SET OPTIMIZER_MODE = ALL_ROWS; -- 세션 레벨 변경
SELECT /*+ALL_ROWS*/ * FROM T WHERE ... -- 쿼리 례벨 변경
```

- 최초 응답속도 최적화

전체 결과 집합 중 일부만 읽다가 멈추는 것을 전제로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택한다.
만약 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면, 전체 처리속도 최적화 실행계획보다 더 많은 리소스를 사용하고 전체 수행 속도도 느려질 수 있다.
옵티마이저에게 최초 응답속도 최적화를 요구하려면, 옵티마이저 모드를 FIRst_rows 로 바꿔주면 된다.
ORACLE에서 옵티마이저 모드를 First_rows_n으로 지정하면, 예를 들어 시스템 또는 세션 레벨에서 FIRst_rows_10으로 지정하면,
사용자가 전체 결과 집합 중 처음 10개 로우만 읽고 멈추는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택하다.

```SQL
-- 쿼리 레벨에서 힌트를 사용하려면 다음과 같이하면 된다.
SELECT /*+ FIRST_ROWS(10) */ * FROM WHERE ;
```

---

# 옵티마이저 행동에 영향을 미치는 요소

## SQL과 연산자 형태

결과가 같더라도 SQL을 어떤 형태로 작성했는지 또는 어떤 연산자를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 이는 쿼리 성능에 영향을 미친다.

---

## 옵티마이징 팩터

쿼리를 똑같이 작성하더라도, 인덱스, IOT, 클러스터링, 파티셔닝, MV 등을 어떻게 구성했는지에 따라 실행계획과 성능이 크게 달라진다.

---

## DBMS 제약 설정

개체 무결성, 참조 무결성, 도메인 무결성 등을 위해 DBMS가 제공하는 PK, FK, CHECK, NOT NULL 같은 제약 설정 기능을 이용할 수 있고, 이들 제약 설정은 옵티마이저가 쿼리 성능을 최적화하는데 매우 중요한 정보를 제공한다.
예를 들어 인덱스 칼럼에 NOT NULL 제약이 설정돼 있으면, 옵티마이저는 전체 개수를 구하는 COUNT 쿼리에 이 인덱스를 활용할 수 있다.

---

## 옵티마이저 힌트

---

## 통계정보

---

## 옵티마이저 관련 파라미터

DBMS 버전을 업그레이드하면 옵티마이저가 다르게 작동할 수 있다. 이는 옵티마이저 관련 파라미터가 추가 또는 변경되면서 나타나는 현상이다.

---

## DBMS 버전과 종류

옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행계획이 다를 수 있다.

---

# 옵티마이저의 한계

## 옵티마이지 팩터의 부족

옵티마이저는 주어진 환경에서 가장 최적의 실행계획을 수립하기 위해 정해진 기능을 수행한다.
사용자가 적절한 옵티마이징 팩터(효과적으로 구성된 인덱스, IOT, 클러스터링, 파티셔닝 등)를 제공하지 않는다면 결코 좋은 실행계획을 수립할 수 없다.

---

## 통계정보의 부정확성

최적화에 필요한 모든 정보를 수집해서 보관하는 것은 현실적으로 불가능하다. 특히 칼럼 분포가 고르지 않을 때 칼럼 히스토리는 반드시 필요한데, 이를 수집하고 유지하는 비용이 높다.
칼럼이 결합했을 때의 모든 결합 분포를 미리 구해두기 어려운 것도 큰 제약 중 하나다. 이는 상관관계에 있는 두 칼림이 조건절에 사용될 때 옵티마이저가 잘못된 실행계획을 수립하게 만드는 주요인이다.

```sql
-- 직급이 {부장, 과장, 대리, 사원}의 집합이고 각각 25%씩 비중을 갖는다. 그리고 전체 사원이 1000명이고 히스토그램상 '연봉 >= 5000' 에 부합하는 사원 비중이 10%이면, 옵티마이저는 위 쿼리 조건에 해당하는 사원 수를 25명으로 추정한다.
-- 하지만 현실에서는 직급과 연봉 간의 상관관계가 매우 높아서, 만약 연봉 5000만원 이상인 사원이 모두 부장이라면 실제 쿼리 결과는 100건이다.
-- 이런 조건절에 대비해 모든 칼럼 간 상관관계와 결합 분포를 미리 저장해두면 좋지만 이는 칼럽 조합이 기하급수적으로 증가하는 결과를 불러온다.
select * from emp where loc = '부장' and 연봉 >= 5000;
```

---

## 바인드 변수 사용시 균등분포 가정

아무리 정확한 칼럼 히스토그램을 보유하더라도 바인드 변수를 사용한 SQL에는 무용지물이다. 조건절에 바인드 변수를 사용하면 옵티마이저가 균등분포를 가정하고 비용을 계산하기 때문이다.

---

## 규칙에 의존하는 CBO

아무리 비용기반 옵티마이저라 하더라도 부분적으로는 규칙에 의존한다. 예를 들어 최적화 목표를 최초 응답속도에 맞추면 order by 소트를 대체할 인덱스가 있을때 무조건 그 인덱스를 사용한다.

---

## 하드웨어 성능

---

# 통계정보를 이용한 비용계산 원리

실행계획을 수립할 때 CBO는 SQL 문장에서 액세스할 데이터 특성을 고려하기 위해 통계정보를 이용한다.
최적의 실행계획을 위해 통계정보가 항상 데이터 상태를 정확하게 반영하고 있어야 하는 이유다.
옵티마이저가 참조하는 통계정보 종류로 아래 네 가지가 있다.

```sql
-- 테이블 통계 : 전체 레코드 수, 총 블록 수, 빈 블록 수, 한 행당 평균 크기 등
-- 인덱스 통계 : 인덱스 높이, 리프 블록 수, 클러스터링 팩터, 인덱스 레코드 수 등
-- 칼럼 통계 :  값의 수, 최저 값, 최고 값, 밀도, null 값 개수, 칼럼 히스토그램 등
-- 시스템 통계: CPU 속도, 평균 I/O 속도, 초당 I/O 처리량
```

---

## 선택도

선택도는 전체 대상 레코드 중에서 특정 조건에 의해 선택될 것으로 예상되는 레코드 비율을 말한다.
선택도를 가지고 카디널리티를 구하고, 다시 비요을 구해 인덱스 사용 여부, 조인 순서와 방법 등을 결정한다.
선택도는 최적의 실행계획을 수립하는데 있어 가장 중요한 요인이다.

```sql
-- 선택도 -> 카디널리티 -> 비용 -> 엑세스 방식, 조인 순서, 조인 방법 등 결정
```

히스토그램이 있으면 그것으로 선택도를 산정하며, 단일 칼럼에 대해서는 비교적 정확한 값을 구한다.
히스토그램이 없거나, 있더라도 조건절에 바인드 변수를 사용하면 옵티마이저는 데이터 분포가 균일하다고 가정한 상태에서 선택도를 구한다.
히스토그램 없이 등차 조건에 대한 선택도를 구하는 공식은 다음과 같다.

```
선택도 = 1/DISTINCT VALUE 개수
```

---

## 카디널리티

카디널리티는 특정 액세스 단계를 거치고 난 후 출력될 것으로 예상되는 결과 건수를 말하며 다음과 같이 총 로우수에 선택도를 곱해서 구한다.

```sql

-- 카디널리티 = 총 로우수 * 선택도 = num_rows / num_distinct

select * from 사원 where 부서 = :부서

-- 예를 들어 위 쿼리에서 부서 칼럼의 DISTICT VALUE 개수가 10 이면 선택도는 0.1 이고, 총 사원 수가 1000명 일때 카디널리티는 100이 된다.
-- 옵티마이저는 위 조건절에 의한 결과 집합이 100건일 것으로 예상한다는 뜻이다.
-- 조건절이 두 개 이상일 때는 각 칼럼의 선택도와 전체 로우 수를 곱해 주기만 하면 된다.

-- 직급의 도메인이 {부장, 과장, 대리, 사원} 이면 DISTICT VALUE 개수가 4이므로 선택도는 0.25다. 따라서 위 쿼리의 카딘러리티는 25로 계산된다.

select * from 사원 where 부서 = :부서 and 직급 = :직급
```

---

## 히스토그램

미리 저장된 히스토그램 정보가 있으면, 옵티마이저는 그것을 사용해 더 정확하게 카디널리티를 구할 수 있다.
특히 분포가 균일하지 않은 칼럼으로 조회할 때 효과를 발휘한다.
Oracle은 도수분포, 높이균형, 상위도수분포, 하이브리드 4가지 유형의 히스토그램을 제공한다.

- 도수분포 히스토그램
  값별로 빈도수를 저장한다.
  칼럼이 가진 값의 수가 적을 때 사용되며, 칼럼 값의 수가 적기 때문에 각각 하나의 버킷을 할당하는 것이 가능하다.

- 높이균형 히스토그램

  칼럼이 가진 값의 수가 아주 많아 각각 하나의 버킷을 할당하기 어려울 때 사용된다. 히스토그램 버킷을 값의 수보다 적게 할당하기 때문에 하나의 버킷이 여러 개 값을 담당한다.
  예를 들어 값으 수가 1000개 인데 히스토그램을 위해 할당된 버킷 개수가 100개면 하나의 버킷이 10개의 값을 대표한다.
  높이균형 히스토그램에서는 말 그대로 각 버컷의 높이가 같다. 각 버킷은 {1/(버킷의 수) \* 100}%의 데이터 분포를 갖는다. 따라서 각 버킷이 갖는 빈도수는 {(총 레코드 개수 / 버킷 개수)}로써 구할 수 있다.
  빈도 수가 많은 값에 대해서는 두 개 이상의 버킷이 할당된다.

- 바인드 변수 사용 시 카디널리티 계산

  바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적제하고, 실행시점에는 그것을 그대로 가져와 값만 다르게 바인딩하면서 반복 재사용한다. 여기서 변수를 바인딩하는 시점(최적화 시점보다 나중)이 실행시점이라는 사실이 중요하다.
  즉, SQL을 최적화하는 시점에 조건절 칼럼의 데이터 분포를 활용하지 못한다.

  바인드 변수를 사용할때 옵티마이저가 평균 분포를 가정한 실행계획을 생성하는 것도 이 때문이다. 칼럼 분포가 균일할때는 상관없겠지만, 그렇지 않을 때는 실행 시점에 바인딩되는 값에 따라 퀴리 성능이 다르게 나타날 수 있어 문제다.
  따라서 DW, OLAP, BATCH 에서 수행되는 쿼리는 바인드 변수보다 상수를 사용하는 것이 좋다. 특히 부등호, BETWEEN 같은 범위조건으로 자주 검색되는 칼럼일때 특히 그렇다. OLTP 성 쿼리이더라도 값의 종류가 적고 분포가 균일하지 않을 때는 상수 조건을 쓰는 것이 유용하다.

---

## 비용

CBO는 비용을 기반으로 최적화를 수행하고 실행계획을 생성한다. 여기서 비용이란 쿼리를 수행하는 데 소요되는 일량 또는 시간을 뜻하며, 어디까지나 예상치이다.
옵티마이저 비용 모델에는 I/O 비용 모델과 CPU 비용 모델 두 가지가 있다. I/O 비용 모델은 예상되는 입출력 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가하는 반면 , CPU 비용 모델은 여기에 시간 개념을 더해 비용을 산정한다.

- 인덱스를 경유한 테이블 엑세스 비용

I/O 비용 모델에서의 비용은 디스트 I/O CALL 횟수(논리적, 물리적으로 읽은 블록 개수가 아닌 I/O CALL 횟수)를 의미한다.
그리고 인덱스를 경유한 테이블 엑세스 시에는 SINGLE BLOCK I/O 방식이 사용된다. 이는 디스크에서 한 블록을 읽을 때마다 한 번의 I/O CALL을 일으키는 방식이므로 읽게 될 물리적 블록 개수가 I/O CALL 횟수와 일치한다.

```
비용 = BLEVEL                           -- 인덱스 수직적 탐색 비용
      + (리프 블록 수 * 유효 인덱스 선택도)   -- 인덱스 수평적 탐색 비용
      + (클러스터`링 팩터 * 유효 테이블 선택도) -- 테이블 랜덤 엑세스 비용


blevel : 브랜치 레벨을 의미하며, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록 개수

클러스터링 팩터: 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도, 인덱스를 경유해 테이블 전체 로우를 엑세스할때 읽을 것으로 예상되는 논리적인 블록 개수로 계수화

유효 인덱스 선택도 : 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율. 리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧 방문할 리프 블록 비율이다.

유효 테이블 선택도 : 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율. 클러스터링 팩터는 인덱스를 경유해 전체 로우를 액세스할 때 읽힑 것으로 예상되는 테이블 블록 개수이므로
여기에 유효 테이블 선택도를 곱함으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있다.
```

-- FULL SCAN에 의한 테이블 엑세스 비용

FULL SCAN은 테이블 전체를 순차적으로 읽어 들이는 과정에서 발생하는 I/O call 횟수를 비용으로 계산한다.
FULL SCAN할 때는 한 번의 I/O CALL로써 여러 블록을 읽어 들이는 MULTIBLOCK 방식을 사용하므로 총 블록 수를 MULTIBLOCK I/O 단위로 나눈 만큼 I/O CALL이 발생한다.
예를 들어 100 블록을 8개씩 나눠 읽는다면 13번의 I/O CALL이 발생하고 I/O CALL 횟수로써 FULL SCAN 비용을 추정한다.
따라서 MULTIBLOCK I/O 단위가 증가할 수록 I/O CALL 횟수가 줄고 예상비용도 줄어든다.
