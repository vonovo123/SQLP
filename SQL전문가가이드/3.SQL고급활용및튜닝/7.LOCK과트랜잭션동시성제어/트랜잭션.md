트랜잭션은 업무 처리를 위한 논리적인 작업 단위다. 작업의 논리적 단위가 단일 연산이 아닐 수 있다. 즉 하나의 트랜잭션이 두 개 이상의 갱신연산일 수 있다. 은행의 계좌이체 트랜잭션을 예로 들면, 하나의 예금 계좌에서 인출해 다른 예금 계좌에 입금하는 일련의 작업을 하나의 단위로 수행해야 한다.

데이터를 일관성 있게 처리하려면 트랜잭션에 속한 두 개 이상의 갱신 연산을 동시에 실행할 수 있어야 하는데, 불행히도 이는 불가능하다. 따라서 DBMS는 차선책을 사용한다. 여러 개의 갱신 연산이 하나의 작업처럼 전부 처리되거나 아예 처리되지 않도록 동시 실행을 구현한다.

## 트랜잭션의 특징

데이터베이스의 갱신과 관련해 트랜잭션은 다음과 같은 특성을 가지며, 영문 첫 글자를 따 ACII라고 부른다

\- 원자성(Atomicity)

트랜잭션은 분해가 불가능한 업무의 최소단위이므로 전부 처리되거아 아예 처리되지 않아야한다.

\- 일관성(Consistency)

일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고나면 그 데이터베이스는 여전히 일관된 상태여야 한다. 즉, 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.

\- 격리성 (Isolation)

실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.

\- 영속성 (Durability)

트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.

---

## 트랜잭션 격리성

트랜잭션의 격리성은, 일관성과 마찬가지로 LOCK 을 강하게 오래 유지할수록 강화되고 LOCK을 최소화 할 수록 약화된다. 낮은 단계의 격리성 수주네서 어떤 현상들이 발생하는지부터 살펴보자.

---

### 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들

\- DIRTY READ

다른 트랜잭션이 수정한 후 커밋하지 않은 데이터를 읽는 것을 말한다. 변경 후 아직 커밋되지 않은 값을 읽었는데 변경을 가한 트랜잭션이 최종적으로 롤백된다면 그 값을 읽은 트랜잭션은 비일관된 상태에 놓이게 된다.

\- NON-REPEATABLE READ

한 트랜잭션 내에서 같은 쿼리를두 번 수행했는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다.

```sql
-- t1 시점에서 123번 계좌번호의 잔고는 55,000원 이었다고 가정하자.
-- 1번 쿼리를 통해 자신의 계좌에 55,000원이 남아 있음을 확인하고 t4에서 인출하려는 순간 TX2 트랜잭션에 의해 계좌의 잔고가 5000원으로 변경됐다.
-- 그러면 TX1 사용자는 잔고가 충분한 것을 확인하고 인출을 시도했음에도 불구하고 잔고가 부족하다는 메시지를받게 된다.


-- TX1                  |             TX2
-- SELECT 잔고           t1
-- INTO BALANGE         |
-- FROM  계좌            |
-- WHERE 계좌번호 = 123;  |
--                      t2    UPDATE 계좌
--                      |      SET 잔고 = 잔고 - 5000
--                      |      WHERE 계좌번호 = 123;
--                      |
--                      t3    COMMIT;
--                      |
-- UPDATE 계좌           t4
-- SET 잔고 = 잔고 - 10000 |
-- WHERE 계좌번호 = 123    |
-- AND 잔고 >= 100000;    |
--                      |
-- IF SQL %ROWCOUNT = 0 t5
-- THEN                 |
-- ALERT('잔고부족');      |
-- END IF;              |
--                      |
-- COMMIT;              t6
```

\- PHANTOM READ

한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상을 말한다.

```sql
-- TX1 트랜잭션이 지역별고객과 연령대별고객을 연속해서 집계하는 도중 새로운 고객이 TX2 트랜잭션에 의해 동록 됐다.
-- 그 결과 지역별고객과 연령대별 고객 두 집계 테이블을 통해 총 고객수를 조회하면 서로 다른 결과 값이 되는 상황에 놓이게 된다.

-- TX1                  |             TX2
-- SELECT               |
-- 지역별고객             t1
-- FROM 고객             |
-- GROUP BY 지역;        |
--                      t2    INSERT INTO 고객
-- SELECT               |      (고객번호, 이름, 지역, 연령대)
-- 지역별고객              |      VALUES(:A, :d, :c, :d, ...)
-- FROM 고객              |
-- GROUP BY 지역;         |
--                       |t3    COMMIT;
--                      |
-- COMMIT;           t4
```

---

## 트랜잭션 격리성 수준

\- READ UNCOMMITTED

트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.

\- READ COMMITTED

트랜잭션이 커밋돼 확정된 데이터만 다른 트랜잭션이 읽독 허용함으로써 DIRT READ를 방지한다.
커밋된 데이터만 읽더라도 NON-REPEATABLE READ와 PHANTOME READ 현상을 막지는 못한다. 읽는 시점에 짜라 결과가 다를 수 있다는 것이다.
한 트랜잭션 내에서 쿼리를 두 번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 값을 변경.삭제하거나 새로운 레코드를 삽입하는 경우이다.

\- REPEATABLE READ

트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해준다.
이 트랜잭션 격리성 수준이 PHANTOM READ 현상을 막지는 못한다. 첫 번째 쿼리에서 없던 새로운 레코드가 나타날수 있다.
한 트랜잭션 내에서 쿼리를 두 번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 새로운 레코드를 삽입하는 경우이다.

\- SERIALIZEABLE READ

트랜재션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않는다.
ORACLE은 READ COMMITTED 와 SERIALIZABLE READ만 지원한다.

대부분의 DBMS가 READ COMMITTED를 기본 트랜잭션 격리성 수준으로 채택하고 있으므로 DIRTY READ가 발생할까 걱정하지 않아도 된다.
NON-REPEATABLE READ, PHANTOM READ 현상에 대해선 세심한 주의가 필요하다. 많은 경우 개발자가 직접 구현해 주어야 한다.

다중 트랜잭션 환경에서 DBMS가 제공하는 기능을 이용해 동시성을 제어하려면 트랜잭션 시작 전에 명시적으로 SET TRANSACTION 명령어를 수행하기만 하면 된다.

```sql
-- 트랜잭션 격리성 수준을 SERIALIZABLE READ 로 상향조정하는 예시이다.
set transaction isolation level read serializable;
```

트랜재션 격리성 수준을 REPEATABLE READ 나 SERIALIZABLE READ로 올리면 ISO에서 정한 기준을 만족해야 하며, 대부분의 dbms가 이를 구현하기 위해 LOCKING 매커니즘에 의존한다.
구체적으로 공유 LOCK을 트랜잭션이 끝날 때까지 유지하는 방식을 사용한다.

```sql
-- TX1 트랜잭션을 REPEATABLE READ 모드에서 실행했다고 하자.
-- 그러면 T1 시점에 1번 쿼리에서 설정한 공유 LOCK을 T6까지 유지하므로,
-- TX2의 2번 update 는 t6 시점까지 대기해야 한다.

-- TX1                  |             TX2
-- SELECT 잔고           t1
-- INTO BALANGE         |
-- FROM  계좌            |
-- WHERE 계좌번호 = 123;  |
--                      t2    UPDATE 계좌
--                      |      SET 잔고 = 잔고 - 5000
--                      |      WHERE 계좌번호 = 123;
--                      |
--                      t3    COMMIT;
--                      |
-- UPDATE 계좌           t4
-- SET 잔고 = 잔고 - 10000 |
-- WHERE 계좌번호 = 123    |
-- AND 잔고 >= 100000;    |
--                      |
-- IF SQL %ROWCOUNT = 0 t5
-- THEN                 |
-- ALERT('잔고부족');      |
-- END IF;              |
--                      |
-- COMMIT;              t6
```

이런 방식의 거래의 문제점은 동시성이다. 대량의 데이터를 읽어 처리할 때는 동시성이 심각하게 낮아진다. 완벽한 데이터 일관성 유지를 위해 심지어 테이블 레벨 LOCK을 걸어야 할 때도 있다.
이에 대한 대한으로 다중버전 동시성 제어를 채택하는 DBMS가 조금씩 늘고 있다. '스냅샷 격리성 수준' 이라고도 불리는 이 방식을 한마디로 요약하면, 현재 진행 중인 트랜잭션에 의해 변경된 데이터를 읽고자 할 때는 변경 이전 상태로
되돌린 버전을 읽는 것이다. 변경이 아직 확정되지 않은 값을 읽으려는 것이 아니므로 공유 LOCK을 설정하지 않아도 된다. 따라서 읽는 세션과 변경하는 세션이 서로 간섭현상을 일으키지 않는다.

```sql
-- TX2 트랜잭션에 의해 새로운 고객이 등록되더라도 TX1 트랜잭션은 그 값을 무시한다.
-- 트랜잭션 내내 자신이 시작된 t1 시점을 기주느로 읽기 때문에 데이터 일관성을 물론 높은 동시성을 유지할 수 있다.

-- TX1                  |             TX2
-- SELECT               |
-- 지역별고객             t1
-- FROM 고객             |
-- GROUP BY 지역;        |
--                      t2    INSERT INTO 고객
-- SELECT               |      (고객번호, 이름, 지역, 연령대)
-- 지역별고객              |      VALUES(:A, :d, :c, :d, ...)
-- FROM 고객              |
-- GROUP BY 지역;         |
--                       |t3    COMMIT;
--                      |
-- COMMIT;           t4
```

---
