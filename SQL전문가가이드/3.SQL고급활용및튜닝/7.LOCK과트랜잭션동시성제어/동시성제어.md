DBMS는 다수의 사용자를 가정한다. 따라서 동시에 작동하는 다중 트랜잭션의 상호 간섭 작용에서 데이터베이스를 보호할 수 있어야 한다. 이를 동시성 제어라고 한다.

동시성을 제어하기 위해 모든 DBMS가 공통적으로 LOCK 기능을 제고안다. 여러 사용자가 데이터를 도시에 엑세스하는 것 처럼 보이지만 내부적으로는 하나씩 실행되도록 트랜잭션을 직렬화하는 것이다.

또한 SET TRANSACTION 명령어를 이용해 트랜잭션 격리성 수준을 조정할 수 있는 기능도 제공한다. 동시성 제어가 어려운 이유는 동시성과 일관성은 트레이드 오프 관계이기 때문이다.

동시성을 높이려고 LOCK의 사용을 최소화하면 일관성을 유지하기 어렵고, 일관성을 높이려고 LOCK을 적극적을 사용하면 동시성이 저하된다. 따라서 동시성 제어의 목표는 동시에 실행되는 트랜잭션 수를 최대화하면서도 입력,수정,삭제,검색 시 데이터 무결성이 유지되도록 하는 데에 있다.

데이터베이스 개발자들이 간과해서는 안되는 사실은, 트랜잭션은 분해가 불가능한 업무의 최소단위이므로 전부 처리되거나 아예 하나도 처리되지 않아야 한다.
DBMS가 제공하는 SET TRANSACTION 명령어로 모든 동시성 제어 문제를 해결할 수 없다. 예를 들어 사용자가 자신의 계좌에서 잔고를 확인하고 인출을 완료할 때 까지의 논리적인 작업 단위를 하나의 트랜잭션으로 처리하고자 할때, 잔고를 확인하는 sql과 인출하는 SQL 이 서로 다른 연결을 통해 처리될 수 있다.

DB와 연결하기 위해 사용하는 라이브러리나 그리드 컴포넌트가 동시성 제어 기능을 제공하기도 하지만, 많은 경우 트랜잭션의 동시성을 개발자가 직접 구현해야한다.

동시성 제어 기법에는 비관적 동시성과 제어와 낙관적 동시성 제어라는 두 가지 기법이 있다.

# 비관적 동시성 제어 vs 낙관적 동시성 제어

## 비관적 동시성 제어

사용자들이 같은 데이터를 동시에 수정할 것이라고 가정한다. 따라서 데이터를 읽는 시점에 LOCK을 걸고 트랜잭션이 완료될 때 까지 이를 유지한다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적
from 고객
where 고객번호 = :cust_num for update;

-- 새로운 적립포인트 계산

update 고객 set 적립포인트 = :적립포인트 where 고객번호 = :cust_num;

-- select 시점에서 LOCK을 거는 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있다. 그러므로 다음과 같이 wait 또는 Nowait 옵션을 함께 사용하는 것이 바람직하다.

-- 대기없이 eXCEPTION 던짐
for update nowait

-- 3초 대기 후 EXCEPTION 던짐ㄴ
for update wait 3

```

---

## 낙관적 동시성 제어

사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정한다. 따라서 데이터를 읽을 때는 lock을 설정하지 않는다. 대신 수정 시점에 다른 사용자에 의해 값이 변경됐는지 반드시 검사해야한다.

```SQL
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into :a, :b, :c, :d
from 고객
where 고객번호 = :cust_num

-- 새로운 적립포인트 계산

update 고객 set 적립포인트 = :적립포인트
where 고객번호 = :cust_num
and 적립포인트 = :a
and 방문횟수 = :b
and 최근방문일시 = :c
and 구매실적 = :d;

if sql%rowcount = 0 then
alert('다른 사용자에 의해 변경됐습니다.');
end if

-- 최종 변경일시를 관리하는 칼럼이 있다면, 다음과 같이 좀 더 간단하게 구현할 수 있다.

select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into :a, :b, :c, :d, :mod_dt
from 고객
where 고객번호 = :cust_num

update 고객 set 적립포인트 = :적립포인트, 변경일시 = sysdate
where 고객번호 = :cust_num
and 변경일시 = :mod_dt; -- 최종 변경일시가 앞서 읽은 값과 같은지 비교
```

---

# 다중버전 동시성 제어

## 일반적인 LOCKING 메커니즘의 문제점

동시성 제어의 목표는, 동시에 실행되는 트랜잭션 수를 최대화하면서도 입력, 수정, 삭제, 섬색 시 데이터 무결성을 유지하는데 있다.
그런데 읽기 작업에 공유 lOCK을 사용하는 일반적인 LOKING 메커니즘에서는 읽기작업과 쓰기 작업이 서로 방해를 일으키기 때문에 종종 동시성 문제가 생기곤 한다.

또한 데이터 일관성에 문제가 생기는 경우도 있어 이를 해결하려면 LOCK을 더 오랫동안 유지하거나 테이블 레벨 LOCK을 사용해야 하므로 동시성을 더 심각하게 떨어뜨리는 결과를 낳는다.

```sql
-- 다음과 같이 10개의 계좌를 가진 계좌 테이블이 있고, 잔고는 각각 1000원 씩이다.

-- 이 테이블에서 잔고 총합을 구하는 아래 쿼리가 TX1 트랜잭션에서 수행되기 시작했다.

TX1> SELECT SUM(잔고) FROM 계좌;

-- 잠시 후 계좌이체를 처리하는 아래 TX2 트랜잭션도 작업을 시작했다.

TX2 > UPDATE 계좌 SET 잔고 = 잔고 + 100 when 계좌번호 = 7 -- 1
TX2 > UPDATE 계좌 SET 잔고 = 잔고 - 100 when 계좌번호 = 3 -- 2

-- 1. TX1 : 2번 계좌까지 읽는다. 현재까지의 잔고 총합은 2,000 원이다.
-- 2. TX2 : 1번 UPDATE를 실행한다. 7번 계좌 잔고는 1,100원이 됐고, 아직 커밋되지 않은 상태다.
-- 3. TX1 : 6번계좌까지 읽어 내려간다. 현재까지 잔고 총합은 5,000원이다.
-- 4. TX2 : 2번 update를 실행함으로써 3번 계좌는 900, 7번 계좌는 1100인 상태에서 커밋한다.
-- 5. TX1 : 10번 계좌까지 읽어 내려간다. 7번 계좌를 1100으로 바꾼 TX2 트랜잭션이 커밋됏으므로 이 값을 읽어서 구한 잔고 총합은 10,100 이 된다.

```

TX2 트랜잭션이 진행되기 직전의 잔고 총합은 10000 이었고, TX2 트랜잭션이 완료된 직후의 잔고 총합도 10000원 이었다. 어느 순간에도 잔고 총합이 10100 인 순간은 없었으므로 TX1의 쿼리는 일관성 없게 구해진 값이다.
위와 같은 비일관성 읽기 문제를 해결하기 위한 일반적인 해법은 트랜잭션 격리성 수준을 상향 조정하는 것이다.
기본 트랜잭션 격리성 수준에서는 값을 읽는 순간에만 공유 LOCK을 걸었다가 다음 레코드로 이동할 때 LOCK을 해재해서 위와 같은 현상이 발생했기 때문이다.

F트랜잭션 격리성 수준을 REPEATABLE READ로 올리면 TX1 쿼리가 진행되는 동안 읽은 레코드는 공유 lOCK이 유지되며, 심지어 쿼리가 끝나고 다음 쿼리가 진행되는 동안에도 유지된다.

이처럼 트랜잭션 격리성 수준을 상향 조정하면 일관성이 높아지지만 LOCK이 더 오래 유지됨으로 인해 동시성이 저하되고 교착상태가 발생할 가능성도 커진다.

```sql
-- TX2가 1번 UPDATE를 통해 7번 레코드에 배타적 LOCK을 설정하고 TX1은 3번 레코드에 공유 LOCK을 설정한다. TX2가 2번 UPDATE를 실행하는 단계에서 3번 레코드에 걸린 공유 LOCK을 대기하게 되고, TX1이 7번 레코드를 읽으려는 순간 영원히 LOCK이 풀릴수 없는 교착상태에 빠진다. 이 때문에 테이블 레벨 LOCK을 사용해야만 할 수도 있고, 이는 동시성을 더 심하게 저하시킨다.
```

---

## 다중버전 도시성 제어

읽기 작업가 쓰기 작업이 설로 방해해 동시성을 떨어뜨리고, 공유 LOCK으 사용함에도 데이터 일관성이 훼손될수 있는 문제를 해결하기 위해 ORACLE은 다중버전 동시성 제어 매커니즘(MVCC)을 사용해 왔다.

MVCC 메커니즘을 간단히 요약하면 다음과 같다.

- 데이터를 변경할 때마다 그 변경사항을 undo 영역에 저장해둔다.
- 데이터를 읽다가 쿼리 시작 시점 이후에 변경된 값을 발견하면 undo 영역에 저장된 정보를 이용해 쿼리 시작 시점의 일관성 있는 버전을 생성하고 그것을 읽는다.

쿼리 도중 배타저 lock이 걸린, 즉 변경이 진행 중인 레코드를 만나더라도 대기하지 않기 때문에 동시성 측면에서 매우 유리하다. 사용자에게 제공되는 데이터의 기준 시점이 쿼리 시작 시점으로 고정되기 때문에 일관성 측면에서도 유맇하다.

장점만 있는 것은 아니다.

UNDO 블록, CR COPY 생성, CR 블록 캐싱 같은 부가적인 작업 때문에 생기는 오버헤드도 무시할 수 없다.

MVCC를 이용한 읽기 일관성에는 문장수준과 트랜잭션 수준이라는 2가지가 있다.

---

## 문장수준 읽기 이관성

다른 트랜잭션에 의해 데이터의 추가-변경 사게ㅏ 발생하더라도 단일 SQL 문 내에서 일관성 있게 값을 읽는 것을 말한다. 일관성 기준 시점은 쿼리 시작 시점이다.

---

## 트랜잭션 수준 읽기 일관성

트랜잭션 수준 읽기 일관성은, 다른 트랜잭션에 의해 데이터의 추가,변경,삭제가 발생하더라도 트랜잭션 내에서 일관성 있게 값을 읽는 것을 말한다.
기본 트랜잭션 격리성 수준에서 완벽한 문장 수준의 읽기 일관성을 보장하는 MVCC 매커니즘도 트랜잭션 수준의 읽기 일관성을 보장하지 않는다. 물ㄹㄴ 일반적인 LOCKING 매커니즘도 트래잭션 수준의 읽기 일관성은 보장하지 않는다.
트랜잭션 수준으로 완벽한 읽기일관성을 보장받으려면 격리성 수준을 SERIALIZABLE READ로 올려줘야한다.

트랜잭션 격리성 수준을 SERIALIZABLE READ로 상향 조정하면 일관성 기준 시점은 트랜잭션 시작 시점이 된다.
물론 트랜잭션이 진행되는 도안 자신이 발생시킨 변경사항은 그대로 읽는다.

---

## SNAPSHOT TOO OLD

undo 데이터를 활용해 높은 수준의 동시성과 읽기 일관성을 유지하는 대신, 일반적인 LOCKING 메커니즘에는 없는 SHAPSHOT TOO OLD 에러가 MVCC 에서 발생한다.
대용량 데이터를 처리할 때 종종 개발자를 괴롭히는 이 에러는 UNDO 영역에 저장된 UNDO 정보가 다른 트랜잭션에 의해 재사용돼 필요한 CR COPY를 생성할 수 없을 때 발생한다.

SHAPSHOT TOO OLD 에러 발생 가능성으 줄이는 방법은 다음과 같다.

1. undo 영역의 크기를 증가시킨다.
2. 불필요하게 커밋을 자주 수행하지 않는다.
3. fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현한다. ANSI 표준 따르면 커밋 이전에 열려 있떤 커서는 더는 fetch 하면 안된다. 다른 방식으로 구현하기 어렵다면 커밋횟수를 줄여본다.
4. 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않독 시간을 조정한다.
5. 큰 테이블을 일정 범위로 나눠 읽고 단계적으로 실행할 수 있도록 코딩한다.
6. 오랜 시간에 걸쳐 같은 블록을 여러 번 방문하는 NESTED LOOP 형태의 조인문 또는 인덱스를 경유한 테이블 엑세스를 수반하는 프로그램이 있는지 체크하고, 이를 회피할 수 있는 방법을 찾는다.
7. 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트연산이 발생하돍한다.
8. 대량 업데이트 후에 곧바로 해당 테이블 또는 인덱스르 full scan 하도록 쿼리를수행하는 것도 하나의 해결방법이 될 수 있다.
