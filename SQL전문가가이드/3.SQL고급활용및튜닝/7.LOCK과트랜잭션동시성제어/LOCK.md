# LOCK 기본

## LOCK 이란?

고가의 DBMS를 도입하는 기본적이고 핵심적인 요소는 트랜잭션 처리 능력이다. 같은 자원을 엑세스하려는 다중 트랜잭션 환경에서 데이터베이스의 일관성과 무결성을 유지하려면 트랜잭션의 순차저 진행을 보장할 수 있는 직렬화 장치가 필요하다.
영화관 좌서을 예약하는 시스템을 예로 들면, 두 명이 도시에 자석을 요청할 때 정학히 한 명만 자석을 배정받도록 할 수 있어야 한다. 이런 직렬화를 가능하게 하려고 모든 DBMS가 곹ㅇ적을 사용하는 메커니즘이 LOCK 이다.

중요한 것은 DBMS 마다 LOCK을 구현하는 방식가 세부저인 기능이 많이 다르다는 사실이다. 따라서 자신이 사용중인 DBMS 만의 독특한 lock 메커니즘을 정확하게 이해하지 못한 상태에선 결코 고품질 데이터베이스를 구축할 수 없다.

---

## 공유 LOCK 과 배타적 LOCK

DBMS는 각 트랜잭션의 오퍼레이션별로 적당한 수준의 LOCK을 자동으로 설정한다. 필요한 경우, 일부 LOCK 에 대해서는 사용자가 직접 제어하는 방법도 제공한다.

가장 기본이 되는 lOCK 모드는 공유적 LOCK 과 배타적 LOCK 이다.

### 공유 LOCK

공유 LOCK 은 데이터를 읽을 때 사용한다. 다른 공유 LOCK과는 호환되지만 배타적 LOCK 과는 호환되지 않는다. '호환된다'는 말은 한 리소스에 두 개 이상의 LOCK을 동시에 설정할 수 있음을 뜻한다.
다시 말해 공유 LOCK을 설정한 리소스에 다른 트랜잭션이 추가로 공유 LOCK을 설정할 수는 있지만 배타적 LOCK은 불가능하다.
따라서 자신이 읽고 있는 리소스를 다른 사용자가 동시에 읽을 수는 있어도 변경은 불가능 하다. 반대로 다른 사용자가 읽고 있는 리소스를 동시에 읽을 수는 있어도 변경중인 리소스를 동시에 읽을 수는 없다.

### 배타적 LOCK

배타적 LOCK 은 데이터를 변경할 때 사용한다. 트랜잭션이 완료될 때까지 유지되며 다른 트랜잭션은 해당 리소스에 접근할 수 없다. 변경이 불가능할뿐만 아니라 읽기도 불가느하다. 반대로 트랜잭션이 lOCK을 설정한 리소스는, 그것이 공유 lock 이든 배타적 LOCK 이든
배타적 LOCK을 동시에 설정할 수 없다.

---

## 블로킹과 교착상태

### 블로킹

블로킹은 LOCK 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 말한다. 공유 lOCK 끼리는 호환되기 때문에 블로킹이 발생하지 않는다. 공유 LOCK 과 배타적 LOCK은 호환되지 않아 블로킹이 발생할 수 있다. 배타적 LOCK 끼리는 당연히 호환되지 않는다.
블로킹 상태를 해소하는 방법은 커밋 또는 롤백 뿐이다. LOCK 경합이 발생하면 먼저 LOCK 을 설정한 트랙잭션이 완료될 때까지 후행 트랜잭션은 기다려야 하며, 이런 현상이 자주 나타나면 사용자 경험에 악영향을 준다.

LOCK에 의한 성능 저하를 최소화 하는 방안은 다음과 같다.

- 트랜잭션의 원자성을 훼손하지 않는 선에서 가능하면 짧게 트랜잭션을 정의한다.
  ORACLE 은 데이터를 읽을 때 공유 LOCK 이 발생하지않아 상대적으로 LOCK 경합이 적게 발생한다. 그렇더라도 배타적 LOCK 끼리 발생하는 경합은 피하지 못하므로 불필요하게 트랜잭션을 길게 정의해선 안 된다.

- 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계하는 것도 중요하다. 특히 트랜잭션이 활발한 주간에 대용량 갱신 작업을 수행해선 안된다.

- 블로킹 현상에 의해 사용자가 무한정 기다리지 않도록 적절한 프로그래밍 기법을 도입해야한다. 예를 들어 LOCK_TIMEOUT 을 설정해 LOCK에 의한 대기 시간이 최대 2초를 넘지 않도록 설정하는 것이다.

```sql
-- ORACLE 이라면 update/delete 문장을 수행하기 전에 nowait 나 wait 옵션을 지정한 select ... for update 문을 먼저 수행해 봄으로써 LOCK 이 설정됐는지 체크할 수 있다. 이를 기반으로 발생한 예외사항에 따라 적절한 조취를 취할 수 있다.

SELECT * FROM T WHERE NO = 1 FOR UPDATE NOWAIT  --- 대기없이 EXCEPTION을 던짐
SELECT * FROM T WHERE NO = 1 FOR UPDATE WAIT 3 --- 3초 대기 후 EXCEPTION을 던짐
```

- 트랜잭션을 잘 설계하고 대기 현상을 피하는 프로그래밍 기법을 적용하기 앖어, 결과가 가장 빨리 나오는 SQL을 작성하는 게 LOCK 튜닝의 기본이고 효과도 가장 확실하다.

### 교착상태

교착상태(DEADLOCK) 은, 두 세션이 각각 LOCK을 설정한 리소스를 서로 엑세스하려고 마주 보며 진행하는 상황을 말한다.
교착상태가 발생하면, DBMS가 둘 중 하나의 세션에 에러를발생시킴으로써 문제를 해결한다. 이를 방지하기위해선 어떻게 해야 할까?
조금 전 설명한 LOCK 튜닝 방안은 교착상태 발생 가능성을 줄이는 방안이기도 하다. 여러 테이블을 엑세스하면서 발생하는 교착상태는 테이블 접근 순서를 같게 처리하면 피할 수 있다.
예를 들어 마스터 테이블과 상세 테이블을 둘 다 갱신할 때 마스터 테이블 다음에 상세 테이블을 갱신하기로 규칙을 정하고 모든 애플리케이션 개발자가 이 규칙을 지킨다면 교착상태는 발생하지 않을 것이다.

---

# ORACLE LOCK

ORACLE은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML LOCK, DDL LOCK, LATCH, BUFFER LOCK, LIBRARY CHACH LOCK/PIN 등 다양한 종류의 LOCK을 사용한다. 이들 중 개발 측면에서 가장 중요하게 다뤄야 할 LOCK은 DML LOCK이 있다.
DML LOCK은, 다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호해 준다. DML LOCK 에는 ROW LOCK & TABLE LOCK이 있다.

## ROW LOCK

ORACLE 에서 로우 LOCK은 항상 배타적이다. Insert, update, delete 문이나 select for update 문을 수행한 트랜잭션에 의해 설정된다.
이 트랜잭션이 커밋 또는 롤백할 때까지 다른 트랜잭션은 해당 로우를 변경할 수 없다. ORACLE에서 일반 select 문에 의해 읽힌 레코드에서 어떤 LOCK도 설정되지 않는다. 다른 DBMS 처럼 읽기 작업에 대한 공유 LOCK을 사용하지 않기 때문에 ORACLE 에서 읽기와 갱신 작업은 서로 방해하지 않는다.

- 읽으려는 데이터를 다른 트랜잭션이 갱신중이더라도 기다리지 않는다.
- 갱신하려는 데이터를 다른 트랜잭션이 읽는중이더라도 기다리지 않는다.(SELECT...FOR UPDATE 구문으로 읽는 경우는 제외)
- 갱신하려는 데이터를 다른 트랜잭션이 갱신중이면 기다린다.

ORACLE이 공유 LOCK을 사용하지 않고도 일관성으 유지할 수 있는 것은 UNDO 데이터를 이용한 다중버전 동시성 제어 메커니즘을 사용하기 때문이다. 별도의 LOCK 매니저 없이 레코드의 속성으로서 로우 LOCK을 구현했기 때문에 아무리 많은 레코드를 갱신하더라도 LOCK ESCALATION은 발생하지 않는다.

---

## TABLE LOCK

한 트랜잭셔니 로우 LOCK을 얻을 때 해당 테이블의 테이블 LOCK도 동시에 얻는다. 이렇게 하는 것은 현재 트랜잭션이 갱신중인 테이블의 구조를 변경하지 못하게 막기 위함이다.
테이블 LOCK 종류는 아래 5가지가 있다.

\- ROW SHARE(RS)
\- ROW EXCLUSIVE(RX)
\- SHARE(S)
\- SHARE ROW EXCLUSIVE(SRX)
\- EXCLUSIVE(X)

대표적으로 SELECT ... FOR UPDATE 문을 수행할 때 RS 모드 테이블 LOCK을 얻고, insert-update-delete 문을 수행할때 RX 모드 테이블 LOCK을 얻는다.
DML 로우 LOCK을 처음 얻는 순간 묵시적으로 테이블 LOCK을 얻지만, 아래처럼 LOCK TABLE 명령어를 이용해 명시적으로 테이블 LOCK을 얻을 수도 있다.

```
lock table emp in row share mode;
lock table emp in row exclusive mode;
lock table emp in share mode;
lock table emp in share row exclusive mode;
lock table emp in excusive mode;
```

테이블 lock 끼리의 호환성은 다음과 같다.

```sql
---        NULL   RS   RX  S   SRX   X
--- NULL    O     O    O   O    O    O
--- RS      O     O    O   O    O
--- RX      O     O    O
--- S       O     O        O
--- SRX     O     O
--- X       O
```

테이블 LOCK 이라고 하면, 테이블 전체에 LOCK 이 걸린다고 생각하기 쉽다. DML 수행 시 항상 테이블 LOCK이 함께 설정된다고 했는데, 만약 이것이 SQL SERVER 의 테이블 레벨 LOCK 처럼 테이블 전체를 잠그는 기능이라면 다른 트랜잭셔니 더는 레코드를 추가하거나 갱신하지 못하도록 막게 될 것이다.
하지만 RX 와 RX 간에 호환성이 있으므로 그런 일은 발생하지 않는다.

ORACLE 에서 말하는 테이블 LOCK 은, LOCK을 획득한 선행 트랜잭션이 해당 테이블에서 현재 어떤 작업을 수행중인지 알리는 일종의 푯말이다. 후행 트랜잭션은 어떤 테이블 lock 이 설정돼 있는지만 보고도 그 테이블로의 진입 여부를 결정할 수 있다.
