## 대기 이벤트

DBMS 내부에서 활동하는 수 많은 프로세스 간에는 상호작용이 필요하며, 그 과정에서 다른 프로세스가 일을 마칠 때까지 기다려야만 하는 상황이 자주 발생한다.

그때마다 해당 프로세스는 자신이 일을 계속 진행할 수 있는 조건이 충족될 때까지 **SLEEP** 상태로 대기한다.

그 기간에 정해진 간격으로 각 대기 유형별 상태와 시간 정보가 공유 메모리 영역에 저장된다.

대개 **누적치** 만 저장되지만, 사용자가 원하면 로그처럼 파일로 기록해주기도 한다.

이런 대기 정보를 ORACLE 에서는 **대기 이벤트** 라고 부른다.

---

## 라이브러리 캐시 부하

아래는 라이브러리 캐시에서 SQL 커서를 찾고 최적화하는 과정에 경합이 발생했음을 나타내는 대기 이벤트이다.

\- latch : shared pool
\- latch : library cache

라이브러리 캐시와 관련해 자주 발생하는 대기 이벤트로는 아래 두가지가 있다.

이들은 수행 중인 SQL이 참조하는 오브젝트에 다른 사용자가 DDL 문장을 수행할 때 나타난다.

\- Library cache lock

\- Library cache pin

라이브러리 캐시 관련 경합이 급증하면 심각한 **동시성저하**를 초래한다.

---

## 데이터베이스 CALL 과 네트워크 부하

아래 이벤트에 의해 소모된 시간은 **애플리케이션**과 **네트워크구간** 에서 소모된 시간으로 이해하면 된다.

\- SQL\*NET MESSAGE FROM CLIENT

\- SQL\*NET MESSAGE TO CLIENT

\- SQL\*NET MORE DATA TO CLIENT

\- SQL\*NET MORE DATA FROM CLIENT

SQL\*NET MESSAGE FROM CLIENT 이벤트는 사실 데이터베이스 경합과는 관련이 없다.

클라이언트로부터 다음 명령이 올 때 까지 IDLE 상태로 기다릴 때 발생하기 때문이다.

반면 나머지 세 개의 대기 이벤트는 실제 네트워크 부하가 원인일 수 있다.

SQL*NET MESSAGE TO CLIENT 와 SQL*NET MORE DATA TO CLIENT 이벤트는 클라이언트에게 메시지를 보냈는데 여기에 대한 응답신호가 정해진 시간보다 늦게 도착하는 경우를 나타낸다.

SQL\*NET MORE DATA FROM CLIENT 이벤트는 클라이언트로부터 더 받을 데이터가 있는데 지연이 발생하는 경우다.

---

## 디스크 I/O 부하

아래는 모두 **디스크 I/O** 가 발생할 때마다 나타나는 대기 이벤트이다.

\- db file sequential read

\- db file scattered read

\- direct path read

\- direct path write

\- direct path write temp

\- direct path read temp

\- db file parallel read

이들 중 특히 주목할 대기 이벤트는 **DB File Sequential Read** 와 **DB File Scattered Read** 이다.

전자는 Single Block I/O를 수행할 때 나타나는 **대기이벤트**이다.

한번의 **인아웃콜** 에 **하나의 데이터 블록**만 읽는 것을 말한다.

인덱스 블록을 읽을 때, 인덱스를 거쳐 테이블 블록을 엑세스할 때 이 방식을 사용한다.

후자는 **MULTIBLOCK I/O** 를 수행할 때 나타나는 대기 이벤트다.

I/O Call 이 필요한 시점에 인접한 블록들을 같이 읽어 메모리에 적재하는 것을 말한다.

Table Full Scan 또는 Index Fast Full Scan 시 나타난다.

---

## 버퍼 캐시 경합

아래는 **버퍼캐시**에서 블록을 읽는 과정에서 경합이 발생했음을 나타내는 대기 이벤트이다.

\- latch: cache buffers chains

\- latch : cache buffers lru chain

\- buffer busy waits

\- free buffer waits

버퍼 캐시에서 블록을 읽더라도 이들 대기 이벤트가 심하게 발생하는 순간 **동시성**은 현저히 **저하**된다.

---

## Lock 관련 대기 이벤트

아래 'enq'로 시작되는 대기 이벤트는 LOCK과 관련된 것이다.

\- enq : TM - CONTENTION

\- enq : TX - ROW LOCK CONTENTION

\- enq : TX - index contention

\- enq : TX - allocate ITL entry

\- enq : TX contention

\- latch free

\- Log file sync

\- checkpoint completed

\- log file switch completion

\- log buffer space

**Latch Free** 는 특정 자원에 대한 래치를 여러 차레 요청했지만 해당 자원이 계속 사용 중이어서 잠시 대기 상태로 빠질 때마다 발생하는 대기 이벤트다.

Latch는 우리가 흔히 말하는 Lock 과 조금 다르다.

LOCK 은 사용자 데이터를 보호하는 반면, 래치는 SGA에 공유돼 있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 LOCK 이다.

Latch도 일종의 Lock 이지만 Queueing 메커니즘을 사용하지 않는다. 따라서 특정 자원에 엑세스하려는 프로세스는 래치 획득에 성공할 때까지 **시도**를 **반복**할 뿐, **우선권**을 부여 받지는 못한다.

---

## 응답 시간 분석

세션 또는 시스템 전체에 발생하는 **병목현상**과 그 **원인**을 찾아 문제를 해결하는 방법과 과정을 다루는 **응답 시간 분석 방법론** 은 **서비스 시간** 과 **대기 시간** 의 **합**으로 정의한다.

```sql
-- RESPONSE TIME = SERVICE TIME + WAIT TIME
-- = CPU TIME _ QUEUE TIME
```

**서비스시간**은 프로세스가 정상적으로 동작하며 일을 수행한 시간을 말한다. CPU TIME 과 같은 의미다.

**대기시간**은 프로세스가 잠시 수행을 멈추고 대기한 시간을 말한다. QUEUE TIME 이라고도 한다.

응답 시간 분석 방법론에 기반한 튜닝은 병목해소의 과정이다. 응답 시간을 위와 같이 정의하고, CPU TIME과 WAIT TIME을 각각 break down 하면서 서버의 일량과 대기 시간을 분석해 나간다.

CPU TIME이 파싱 작업에 소비한 시간인지 아니면 쿼리 본연의 오퍼레이션 수행을 위한 소비 시간인지 분석한다.

WAIT TIME은 각각 발생한 대기 이벤트들을 분석해 가장 많은 시간을 소비한 이벤트 중심으로 해결방안을 모색한다.

모니터링과 튜닝을 반복하면서 병목을 해소해 나가는 이 방법론을 지원하는 성능관리 툴이 많이 개발됐고 이미 보편화 돼 있다.

이들 툴은 대기 이벤트 발생현황을 지속적으로 수집하면서 실시간으로 병목 발생상황을 체크해주고, 과거 시점에 대한 리포팅도 제공한다.

---

## AWR

Automatic Workload Repository 는 응답 시간 분석 방법론을 지원하는 ORACLE 표준도구다.

아래 나열한 동적 성능 뷰를 주기적으로 특정 저장소에 저장하고 분석함으로써 DBMS 전반의 건강 상태를 체크하고, 병목원인과 튜닝 대상을 식별해 내는 방법을 제공한다.

\- v$segstat

\- v$undostat

\- v$latch

\- v$latch_children

\- v$sgastat

\- v$pgastat

\- v$sysstat

\- v$system_event

\- v$waitstat

\- v$sql

\- v$sql_plan

\- v$sqlstats

\- v$active_session_history

\- v$osstat

오래전부터 제공하던 성능관리 패키지 STATPACK 은 SQL을 이용한 딕셔너리 조회 방식인데 반해, AWR은 DMA 방식으로 SGA 공유 메모리를 직접 액세스하기 때문에 좀 더 빠르게 정보를 수집할 수 있다.

부하가 적기 때문에 더 많은 정보를 수집하고 제공할 수 있게 된다.

---

## AWR 기본 사용법

sys 계정 밑에 **DBA_HIST** 로 시작하는 뷰를 이용한다.

이들 뷰를 이용해 다양한 성능 분석자료를 보고서 형태로 뽑아 볼 수 있는데, 직접 작성한 쿼리를 이용할 수도 있지만 아래 스크립트를 이용하면 표준화한 보고서를 출력한다.

```sql
SQL > @?rdbms/admin/awrrpt
```

성능 진단 보고서를 출력할 때는 측정 구간, 즉 시작 스냅샷 id와 종료 스냅샷 ID를 어떻게 입력하느냐가 가장 중요하다.

만약 매일 시스템의 LOAD PROFILE이 어떻게 변하는지 비교할 목적이라면 업무 시간을 기준으로 뽑는다.

어느 요일에 SQL 수행과 트랜잭션이 가장 많은지, 어느 요일에 입출력이 많이 발생하는지 등을 비교해 자신이 관리하는 시스템의 사용패턴을 파악하는 것도 의미있는 정보가 된다.

사용자 인터뷰를 통해 성능 저하 현상을 경험했던 시간대를 파악하거나 모니터링 도구를 이용해 CPU, 메모리, I/O 사용량 정보를 수집하고 이를 통해 PEAK 시간대를 파악해야한다.

---

## AWR 리포트 분석

리포트의 맨 첫 장에 제공하는 한 장의 요약보고서만 정확히 해석할 줄 안다면 ORACLE 데이터베이스의 건강상태를 한눈에 파악할 수 있다.

첫 장 요약보고서는 부하 프로필, 인스턴스 효율성, 공유 풀 통계, 최상위 5개 대기 이벤트 등으로 구성된다.

**부하 프로필**

Per Second는 각 측정 지표 값들을 측정 시간으로 나눈 것이다. 따라서 초당 부하 발생량을 의미한다.

Per Transaction 은 각 측정 지표 값들을 트랜잭션 개수로 나눈 것이다. 한 트랜잭션 내에서 평균적으로 얼만큼의 부하가 발생하는지를 보여주는데 트랜잭션 개수는 Commit 또는 ROLLBACK 수행 홧수를 단순히 더한 값이다.

**인스턴스 효율성**

인스턴스 효울성 항목은 EXECUTE to Parse % 항목을 제외하면 모두 100%에 가까운 수치를 보여야 정상이다.

참고로 위에서 PARSE CPU TO PARSE ELAPSD % 항목이 0.85%로 비정상적으로 낮은 수치를 보인 것은 ACTIVE 프로세스가 동시에 폭증하면서 과도한 parse call 이 발생한 장애 상황에서 측정했기 때문이다.

**공유풀 통계**

AWR 리포트 구간 시작 시점의 공유 풀 메모리 상황과 종료 시점에서의 메모리 상황을 보여준다.

**최상위 5개 대기 이벤트**

최상위 5개 대기 이벤트는 AWR 리포트 구간 동안 누적 대기 시간이 가장 컸떤 대기 이벤트 5개를 보여준다.

CPU TIME 은 대기 이벤트가 아니며 원활하게 일을 수행했던 서비스 time 이지만, 가장 오래 대기를 발생시켰던 이벤트와의 점유율을 서로 비교해 볼 수 있도록 top 5 대기 이벤트에 포함해 보여주고 있다.

CPU TIME이 TOTAL CALL TIME 에서 차지하는 비중이 가장 높아 top 1에 위치한다면 일단 DB의 건강상태가 양호하다는 청신호인 셈이다.

서비스가 정상적으로 수행된 시간대에 AWR 리포트를 뽑더라도 cpu time을 제외하고 항상 4개의 대기 이벤트가 나열된다.

따라서 실제 시스템에 악영향을 주었는지에 대한 세부적인 분석 없이 대기 이벤트 순위가 상위로 매겨졌다는 이유만으로 이상 징후로 단정할 수는 없다.

예를들어 래치나 lock 관련 대기 이벤트 순위가 상위로 매겨졌다면 문제가 발생했음을 나타내는 위험 신호일 가능성이 높지만, 래치의 경우는 CPU 사용률까지 같이 분석해 봐야한다.

래치 경합은 CPU 사용률을 높이는 주원인이므로, 그 당시 CPU 사용률이 높지 않았다면 다른 이벤트보다 상대적으로 많이 발생한 것에 불과할 수 있다.

트랜잭션 처리 위주의 시스템이라면 LOG FILE SYNC 대기 이벤트가 TOP 5 내에 포함됐다고 무조건 이상징후로 보기 어렵다.

이벤트가 많이 발생한 것만으로 불필요한 커밋을 자주 날렸다고 판단해서는 안된다.

입출력 관련 대기 이벤트가 상위로 올라오는 것은 상황에 따라 다르게 해석해야한다.

데이터베이스는 입출력 집약적인 시스템이므로 DB FILE SEQUENTIAL READ, DB FILE SCATTERED READ 대기 이벤트가 상위에 매겨지는 게 정상이다.

OLTP 시스템이냐 DW, OLAP 시스템이냐에 따라 둘 간의 순서가 바뀔 수는 있지만 입출력 대기 이벤트가 높게 나타나는 것은 대개 정상이라는 뜻이다.

다만 이 두 대기 이벤트가 cpu time 보다 높은 점유율을 차지하고, os 모니터링 결과 CPU 사용률도 매우 높은 상황이 지속된다면 입출력 튜닝이 필요한 시스템일 가능성이 높다.

결론적으로 이 두 대기 이벤트는 I/O 효율화 튜닝이 필요한 시스템에도 순위가 높게 매겨지지만 튜닝이 잘된 시스템에서도 마찬가지 결과가 나오므로 상세한 분석을 통해 결론을 도출해야한다.
