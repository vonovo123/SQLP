# 파티션 개요

파티셔닝은 테이블 또는 인덱스 데이터를 파티션 단위로 나누어 저장하는 것을 말한다. 테이블을 파티셔닝하면 파티션 키에 따라 물리적으로 별도의 세그먼트에 데이터를 저장하며, 인덱스도 마찬가지다. 파티셔닝이 필요한 이유를 관리적 측면과 성능적 측면으로 나눠 볼 수 있다.

- 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경
- 성능적 측면 : 파티션 단위 조회 및 DML 수행, 경합 및 부하 분산

파티셔닝은 우선 관리 측면에서 많은 이점이 있다. 보관주기가 지난 데이터를 별도 장치에 백업하고 지우는 일은 데이터베이스 관리자들의 일상적인 작업이다. 만약 파티션 없이 대용량 테이블에 이런 작업을 수행하려면 시간도 오래걸리고 비효율 적이다. 대용량 테이블에 인덱스를 새로 생성하거나 재생성할 때도 파티션 기능을 이용하면 효과적이다.

성능 측면에서의 효용성도 매우 좋다. 데이터를 빠르게 검색할 목적으로 데이터베이스마다 다양한 저장구조와 검색 기법들이 개발되고 있지만, 인덱스를 이용한 랜덤 엑세스 방식은 일정량을 넘는 순간 FULTT TABLE SCAN보다 오히려 성능이 떨어진다. 그렇다고 초대용량 테이블을 FULL SCAN 하는 것은 매우 비효율적이다. 이런 경우 테이블을 파티션 단위로 나누어 관리하면, FULL TABLE SCAN 이라 하더라도 일부 세그먼트만 읽고 작업을 마칠 수 있다.

테이블이나 인덱스를 파티셔닝하면 DBMS는 내부에 2개 이상의 저장영역을 생성하고, 그것들이 논리적으로 하나의 오브젝트임을 메타종보로 관리한다. 파티션되지 않은 일반 테이블 일때는 테이블과 저장영역이 1:1 관겨이지만 파티션한 테이블 일때는 1:M 관계이다. 인덱스를 파티셔닝 할때도 마찬가지다.

---

# 파티션 유형

## RANGE 파티셔닝

\- 파티션 키 값의 범위로 분할
\- 파티셔니의 가장 일반적인 형태이며, 주로 날짜 칼럼으 기준으로 함

## HASH 파티셔닝

\- 파티션 키 값에 해시 함수를 적용하고, 거기서 반환된 값으로 파티션 매핑
\- 데이터가 모든 파티션에 고르게 분산되도록 DBMS가 관리 -> 각 로우의 저장 위치 예측 불가
\- 파티션 키의 데이터 분포가 고른 칼럼이어야 효과적
\- 병렬처리 시 성능효과 극대화
\- DML 경합 분산에 효과적

## LIST 파티셔닝

\- 불연속적인 값의 목록을 각 파티션에 지정
\- 순서와 상관없이, 사용자가 미리 정한 기준에 따라 데이터를 분할 저장

## COMPOSITE 파티셔닝

\- RANGE나 LIST 파티션 내에 또 다른 서브 파티션 구성
\- RANGE 나 LIST 파티션이 갖는 이점 + 각 서브 파티션 구성의 이점

```sql

-- ORACLE 에서 RANGE 파티셔닝하는 방법을 간단히 예시하면 다음과 같다.
create table order (orderNumber number, orderDate, varchar2(8), custId varchar2(5), )
partition by range(주문일자) (
  partition p2009_q1 value less then ('20090401')
  ,partition p2009_q2 value less then ('20090701')
  ,partition p2009_q3 value less then ('20091001')
  ,partition p2009_q4 value less then ('20100101')
  ,partition p2009_q1 value less then ('20100401')
  ,partition p9999_mx value less then (MAXVALUE) -> 주문일자 >= '20100401'
)

-- ORACLE 에서 [RANGE+HASH]로 파티셔닝하는 방법을 간단히 예시하면 다음과 같다.
create table order (orderNumber number, orderDate, varchar2(8), custId varchar2(5), )
partition by range(주문일자)
subpartition by hash(고객id) suspartitions 8
(
  partition p2009_q1 value less then ('20090401')
  ,partition p2009_q2 value less then ('20090701')
  ,partition p2009_q3 value less then ('20091001')
  ,partition p2009_q4 value less then ('20100101')
  ,partition p2009_q1 value less then ('20100401')
  ,partition p9999_mx value less then (MAXVALUE) -> 주문일자 >= '20100401'
)
```

---

# 파티션 PRUNING

파티션 PRUNING 은 옵티마이저가 SQL의 대상 테이블과 조건절을 분석해 불필요한 파티션을 엑세스 대상에서 제외하는 기능을 말한다.
이를 통해 엑세스 조건과 관련된 파티션만 작업을 수행할 수 있다. 파티션 테이블에 조회나 DML 을 수행할때 극적인 성능 개선의 핵심 원리가 바로 파티션 PRUNNING에 있다.

기본 파티션 PRUNING에는 정적 PRUNING과 동적 PRUNING이 있다. DBMS 별로 서브쿼리 PRUNING, 조인 필터 PRUNING 같은 고급 기법을 지원한다.

## 정적 파티셔 PRUNING

엑세스할 파티셔을 컴파일 시점에 미리 결정하며, 파티셔 키 칼럼을 상수 조거으로 조회하는 경우 정적 PRUNING이 작동한다.

## 동적 파티션 PRUNING

엑세스할 파티션을 실행 시점에 결정하며, 파티션 키 칼럼을 바인드 변수로 조회하는 경우가 대표적이다. NL 조인할 때도 INNER 테이블이 조인 칼럼 기준으로 파티셔닝돼 있으면 동적 PRUNING이 작동한다.

파티션 PRUNING은 SQL에 사용한 조건절과파티션 구성을 분석해 DBMS가 지능적으로 수행하는 메커니즘이므로 사용자가 굳이 신경 쓰지 안하도 된다.
다만 파티션 키 칼럼에 대한 가공이 발생하지 않도록 주의해야 한다. 사용자가 명시적으로 파티션 키 칼럼을 가공했을 때는 물론, 데이터 타입이 묵시적으로 변환될 때도 정상적인 pruning이 불가능해지기 때문이다.

--

# 인덱스 파티셔닝

지금까지 테이블 파티션 위주로만 설명했는데, 테이블 파티션과 인덱스 파티션을 구분할 줄 알야아한다.

## LOCAL 파티션 인덱스 vs GLOBAL 파티션 인덱스

\- LOCAL 파티션 인덱스

테이블 파티션과 1:1로 대응되도록 파티셔닝한 인덱스. 인텍스 파티션 키를 사용자가 따로 지정하지 않으며, 테이블과 1:1 관계를 유지하도록 DBMS가 자동으로 관리해준다.

\- GLOBAL 파티션 인덱스

테이블 파티션과 독립적인 구성을 갖도록 파티셔닝한 인덱스

---

## PREFIXED 파티션 인덱스 vs NONPREFIXED 파티션 인덱스

인덱스 파티션 키 칼럼이 인덱스 구성상 왼쪽 선두 칼럼에 위치하는지에 따른 구분이다.

\- PREFIXED : 파티션 인덱스를 생성할 때, 파티션 키 칼럼을 인덱스 키 칼럼 왼쪽 선두에 두는 것을 말한다.
\- NONPREFIXED : 파티션 인덱스를 생성할 때, 파티션 키 칼럼을 인덱스 키 칼럼 왼쪽 선두에 두지 않는 것을 말한다. 파티션 키가 인덱스 칼럼에 아예 속하지 않을 때도 여기에 속한다.

비파티션까지 포함해 인덱스를 총 5가지 유형으로 구분할 수 있다.

\- LOCAL PREFIXED PARTITION INDEX
\- LOCAL NONPREFIXED PARTITION INDEX
\- GLOBAL PREFIXED PARTITION INDEX
\- GLOBAL NONPREFIXED PARTITION INDEX
\- NONPARTITION INDEX

ORACLE 은 이중 GLOBAL NONPREFIXED 파티션 인덱스를 허용하지 않는다.

---

## 인덱스 파티셔닝 가이드

인덱스 파티션은 파티션 테이블과 마찬가지로 성능, 관리 편의성, 가용성, 확장성 등을 제공한다.
종속적인 LOCAL 파티션과, 테이블과 독립적인 GLOBAL 파티션 모두 가능하지만, 관리적인 측면에서 LOCAL 인덱스가 훨씬 유용하다.

테이블 파티션에 대한 DROP, EXCHANGE, SPLIT 등의 작업 시 GLOBAL 인덱스는 UNUSUAL 상태가 되기 때문이다.
인덱스를 다시 사용할 수 있게 하려면 인덱스를 REBUILD 하거나 재생성해 줘야 한다.

인덱스 파티셔닝 적용가이드

### 비파티션

\- 파티션 키 칼럼이 조건절에 없으면 여러 인덱스 파티션을 엑세스해야 하므로 비효율적.
특히 OLTP 환경에서 성능에 미치는 영향이 크므로 비파티셔닝 전략이 유용할 수 있음

\- NL 조인에서 파티션 키에 대한 넓은 범위검색 조건을 가지고 INNER 테이블 엑세스 용도로 인덱스 파티션이 사용된다면 비효율적 -> 비파티션 인덱스 사용을 고려

\- 파티션 인덱스를 이용하면 SORT ORDER BY 대체 효과 상실. 소트 연산을 대체함으로써 부분범위처리를 활용하고자 할 땐 비파티셔닝 전략이 유용

\- 테이블 파티션 이동, 삭제 등의 작업시 UNUSABLE 되므로 적용할 때 주의

### GLOBAL PREFIXED

\- 인덱스 경합 분산에 효과적
\- 여러 LOCAL 인덱스 파티션을 엑세스하는 것이 비효율적일 때 대안으로 활용 가능
\- 테이블 파티션 이동, 삭제 등의 작업시 UNUSABLE 되므로 적용할 때 주의

### LOCAL PREFIXED

\- 관리적 측면에서 유용 : 테이블 파티션에 대한 추가, 삭제 등의 작업이 빈번할 때
\- 이력성 데이터를 주로 관리하는 DB 환경에 효과적
\- 파티션 키 칼럼이 '=' 조건으로 사용될 때 유용
\- 파티셔닝 컬럼이 검색 조건에 없으면 인데스 선두 칼럼이 조건절에 누락된 것이므로 정상적인 사용ㅇ 불가
\- 파티션 키 칼럼이 like, between, 부등호 같은 범위검색 조건일 때 불리

### LOCAL NON PREFIXED

\- 관리적 측면에서 유용 : 테이블 파티션에 대한 추가, 삭제 등의 작업이 빈번할 때
\- 이력성 데이터를 주로 관리하는 DB 환경에 효과적
\- 파티션 키 칼럼이 조건절에 사용될 때 유용
\- 파티셔닝 칼럼에 대한 검색 조건이 없으면 인덱스 파티션 전체를 액세스하는 비효율이 발생할 수 있으므로 주의
\- 파티션 키 칼럼이 범위검색 조건으로 자주 사용된다면 local prefixed 보다 local non prefixed가 유리
그렇더라도 좁은 범위검색어어야 함
