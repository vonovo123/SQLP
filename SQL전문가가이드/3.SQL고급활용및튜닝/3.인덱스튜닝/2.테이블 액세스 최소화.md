# 인덱스 ROWID에 의한 테이블 랜덤 액세스

쿼리에서 참조되는 칼럼이 인덱스의 키에 모두 포함되는 경우가 아니라면, '테이블 랜덤 액세스' 가 일어난다. 다음 실행 계획에서 'TABLE ACCESS BY INDEX ROWID' 라고 표시된 부분을 말한다.

```sql
SELECT * FROM 고객 where 지역 = '서울';

-- EXECUTION PLAN
--------------------
SELECT STATEMENT
TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
INDEX (RANGE SCAN) OF '고객_지역_인덱스'
```

## 인덱스 ROWID에 의한 테이블 액세스 구조

인덱스에 저장돼 있는 ROW ID 는 흔히 '물리적 주소정보'라고 일컬어진다. 오브젝트 번호, 데이터 파일 번호, 블록 번호 같은 물리적 요소로 구성되어있다.

하지만 보는 시각에 따라 논리적 주소정보라고 표현하기도 한다. ROW_ID 가 물리적 위치 정보로 구성되지만 인덱스에서 테이블 레코드로 직접 연결되는 구조는 아니기 때문이다.

중요한 것은 ROW ID 가 메모리 상의 위치정보가 아니라 디스크 상의 위치정보라는 사실이다.

데이터 블록을 읽을 때는 항상 버퍼 캐시를 경유하므로 메모리 상에서 버퍼 블록을 찾기위해 해시 구조와 알고리즘을 사용한다.
해시 키 값으로는 rowid에 내포된 데이터 블록 주소를 사용한다.

인덱스의 ROWID 를 이용해 테이블 블록을 읽는 메커니즘을 요약하면 다음과 같다.

\- 인덱스에서 하나의 ROW ID를 읽고 DBA를 해시 함수에 적용해 해시 값을 확인한다.

\- 해시 값을 이용해 해시 버킷을 찾아간다.

\- 해시 버킷에 연결된 해시 체인을 스캔하면서 블록 헤더를 찾는다.

\- 해시 체인에서 블록 헤더를 찾으면 거기 저장된 포인터를 이용해 버퍼블록을 읽는다.

\- 해시 체인을 스캔하고도 블록 헤더를 찾지 못하면, LRU 리스트를 스캔하면서 FREE 버퍼를 찾는다. 디스크에서 읽은 블록을 적재하기 위해 빈 캐시공간을 찾는다.

\- LRU 리스트에서 FREE 버퍼를 얻지 못하면 DIRTY 버퍼를 디스크에 기록해 FREE 버퍼를 확보한다.

\- FREE 버퍼를 확보하고 나면 디스크에서 블록을 읽어 캐시에 적제한다.

이러한 과정을 거치기에 인덱스 ROW ID에 의한 테이블 엑세스는 생각만큼 빠르지 않다. 특히 다량의 테이블 레코드를 읽을 때의 성능 저하가 심각하다.

실행 계획에 TABLE ACCESS BY INDEX ROWID 나 RID LOOKUP 오퍼레이션은 인덱스 ROW ID 에 의한 테이블 엑세스이다.

---

## 클러스터링 팩터

ORACLE은 클러스터링 팩터라는 개념을 사용해 인덱스 ROWID에 의한 테이블 엑세스 비용을 평가한다.

클러스터링 팩터는 '군집성 계수' 쯤으로 번역될 수 있는 용어로, 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여 있는 정도를 의미한다.

인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 전혀 일치하지 않으면 인덱스 클러스터링 팩터가 가장 좋지 않은 상태인다.

---

## 인덱스 손익분기점

데이터가 일정량을 넘는 순간 인덱스 스캔이 테이블 전체 스캔보다 오히려 더 느려진다. INDEX RANGE SCAN에 의한 테이블 액세스가 TABLE FULL SCAN보다 느려지는 지점을 손익 분기점이라고 부른다.

인덱스의 손익분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만, 클러스터링 팩터에 따라 크게 달라진다.

클러스터링 팩터가 나쁘면 손익분기점은 5% 미만에서 결정된다. 반대로 클러스터링 팩터가 아주 좋을 때는 손익분기점이 90% 수준까지 올라가기도 한다.

인덱스에 의한 액세스가 FULL TABLE SCAN 보다 더 느리게 만드는 가장 핵심적인 두가지 요인은 다음과 같다.

인덱스 ROWID 에 의한 테이블 액세스는 랜덤 액세스인 반면, FULL TABLE SCAN 은 시퀀셜 엑세스 방식으로 이뤄진다. 디스크 I/O 시, 인덱스 ROWID 에 의한 테이블 액세스는 SINGLE BLOCK READ 방식을 사용하믄 반면, FULL TABLE SCAN 은 MULTIBLOCK READ 방식을 사용한다.

---

## 손익분기점 극복하기

손익분기점 원리에 따르면 선택도가 높은 인덱스는 효용가치가 낮다. 그렇더라도 테이블 전체가 스캔하는 것은 부담스러울 때가 많다. 이럴때 DBMS가 제공하는 기능을 잘 활용하면 인덱스의 손익분기점 한계를 극복하는데 도움이 된다.

첫 번째, SQL SERVER의 클러스터형 인덱스 또는 ORACLE IOT로 테이블을 인덱스 구조로 생성하는 것이다.
테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다. 더불어 인덱스 리프 블록이 곧 데이터 블록이어서 인덱스를 수직 탐색한 다음 테이블 레코드를 일기 위한 추가적인 랜덤 엑세스가 불필요하다.

두 번째, SQL SERVER의 INCLUDE INDEX이다. 인덱스 키 외에 미리 지정한 칼럼을 리프 레벨에 함께 저장하는 기능이다. 테이블의 랜덤 엑세스 횟수를 줄이도록 돕는다.

세 번째, ORACLE 이 제공하는 클러스터 테이블이다. 키 값이 같은 레코드를 같은 블록에 저장하기 때문에 클러스터 테이블에 대한 클러스터 인덱스를 이용할때는 테이블 랜덤 액세스가 키 값별로 한 번씩만 발생한다. 클러스터에 도달해서는 시퀀셜 방향으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다.

네 번째는 파티셔닝이다. 읽고자 하는 데이터가 많을 때는 인덱스를 이용하지 않는 편이 낫다고 하지만 수천만 건에 이르는 테이블을 FULL SCAN 해야 한다면 난감하다.

그럴 때 대량 범위검색 조건으로 자주 사용되는 칼럼 기준으로 테이블을 파티셔닝하면 full table SCan 하더라도 일부 파티션만 읽고 멈출 수 있다.

클러스터는 기준 키 값이 같은 레코드를 블록 단위로 모아 저장하지만, 파티셔닝은 세그먼트 단위로 저장하는 점이 다르다.

---

# 테이블 액세스 최소화 튜닝

## 인덱스 칼럼 추가

```sql

-- EMP 테이블에 현재 PK 이외에 [DEPTNO + JOB] 순으로 구성된 emp_x01 인덱스 하나만 있는 상태에서 다음 쿼리를 수행하려 한다.

SELECT /*+INDEX(EMP EMP_X01)*/ ENAME, JOB, SAL
FROM EMP
WHERE  DEPTNO = 30
AND SAL >= 2000


-- 위 조건을 만족하는 사원은 한명 뿐인데 테이블 엑세스가 6번 발생했다.
----------------------------------------------------------
Plan hash value: 1549005378

--------------------------------------------------------------------------------
-------

| Id  | Operation		    | Name    | Rows  | Bytes | Cost (%CPU)| Tim
e     |

--------------------------------------------------------------------------------
-------

|   0 | SELECT STATEMENT	    |	      |     4 |    84 |     2	(0)| 00:
00:01 |

|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP     |     4 |    84 |     2	(0)| 00:
00:01 |

|*  2 |   INDEX RANGE SCAN	    | EMP_X01 |     5 |       |     1	(0)| 00:
00:01 |

--------------------------------------------------------------------------------
-------


Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("SAL">=2000)
   2 - access("DEPTNO"=30)

-- 인덱스 구성을 [DEPTNO + SAL] 순으로 바꿔주면 좋겠지만 실 운영 환경에서는 인덱스 구성을 함부로 변경하기 어렵다.
-- 기존 인덱스를 사용하는 다음과 같은 SQL 이 있을 수 있기 때문이다.
SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO =30 AND JOB = 'CLERK';

```

할 수 없이 인덱스를 새로 만들어야겠지만 이런 식으로 인덱스를 추가하다 보면 테이블마다 인덱스가 만들어진다. 이럴때 기존 인덱스에 SAL 칼럼을 추가하는 것만으로 큰 효과를 거둘 수 있다. 인덱스 스캔량은 줄지 않지만 테이블 랜덤 엑세스 횟수를 줄여주기 때문이다.

---

## COVERED INDEX

테이블을 액세스하고서 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스 칼럼을 추가함으로써 얻는 성능 효과를 살펴보았다.

그런데 테이블 랜덤 엑세스가 아무리 많더라도 필터 조건에 의해 버려지는 레코드가 거의 없다면 비효율은 없다.

이때는 어떻게 튜닝해야할까? 이때는 아예 테이블 액세스가 발생하지 않도록 필요한 모든 칼럼을 인덱스에 포함시키는 방법을 고려해 볼 수 있다.

이렇게 인덱스만 읽고 처리하는 퀴리를 COVERED 쿼리라고 부른다.

---

## IOT, 클러스터형 인덱스, 클러스터 테이블 활용

해시 클러스터 테이블은 해시 함수에서 반환된 값이 같은 데이터를 물리적으로 함께 저장하는 구조다. 클러스터 키로 데이터를 검색하거나 저장할 위치를 찾을 때 해시 함수를 사용한다.

해시 함수가 인덱스 역할을 대신하는 것이며, 해싱 알고리즘을 이용해 클러스터 키 값을 데이터 블록 주소로 변환해준다. 별도의 인덱스 구조를 생성하지 않는 장점에도 불구하고 제약사항은 '=' 검색만 가능하다는 점이다. 등호 조건으로만 검색되는 칼럼을 해시 키로 선정해야 한다.

---

## 수동으로 클러스터링 팩터 높이기

테이블에는 데이터가 무작위로 입력되는 반면, 그것을 가리키는 인덱스는 항상 key 순으로 정렬되기때문에 대개 클러스터링팩터가 좋지않게 마련이다. 클러스터릴 팩터가 나쁜 인덱스를 이용해 많은 데이터를 읽는 SQL 튜닝은 어렵다.

그럴때 인덱스 기준으로 테이블을 재생성함으로써 클러스터링 팩터를 인위적으로 좋게 만든는 방법을 생각해 볼 수 있다.

주의할 것은, 인덱스가 여러 개인 상황에서 특정 인덱스를 기준으로 테이블을 재정렬하면 다른 인덱스의 클러스터링 팩터가 나빠질 수도 있다는 점이다.

따라서 인위적으로 클러스터링 팩터를 높일 목적으로 테이블을 재조정할 때 가장 자주사용되는 인덱스를 기준으로 삼고 다른 인덱스를 사용하는 중요한 쿼리 성능에 나쁜 영향을 주지 않는지 확인해야한다.

---

## 배치 I/O

인덱스 ROWID를 이용한 테이블 랜덤 엑세스는 고비용 구조다. 인덱스를 이용해 대량 데이터를 조회하면 디스크 I/O 발생량도 증가해 성능이 급격히 나빠진다. 이를 방지하기 위한 다양한 방법중 배치I/O가 있다.

배치 I/O는 읽는 블록마다 건건이 입출력 호출을 발생시키는 비효율을 줄이기 위해 고안한 기능이다. 인덱스를 이용해 테이블을 엑세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 읽는다. 이 기능이 작동하면 데이터 블록에 대한 디스크 입출력 호출을 미뤗다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다는 사실에 주목해야한다. 테이블 블록을 모두 버퍼 캐시에서 찾을때는 기존 처럼 인덱스 키 값으로 데이터가 출력된다. 실제 배치 I/O가 작동할 때는 데이터 출력 순서가 인덱스 정렬 순서와 다를 수 있다.

```sql
-- 배치 I/O 가 작동할 때 나타나는 실행계획이다.
CREATE INDEX EMP_XO1 ON SCOTT.EMP(DEPTNO, JOB, EMPNO);
SET AUTOTRACE TRACEONLY EXP;
SELECT /*+batch_table_access_by_rowid(e)*/ *
FROM SCOTT.EMP e
WHERE DEPTNO = 20
ORDER BY JOB, EMPNO;
```

주목할 점은 소트 연산을 생략할 수 있는 인덱스 구성임에도 SORT ORDER BY 오퍼레이션이 나타났다는 사실이다.
배치 I/O 기능이 작동하면 데이터 정렬 순서를 보장할 수 없으므로 옵티마이저가 이런 선택을 한 것이다.

인덱스를 이용하면 결과 집합이 자동으로 인덱스 키값 순으로 정렬되므로 과거에는 ORDER BY를 생략한채 rownum 조건과 함께 INDEX/INDEX_DESC 힌트를 적용하는 패턴을 많이 사용했다.

```SQL
-- 변경일시 순으로 상위 10개 레코드 출력
SELECT /*+INDEX(H 상태변경이력_pk) */ 장비번호, 변경일시, 상태코드
FROM 상태변경이력 h
WHERE 장비번호 = :eqp_no
AND ROWNUM <= 10


-- 변경일시 역순으로 상위 1개 레코드 조회
SELECT 장비번호, 장비명, 상태코드
,(
  SELECT /*+INDEX_DESC(H 상태변경이력_pk) */ 변경일시
  FROM 상태변경이력 H
  WHERE 장비번호 = P.장비번호
  AND ROWNUM <= 1
) 최종변경일시
FROM 장비 P
WHERE 장비구분코드 = 'A001';
```

12C로 업그레이드 하면서 결과 집합의 정렬 순서가 달라질 수 있다. 'NO_BATH_TABLE_ACCESS_BY_ROWID' 힌트를 사용해도 되지만, 할 수 있다면 ORDER BY 를 추가하는 것이 바람직하다.
