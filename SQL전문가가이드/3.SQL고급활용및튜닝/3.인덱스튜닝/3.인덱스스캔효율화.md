SEQUENCIAL ACCESS 는 레코드간 논리적 또는 물리적 순서를 따라 차례대로 읽어나가는 방식을 말하고,
RANDOM ACCESS는 레코드간 논리적,물리적 순서를 따르지 않고 한 건을 읽기 위해 한 블록씩 접근하는 방식이다.

결과적으로 I/O 튜닝의 핵심 원리는 다음 과 같다

- 랜덤 엑세스 발생량을 줄인다.
- 시퀄셜 액세스에 의한 선택 비중을 높인다.

이 장에서는 시퀀셜 엑세스에 의한 선택 비중을 높이는 방안, 그 중에서도 인덱스를 시퀀셜 방식으로 스캔하는 단계에서 발생하는 비효율 해소 원리르 다룬다.

---

# 인덱스 선행 칼럼이 범위조건일 때의 비효울

인덱스 구성 칼럼이 조건절에서 모두 등치 조건으로 비교되면 리프 블록을 스캔하면서 읽은 레코드는 모두 테이블 액세스로 이어진다.
읽고 버리는 레코드가 하나도 없으므로 인덱스 스캔 단계에서의 효율은 최상이다. 인덱스 칼럼 중 일부가 등차 조건이 아니거나 조건절에서 생략 되더라도 그것이 뒤쪽 칼럼일 때는 비효율이 없다.

```sql

-- 예를 들어 인덱스가 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 구성됐을때 조건절이 다음과 같은 경우를 말한다.

WHERE 아파트시세코드 = :a
WHERE 아파트시세코드 = :a and 평형 = :b
WHERE 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c
WHERE 아파트시세코드 = :a and 평형 = :b and 평형타입 between :c and :d
```

반면 인덱스 선행 칼럼이 조건절에서 누락되거나 between, 부등호, LIKE 같은 범위검색 조건이 사용되면 인덱스를 스캔하는 단계에서 비효율이 발생한다.

```sql

-- 예를들어 인덱스가 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 구성된 상황에서 다음같은 SQL을 수행하는 경우이다.
-- 인터넷 매물이 between 조건이지만 선행 칼럼들이 모두 = 조건이므로 전혀 비효율 없이 2건을 빠르게 찾았다.
-- 인덱스 선행 칼럼이 모두 = 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 이유는 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.

SELECT 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
FROM 매물아파트매매
WHERE 아파트시세코드 =
AND 평형 =
AND 평형타입 =
AND 인터넷매물 BETWEEN '1' AND '2'
ORDER BY 입력일 DESC

-- 인덱스 구성을 [인터넷매물 + 아파트시세코드 + 평형 + 평형타입] 순으로 바꾸고 나서 같은 SQL을 수행해보면 인덱스 스캔 범위가 넓어진다.
-- 인덱스 선두 칼럼인 인터넷메물에 Between 연산자를 사용하면 등차비교 조건을 만족하는 레코드들이 인터넷매물값 별로 뿔뿔이 흩어진다
-- 따라서 조건을 만족하지 않는 레코드까지 스캔하고서 버려야 하는 비효울이 생간다.
```

---

# 범위조건을 IN-LIST로 전환

범위검색 칼럼이 맨 뒤로 가도록 인덱스를 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 변경하면 좋지만 운영중인 시스템에서 인덱스 구성을 바꾸기는 쉽지않다.

이럴때 BETWEEN 조건을 다음과 같이 IN-LIST로 바꿔주면 가끔 큰 효과를 얻는다.

```sql
-- 수직적 탐색이 두번 발생한다.(INLIST ITERATOR 오퍼래이선)
SELECT 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
FROM 매물아파트매매
WHERE 인터넷 매물 IN('1', '2');
AND 아파트시세코드 =
AND 평형 =
AND 평형타입 =
ORDER BY 입력일 DESC

-- 인덱스를 수직적 탐색으로 두 번 탐색하는 것은 SQL 이 다음과 같이 작성된 것과 마찬가지이다.
-- 모든 칼럼의 조건이 등차비교이다.

SELECT 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
FROM 매물아파트매매
WHERE 인터넷 매물 = '1'
AND 아파트시세코드 =
AND 평형 =
AND 평형타입 =
ORDER BY 입력일 DESC
UNION ALL
SELECT 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
FROM 매물아파트매매
WHERE 인터넷 매물 = '2'
AND 아파트시세코드 =
AND 평형 =
AND 평형타입 =
ORDER BY 입력일 DESC
```

인덱스 선두 칼럼의 Between 조건을 IN-LIST 조건으로 바꿀 때 주의할 점은, IN-LIST 개수가 많지 않아야 한다는 것이다.

익덱스 수직 탐색이 여러번 발생하기 때문이다. 인덱스 높이가 높을때 between 조건 때문에 리프 블록을 추가로 스캔하는 비효율보다 IN-LIST 조건으로 인해 발생하는 브랜치 블록을 반복하는 탐색이 비효율이 더 클 수 있다.

---

# 범위조건을 2개 이상 사용할 때의 비효율

인덱스 구성이 [회사 + 지역 + 상품명]일 때, 다음과 같이 범위검색 조건을 2개 이상 사용하면 첫 번째 조건이 인덱스 스캔 범위를 결정하고, 두 번째는 필터 조건 역할만 하기 때문에 성능상 불리해질 수 있다.

```sql

SELECT 고객 ID, 상품명, 지역
FROM 가입상품
WHERE 회사 = :com
AND 지역 like :reg || '%'
AND 상품명 like :prod || '%'

-- 스캔량이 소량일 때는 그 차이가 미미하지만 대량일 경우 상당한 성능 차이를 보일 수 있으므로 인덱스 칼럼에 대한 비교 연산자는 신중하게 선택해야한다.
-- 만약 지역 칼럼에 대한 조건이 입력되지 않을 수도 있어 위와 같이 LIKE 연산자를 사용한 거라면 sql을 다음과 같이 2개 만들어 사용하는 것이 좋다.

-- 지역 값이 입력되지 않는 경우
SELECT 고객 ID, 상품명, 지역
FROM 가입상품
WHERE 회사 = :com
AND 상품명 like :prod || '%'

-- 지역 값이 입력되는 경우
SELECT 고객 ID, 상품명, 지역
FROM 가입상품
WHERE 회사 = :com
AND 지역  = :reg
AND 상품명 like :prod || '%'

-- 또는 아래처럼 UNION ALL을 이용하는 방법도 있다.
-- UNION ALL 상단 쿼리는 기존과 동일한 비효율을 안은 채 수행되겠지만 하단 쿼리만큼은 최상으로 수행될 수 있다.
-- 만약 상당 쿼리까지 최적화하려면 [회사 + 상품명] 순으로 구성된 인덱스를 하나 더 추가해야한다.
-- 인덱스를 새로 추가하는 데 부담이 있으면 기존 인덱스 순서를 [회사 + 상품명 + 지역] 순으로 변경하는 것을 고려할 수 있다.
-- 그럴 경우 UNION ALL 하단 쿼리를 처리하는데 불리해진다.

SELECT 고객 ID, 상품명, 지역
FROM 가입상품
WHERE :REG IS NULL
WHERE 회사 = :com
AND 상품명 like :prod || '%'
UNION ALL
SELECT 고객 ID, 상품명, 지역
FROM 가입상품
WHERE :REG IS NOT NULL
AND 회사 = :com
AND 지역  = :reg
AND 상품명 like :prod || '%'
```
