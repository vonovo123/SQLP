책에 인덱스를 이용하면 원하는 키워드를 포함한 페이지를 빠르게 찾을 수 있다. 인덱스가 업다면 책 전체를 한 장씩 훝어가며 찾는 수 밖에
없다.

데이터베이스에서 사용하는 인덱스도 다르지 안다. 대용량 테이블에서 우리에게 필요한 데이터를 빨리 찾기 위해서는 인덱스의 도움이 필요하다. 인덱스가 아예 없거나, 적절한 인덱스를 찾지 못하면 테이블 전체를 읽어야 하기에 많은 시간이 소요된다.

---

# 인덱스 구조

## 인덱스 기본 구조

모든 DBMS는 다양한 인덱스를 제공한다.

가장 일반적으로 사용되는 인덱스의 구조는 B\*Tree 인덱스 구조이다. B\*TREE 인덱스는 맨 위쪽 루트노드에서 브랜치 노드를 거쳐 맨 아래 리프 노드까지 연결되는 구조다.

루트에서 리프블록까지의 거리를 '인덱스 깊이' 라고 부르고 인덱스를 반복적으로 탐색할 때 성능에 영향을 미친다.

인덱스의 블록은 컨텐츠(KEY)와 페이지(ROWID)로 구성된다.

루트와 브랜치 블록은 각 하위 노드들의 데이터 값 범위를 키 값으로 그 키 값에 해당하는 블록을 찾는데 필요한 주소 정보를 페이지(ROWID)로 가진다.

블록내부의 인덱스는 KEY 값에 따라 항상 정렬되어있다. 키 값이 같을때는 ROWID 순으로 정렬된다.
리프 블록은 항상 인덱스 키 값 순으로 정렬돼 있기 때문에 범위 스캔이 가능하고, 정방향과 역방향 스캔이 둘 다 가능하도록 양방향 연결 리스트 구조로 연결돼 있다.

만약 데이터가 10억건이있다면 데이터에 따른 인덱스도 10억개가 존재한다. 10억개의 데이터를 저장하는데 대략 1억개 정도의 데이터블록이 필요하다면 10억개의 인덱스를 저장하는데는 대략 300만개의 데이터 블록이 필요하다. 이는 데이터 자체의 볼륨보다 데이터의 정보를 가진 인덱스의 볼륨이 1/3 정도 더 적다는 것을 의미한다.

ORACLE에서 인덱스 구성 칼럼이 모두 Null인 레코드는 인덱스에 저장하지 않는다. 반대로 인덱스 구성 칼럼 중 하나라도 NUll 값이 아닌 레코드는 인덱스에 저장한다. 이런 특성이 null 값 조회에 인덱스가 사용될 수 있는지를 결정하므로 인덱스를 설계하거나 SQL을 개발할 때 반드시 숙지해야한다.

인덱스를 생성하면 루트블록와 리프블록은 같다.

하나의 데이터 블록에 대략 400개 정도의 인덱스가 저장된다고 가정하면, 401번째 인덱스가 생성되면 루트블록와 리프블록은 분리된다.

루트와 리프블록이 하나의 블록에 위치하면 즉, 깊이 레벨이 0이면 최대 400개의 데이터를 인덱싱할 수 있다.
1레벨의 깊이의 브랜치블록이 존재할 경우 최대 400^2 개의 데이터를 인덱싱 할 수 있다. 같은 원리로 4레밸 깊이의 브랜치노드가 존재할 경우 최대 400^5(10조개) 개의 데이터를 인덱싱 할 수 있다.

루트 블록은 인덱스 트리의 최상위 블록으로 각 인덱스에 하위블록에 속한 인덱스의 값의 범위 및 블록에 대한 주소(BLOCK ADDRESS)를 가지고 있다. 루트 블록은 자신의 하위 블록의 수 만큼의 인덱스를 가진다.

브랜치 블록은 루트 블록과 리프 블록의 연결고리 역할을 하는 블록으로 각 인덱스에 하위블록에 속한 인데스의 값의 범위 및 블록에 대한 (BLOCK ADDRESS)를 가지고 있다. 각 브랜치 블록은 자신의 하위 브랜치 블록 또는 리프 블록의 수 만큼 인덱스를 가진다.

리프 블록의 각 인덱스는 키값과 하위 테이블의 데이터에 대한 ROWID로 구성되어있다. 키값 순서대로 정렬 되어있으며, 이전 이후의 리프 블록과 연결되어있다.

---

## 인덱스 탐색

인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 나눠 설명할 수 있다. 수평적 탐색은 인덱스 리프 블록에 저장된 레코드 끼리 연결된 순서에 따라 스캔한다. 수직적 탐색은 수평적 탐색을 위한 시작점을 찾는 과정이라고 할 수 있다. 루트에서 리프 블록까지 아래쪽으로 진행된다.

인덱스 트리에서 에서 찾고자하는 값의 시작점을 찾는 것을 수직적 탐색, 시작점 부터 끝점을 찾는 것을 수평적 탐색이라고 한다.

정렬된 데이터 중 찾고자하는 데이터의 위치에 상관없이 브랜치노드의 깊이 만큼만 탐색하면 그 값을 찾을 수 있다.

전체 데이터 대비 찾는 데이터의 수가 10%가 넘으면 인덱스를 활용한 탐색보다 전체 스캔이 더 빠르다.

## RANDOM ACCESS VS. SEQUENTIAL ACCESS

RANDOM ACCESS는 하나의 블록에서 하나의 레코드(ROW)만 꺼내 읽는다. 수직적 탐색과 리프 블록에서 테이블에 접근하기 위해 사용한다.

SEQEUNTIAL ACCESS는 블록에 존재하는 모든 레코드(ROW)를 읽는다. 수평적 탐색에 사용되는 방식이다. 낭비되는 레코드가 없어 적은비용으로 효율적인 탐색이 가능하다. MULTI BLOCK I/O를 활용해 디스크 접근 횟수를 줄일 수 있다.

```sql
-- 키 값이 53 인 레코드를 찾는 탐색과정은 다음과 같다.
-- 우선 루트 블록에서 53이 속한 블록을 찾는데 필요한 블록 주소정보를 찾는다.
-- 루트 블록의 두 번째 레코드의 주소정보가 가리키는 3번 블록으로 찾아간다.
-- 3번 블록에서 53이 속한 속한 블록을 찾는데 필요한 주소 정보를 찾는다.
-- 3번 블록의 첫 번째 레코드의 주소정보가 가리키는 9번 블록으로 향한다.
-- 9번 블록은 리프 블록이므로 거기서 값을 찾거나 못 찾거나 둘 중 하나다.
-- 9번 블록의 세번째 레코드의 키값이 53번이므로 함께 저장된 ROWID를 이용해 테이블 블록으로 찾아간다.
-- ROWID를 분해해 보면 오브젝트 번호, 데이터 파일 번호, 블록번호, 블록 내 위치 정보를 알 수 있다.
-- 테이블 블록에서 레코드를 찾아간다.
-- 키가 UNIQUE 인덱스가 아니라면 값이 53인 레코드가 더 있을 수 있다.
-- 9번 블록에서 레코드 하나를 더 읽어 키 값이 53인 레코드가 더 있는지 확인한다.
-- 키 값이 53인 레코드가 더 이상 나오지 않을 때까지 스캔하면서 테이블 블록에서 레코드를 찾는 과정을 반복한다.
-- 만약 9번 블록을 다 읽었는데도 계속 53이 나오면 10번 블록으로 넘어가서 스캔을 계속한다.
```

---

# 다양한 인덱스 스캔 방식

## INDEX RANGE SCAN

인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 수평적 스캔하는 방식
B\*TREE 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있다.

```sql
SQL> CREATE INDEX EMP_DEPTNO_IDX ON SCOTT.EMP(DEPTNO);

Index created.

SQL> SET AUTOTRACE TRACEONLY EXPLAIN
SQL> SELECT * FROM SCOTT.EMP WHERE DEPTNO = 20;

Execution Plan
----------------------------------------------------------
Plan hash value: 2468466201

--------------------------------------------------------------------------------
--------------

| Id  | Operation		    | Name	     | Rows  | Bytes | Cost (%CP
U)| Time     |

--------------------------------------------------------------------------------
--------------

|   0 | SELECT STATEMENT	    |		     |	   5 |	 190 |	   2   (
0)| 00:00:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP	     |	   5 |	 190 |	   2   (
0)| 00:00:01 |

|*  2 |   INDEX RANGE SCAN	    | EMP_DEPTNO_IDX |	   5 |	     |	   1   (
0)| 00:00:01 |

--------------------------------------------------------------------------------
--------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("DEPTNO"=20)

```

인덱스를 수직적으로 탐색한 후에 리프 블록으로 '필요한 범위'만 스킨한다. 이는 범위 스캔이 의미하는 바를 잘 설명해준다.
실행계획 상에 INDEX RANGE SCAN이 나타난다고 해서 항상 빠른 속도를 보장하는 것은 아니다. 인덱스를 스캔하는 범위를 얼마나 줄일 수 있느냐, 테이블로 액세스하는 횟수를 얼마나 줄일 수 있느냐가 관건이다.

INDEX RANGE SCAN이 가능하게 하려면 인덱스를 구성하는 선두 칼럼이 조건절에 사용돼야한다. 그렇지 못한 상황에서 인덱스를 사용하도록 힌트를 강제로 설정하면 INDEX FULL SCAN 방식으로 처리된다.

INDEX RANGE SCAN 과정을 거쳐 생성된 결과집합은 인덱스 칼럼 순으로 정렬된 상태가 되기때문에 이런 특성을 이용하면 sort order by 연산을 생략하거나 min/max를 빠르게 추출할 수 있다.

---

## INDEX FULL SCAN

수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식으로, 대게 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.

```SQL

CREATE INDEX EMP_IDX ON SCOTT.EMP(ENAME, SAL);

SET AUTOTRACE TRACEONLY EXP

SELECT * FROM SCOTT.EMP
WHERE SAL > 2000
ORDER BY ENAME;

| Id  | Operation		    | Name    | Rows  | Bytes | Cost (%CPU)| Tim
e     |

--------------------------------------------------------------------------------
-------

|   0 | SELECT STATEMENT	    |	      |    10 |   380 |     2	(0)| 00:
00:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP     |    10 |   380 |     2	(0)| 00:
00:01 |

|*  2 |   INDEX FULL SCAN	    | EMP_IDX |    10 |       |     1	(0)| 00:
00:01 |

--------------------------------------------------------------------------------
-------
```

수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로만 탐색한다. 이는 개념적으로 설명하기 위한 것일 뿐 실제로는 수직적 탐색이 먼저 일어나다. 루트 블록과 브랜치 블록을 거치지 않고는 가장 왼쪽에 위치한 첫 번째 리프 블록을 찾아갈 방법이 없기 때문이다.

- INDEX FULL SCAN 의 효용성

인덱스 선두 칼럼(ename)이 조건절에 없으면 옵티마이저는 우선적으로 TABLE FULL SCAN을 이용한다. 대용량 테이블이어서 TABLE FULL SCAN 부담이 크다면 옵티마이저는 인덱스를 활용하는 방법을 고려한다.

데이터 저장공간은 '칼럼길이 \* 레코드수'로 결정되므로 대개 인덱스가 차지하는 면적은 테이블보다 훨씬 적다. 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 일부 테이블에 대해서만 테이블 액세스가 발생하는 경우라면 테이블 전체를 스캔하는것 보다 낫다. 이럴 때 옵티마이저는 INDEX FULL SCAN 방식을 선택할 수 있다.

즉, 최종 결과 값이 적을 땐 TABLE FULL SCAN 보다 INDEX FULL SCAN이 효율적이고 최종 결과 값이 많을 땐 TABLE FULL SCAN이 효율적이다.

아래는 INDEX FULL SCAN이 효과를 발휘하는 케이스다

```sql

-- 연봉이 5000을 초과하는 사원이 전체 중 극히 일부라면 INDEX FULL SCAN을 통한 필터링이 큰 효과를 가져다준다. 하지만 이런 방식은 적절한 인덱스가 없어 INDEX RANGE SCAN의 차선책으로 선택된 것이므로 가능하다면 인덱스 구성을 조정해 주는 것이 좋다.

SELECT * FROM SCOTT.EMP WHERE SAL > 5000 ORDER BY ENAME;
Execution Plan
----------------------------------------------------------
Plan hash value: 737262432

--------------------------------------------------------------------------------
-------

| Id  | Operation		    | Name    | Rows  | Bytes | Cost (%CPU)| Tim
e     |

--------------------------------------------------------------------------------
-------

|   0 | SELECT STATEMENT	    |	      |     1 |    38 |     2	(0)| 00:
00:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP     |     1 |    38 |     2	(0)| 00:
00:01 |

|*  2 |   INDEX FULL SCAN	    | EMP_IDX |     1 |       |     1	(0)| 00:
00:01 |

--------------------------------------------------------------------------------
-------
```

- 인덱스를 이용한 소트 연산 대체

INDEX FULL SCAN은 INDEX RANGE SCAN과 마찬가지로 그 결과 집합이 인덱스 칼럼 순으로 정렬되므로 SORT ORDER BY 연산을 생략할 목적으로 사용될 수 있다.

```SQL
-- 대부분 사원의 연봉이 1000을 초과하므로 INDEX FULL SCAN을 하면 거의 모든 레코드에 대해 테이블 엑세스가 발생한다.
-- 만약 SAL이 인덱스 선두 칼럼이어서 INDEX RANGE SCAN 을 하더라도 마찬가지다.
-- 그럼에도 인덱스가 사용된 것은 사용자가 first_rows 힌트를 이용해 옵티마이저 모드를 바꾸었기 때문이다.
-- 옵티마이저는 소트 연산을 생략함으로써 전체 집합 중 처음 일부만 빠르게 리턴할 목적으로 INDEX FULL SCAN 방식을 선택한 것이다.
-- 사용자가 처음 의도와는 다르게 데이터 읽기를 멈추지 않고 끝까지 FETCH 한다면 FULL TABLE SCAN 한 것보다 훨씬 더 많은 I/O를 일으키면서 서버자원을 낭비하는데 이는 옵티마이저의 잘못이 아닌 first_rows 힌트를 사용한 사용자에게 책임이 있다.

SELECT /*+ FIRST_ROWS */ * FROM EMP
WHERE SAL > 1000
ORDER BY ENAME;
```

---

## INDEX UNIQUE SCAN

수직적 탐색만으로 인덱스를 찾는 방식으로, UNIQUE 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.

```sql
CREATE UNIQUE INDEX PK_EMP ON SCOTT.EMP(EMPNO);
ALTER TABLE EMP ADD CONSTRAINT PK_EMP PRIMARY KEY(EMPNO) USING INDEX PK_MEP;

SET AUTOTRACE TRACEONLY EXPLAIN;
SELECT EMPNO, ENAME FROM SCOTT.EMP WHERE EMPNO = 7788;

Execution Plan
----------------------------------------------------------
Plan hash value: 2949544139

--------------------------------------------------------------------------------
------

| Id  | Operation		    | Name   | Rows  | Bytes | Cost (%CPU)| Time
     |

--------------------------------------------------------------------------------
------

|   0 | SELECT STATEMENT	    |	     |	   1 |	  10 |	   1   (0)| 00:0
0:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |	   1 |	  10 |	   1   (0)| 00:0
0:01 |

|*  2 |   INDEX UNIQUE SCAN	    | PK_EMP |	   1 |	     |	   0   (0)| 00:0
0:01 |

--------------------------------------------------------------------------------
------

```

---

## INDEX SKIP SCAN

인덱스 선두 칼럼이 조건절로 사용되지 않으면 옵티마이저는 기본적으로 TABLE FULL SCAN을 선택한다.
또는 TALBE FULL SCAN 보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 INDEX FULL SCAN 방식을 사용한다.

ORACLE 은 인덱스 선두 컬럼이 조건절에서 빠졌어도 인덱스를 활용하는 새로운 스캔방식인 INDEX SKIP SCAN을 9i버전부터 제공한다.

예를 들어 성별과 연봉 두 칼럼으로 구성된 결합 인덱스에서 선두 칼럼인 성별 조건이 빠진 SQL문이 INDEX SKIP SCAN 방식으로 수행될 때의 실행계획은 다음과 같다.

```SQL
-- 인덱스 : 성별 + 연봉

SELECT * FROM 사원 WHERE 연봉 BETWEEN 2000 AND 4000;

-- EXECUTION PLAN
--------------
SELECT STATMENT OPTIMIZER=ALL_ROWS
  TABLE ACCESS BY INDEX(ROWID) OF '사원'(TABLE)
    INDEX (SKIP SCAN) OF '사원_IDX'(INDEX)
```

수행원리를 간단히 요약하면, 루트 또는 브랜치 블록에서 읽은 칼럼값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 하위 블록만 골라서 엑세스하는 방식이라고 할 수 있다.

조건절에서 빠진 인덱스 선두 칼럼의 DISTINCT VALUE 개수가 적어야 유리하다. DISTINCT가 높으면 DISTINCT 의 수만큼 SKIP이 일어나기 때문이다. 반대로 후행 칼럼의 DISTINCT VALUE 개수가 많을 때 유용하다. 조건절이 BETWEEN LIKE, 부등호 일 때도 사용 가능하다.

```sql
SELECT * FROM EMP
WHERE SALARY BETWEEN 2000 AND 4000
AND GENDER IN ('MALE', 'FEMALE')

-- EXECUTE PLAN
------------
SELECT STATEMENT OPTIMIZER = ALL_ROWS
  INLIST ITERATOR
    TABLE ACCESS ( BY INDEX ROWID) OF 'EMP'(TABLE)
      INDEX (RANGE SCAN) OF 'EMP_IDX'(INDEX)
```

실행계획 1번 단계에 INLIST ITERATOR라고 표시된 부분은 조건절 ln-list에 제공된 값의 종류만큼 인덱스 탐색을 반복 수행함을 뜻한다.

직접 성별에 대한 조건식을 추가해주면 INDEX SKIP SCAN에 의존하지 않고도 빠르게 결과 집합을 얻을 수 있다. 단 이처럼 IN-LIST 를 명시하려면 성별 값의 종류가 더 이상 늘지 않음이 보장돼야한다. 그리고 이 기법이 효과를 발휘하려면 IN-LIST로 제공하는 값의 종류가 적어야한다.

---

## INDEX FAST FULL SCAN

INDEX FAST FULL SCAN 은 INDEX FULL SCAN 보다 빠르다. 그 이유는 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 MULTOBLOCK READ 방식으로 스캔하기 때문이다.

조회 조건이 인덱스 선두 컬럼이 아니어서 INDEX RANGE SCAN의 사용이 불가하면 옵티마이저는 INDEX FULL SCAN을 선택한다. 이때 블록단위가 아닌 익스텐트(8개의 블록) 단위로 읽는다.

인덱스 리프블록을 MULTI-BLOCK I/O로 읽기 때문에 스캔 속도가 빠르다. TABLE RANDOM I/O가 발생하는 경우 사용이 불가하므로 인덱스에 포함되는 컬럼으로만 조회할 때 사용 가능하다.

---

## INDEX RANGE SCAN DECENDING

INDEX RANGE SCAN 과 기본적으로 동일한 스캔 방식이다. 단 인덱스를 뒤쪽에서 부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과 집합을 얻는다.

```sql
-- 아래처럼 EMP TABLE EMPNO 기분으로 내림차순 정렬하고자 할때 EMPNO 컬럼에 인덱스가 있으면 옵티마이져가 알아서 인덱스를 거꾸로 읽는 실행계획을 수립한다.

SELECT * FROM EMP
WHERE EMPNO IS NOT NULL

Execution Plan
----------------------------------------------------------
Plan hash value: 3088625055

--------------------------------------------------------------------------------
------

| Id  | Operation		    | Name   | Rows  | Bytes | Cost (%CPU)| Time
     |

--------------------------------------------------------------------------------
------

|   0 | SELECT STATEMENT	    |	     |	  14 |	 532 |	   2   (0)| 00:0
0:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |	  14 |	 532 |	   2   (0)| 00:0
0:01 |

|   2 |   INDEX FULL SCAN DESCENDING| PK_EMP |	  14 |	     |	   1   (0)| 00:0
0:01 |

--------------------------------------------------------------------------------
------


ORDER BY EMPNO DESC

-- 아래처럼 Max 값을 구하고자 할 때도 해당 칼럼에 인덱스가 있으면 인덱스를 뒤에서부터 한 건만 읽고 멈추는 실행계획이 자동으로 수립된다.
SQL> SELECT DEPTNO, DNAME, LOC ,(SELECT MAX(SAL) FROM SCOTT.EMP WHERE DEPTNO = D.DEPTNO) FROM SCOTT.DEPT D;

Execution Plan
----------------------------------------------------------
Plan hash value: 3928207977

--------------------------------------------------------------------------------
--------

| Id  | Operation		     | Name    | Rows  | Bytes | Cost (%CPU)| Ti
me     |

--------------------------------------------------------------------------------
--------

|   0 | SELECT STATEMENT	     |	       |     4 |    80 |     3	 (0)| 00
:00:01 |

|   1 |  SORT AGGREGATE 	     |	       |     1 |     7 |	    |
       |

|   2 |   FIRST ROW		     |	       |     1 |     7 |     1	 (0)| 00
:00:01 |

|*  3 |    INDEX RANGE SCAN (MIN/MAX)| EMP_X02 |     1 |     7 |     1	 (0)| 00
:00:01 |

|   4 |  TABLE ACCESS FULL	     | DEPT    |     4 |    80 |     3	 (0)| 00
:00:01 |

--------------------------------------------------------------------------------
```

---

# 인덱스 종류

## B\*TREE 인덱스

모든 DBMS가 B\*TREE 인덱스를 기본적으로 제공한다. 추가로 제공하는 인덱스 구조는 모두 단점을 보완하기 위해 개발된 것들이다.

### UNBALANCED INDEX

트리는 DELETE 작업 때문에 인덱스가 불균형 상태에 놓일 수 있다. 다른 리프 노드에 비해 루트 블록과의 거리가 더 멀거나 더 가까운 리프노드가 발생할 수 있다.

B\*TREE 구조에서 이런 현상을 절대 발생하지 않는다. B\*TREE 는 인덱스 루트에서 리프 블록까지 어떤 값으로 탐색하더라도 블록 수가 같음을 의미한다. 즉, 루트로부터 모든 리프 블록까지의 높이가 동일하다.

### INDEX SKEW

B\*TREE 구조에서 불균형은 생길 수 없지만 INDEX FRAGMENTATION에 의한 INDEX SKEW 또는 SPARSE 현상이 생기는 경우가 있다. 이는 인덱스 스캔 효율에 나쁜 영향을 미칠 수 있다. 인덱스 엔트리가 오른쪽 또는 왼쪽에 치우치는 현상을 말한다.

```sql
-- 인덱스 왼쪽에 있는 리프 블록들은 텅 비는 반면 오른쪽 은 꽉찬 상태가 된다.

CREATE TABLE T AS SELECT ROWNUM NO FROM BIG_TABLE ROWNUM <= 100000;
CREATE INDEX T_IDX ON T(NO);
DELETE FROM T WHERE NO <= 50000;
```

ORACLE의 경우 텅 빈 인덱스 블록은 커밋하는 순간 Freelist로 반환되지만 인덱스 구조 상에는 그대로 남는다.

상위 브랜치 불록에서 해당 리프 블록을 가리키는 엔트리가 그대로 남아 있어 인덱스 정렬 순서상 그곳에 입력될 새로운 값이 들어오면 언제든 재사용된다.

새로운 값이 하나라도 입력되기 전 다른 블록에 인덱스 분할이 발생하면, 그것을 위해서도 이들 블록이 재사용된다. 이때 상위 브랜치 블록에서 해당 리프 블록을 가리키는 엔트리가 제거되 다른 쪽 브랜치의 자식 노드로 이동하고 FREELIST에서도 제거된다.

레코드가 모두 삭제된 블록은 언제든 재사용 가능하지만, 문제는 다시 채워질 때까지 인덱스 스캔 효율이 낮다는데 있다.

### INDEX SPARE

인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말한다. 예를 들어 다음과 같은 형태로 DELETE 작업을 수행하고 나면 t_idx 블록의 밀도는 50% 정도밖에 되지 않는다. 100만 건 중 50만 건을 지우고 나서도 스캔한 인덱스 블록 수가 똑같이 2001 개이다.

```sql
CREATE TABLE T AS SELECT ROWNUM NO FROM BIG_TABLE ROWNUM <= 100000;
CREATE INDEX T_IDX ON T(NO);
-- 2001 CONSISTENT GETS
SELECT /*+INDEX(T)*/ COUNT(*) FROM T WHERE NO > 0;
DELETE FROM T WHERE MOD(NO, 10) > 5;
COMMIT
-- 2001 CONSISTENT GETS
SELECT /*+INDEX(T)*/ COUNT(*) FROM T WHERE NO > 0;
```

지워진 자리에 인덱스 정렬 순서에 따라 새로운 값이 입력되면, 그 공간은 재사용되지만 위와 같은 대량의 DELETE 작업이 있고 난 후 한동안 인덱스 스캔 효율이 낮다는데에 문제가 있다.

오른쪽/왼쪽/중간 어디든 INDEX SKEW 처럼 블록이 아예 텅 비면 곧바로 freelist로 반환돼 언제든 재사용되지만, INDEX SPARSE는 지워진 자리에 새로운 값이 입력되지 않으면 영영 재사용 되지 않을 수도 있다.

총 레코드 건수가 일정한데도 인덱스 공간 사용량이 계속 커지는 것은 이러한 현상에 기인한다.

### 인덱스 재생성

FRAGMENTATION 때문에 인덱스 크기가 계속 증가하고 스캔 효율이 나빠지면 인덱스를 재생성하거나 DBMS가 제공하는 명령어를 이용해 빈 공간 제거가 유용할 수 있다.

하지만 일반적으로 인덱스 블록에는 어느 정도 공간을 남겨두는 것이 좋다. 왜냐면 빈 공간을 제거해 인덱스 구조를 슬림화하면 저장 효율이나 스캔 효율엔 좋겠지만 인덱스 분할이 자주 발생해 DML 성능이 나빠질 수 있기 때문이다. 인덱스 분할에 의한 경합을 줄일 목적으로, 초기부터 빈 공간을 남기도록 옵션을 주고 인덱스를 재생성할 수도 있다.

인덱스를 재생성하는 데 걸리는 시간과 부하도 무시할 수 없다. 따라서 인덱스의 주기적인 재생성 작업은 다음과 같이 예상효과가 확실할 때만 시행하는 것이 바람직하다.

\- 인덱스 분할에 의한 경합이 현저히 높을 때

\- 자주 사용되는 인덱스 스캔 효율을 높이고자 할때, 특히 NL 조인에서 반복 액세스 되는 인덱스 높이가 증가했을 때

\- 대량 DELETE 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때

\- 총 레코드 수가 일정한데도 인덱스가 계속 커질때

---

## 비트맵 인덱스

ORACLE은 비트맵 인덱스 구조를 제공한다. 비트맵 인덱스는 부정형 조건에도 사용할 수 있다.
B\*TREE 인덱스와 달리 비트맵 인덱스는 NULL 도 저장하기 때문에 다음과 같은 조건에도 사용할 수 있다.

```SQL
SELECT * FROM PRODUCT
WHERE COLOR IS NULL;
```

칼럼의 DISTICT VALUE 개수가 적을 때 비트맵 인덱스를 사용하면 저장효율이 매우 좋다. B\*TREE 인덱스보다 훨씩 적은 용량을 차지하므로 인덱스가 여러 개 필요한 대용량 테이블에 유용하다.

다양한 분석관점을 가진 팩트성 테이블이 주로 여기에 속한다. 반대로 DISTICT VALUE 가 아주 많은 칼럼이면 오히려 B\*TREE 인덱스 보다 많은 공간을 차지한다.

DISTICT VALUE 개수가 적은 칼럼일 때 저장효율이 좋지만, 테이블 랜덤 액세스 발생 측면에서는 B\*TREE와 똑같기 때문에 그런 칼럼을 비트맵 인덱스로 검색하면 그다지 좋은 성능을 기대하기 어렵다.

따라서 하나의 비트맵 인덱스는 단독으로는 쓰임새가 별로 없다. 그 대신 여러 비트맵 인덱스를 동시에 사용할 수 있는 특징 때문에 대용량 데이터 검색 성능을 향상 시키는 데에 효과가 있다.

예컨대 다음과 같은 쿼리에 여러 개 비트맵 인덱스로 BITWISE 연산을 수행한 결과, 테이블 엑세스량이 크게 줄어든다면 큰 성능 개선을 기대할 수 있다.

```sql
SELECT 지역, sum(판매량), sum(판매금액)
from 연도별지역상품매출
where (크기 = 'small' or 크기 is null)
and 색상 = 'green'
and 출시연도 = '2010'
group by 지역
```

비트맵 인덱스는 여러 인덱스를 동시에 활용할 수 있다는 장점 때문에 다양한 조건절이 사용되는, 특히 정형화되지 않은 임의 질의가 많은 환경에 적합하다.

다만 비트맵 인덱스는 lock에 의한 DML 부하가 심한 것이 단점이다. 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 lock 이 걸린다.

---

## 함수기반 인덱스

ORACLE 이 제공하는 함수기반 인덱스는 칼럼 값 자체가 아닌 칼럼에 특정함수를 적용한 값으로 B\*TREE 인덱스를 만든다.

```sql
SELECT *
FROM 주문
WHERE NVL(주문수량, 0) < 100
```

주문수량 칼럼에 인덱스가 있어도 위처럼 인덱스 칼럼을 가공하면 정상적인 인덱스 사용이 불가하다.

하지만 조건절과 똑같이 NVL 함수를 씌워 아래처럼 인덱스를 만들면 인덱스 사용이 가능하다. 주문 수량이 null인 레코드는 인덱스에 0으로 저장된다.

```sql
CREATE INDEX EMP_X01 ON EMP(NVL(주문수량, 0));
```

이 외에도 함수기반 인덱스가 유용한 사례는, 대수문자를 구분해 입력 받은 데이터를 대소문자 구분 없이 조회할 때다.

upper(column name) 함수를 씌워 인덱스를 생성하고 upper 조건으로 검색하는 것이다.

함수기반 인덱스는 데이터 입력, 수정 시 함수를 적용해야 하므로 다소 부하가 발생할 수 있다. 사용된 함수가 사용자 정의 함수일 때는 부하가 더 심하다.

---

## 리버스 키 인덱스

일련번호나 주문일시 같은 칼럼에 인덱스를 만들면, 입력되는 값이 순차적으로 증가하기 때문에 오른쪽 리프 블록에만 데이터가 쌓인다. 이런 현상이 발생하는 인덱스를 흔히 RIGHT GROWING 인덱스라고 부른다. 동시 INSERT가 심할때 인덱스 블록 경합을 일으켜 초당 트랜잭션 처리량을 크게 감소시킨다.

그럴 때 리버스 키 인덱스가 유용할 수 있다. 이것은 말 그래도 입력된 키 값을 거꾸로 변환해서 저장하는 인덱스다. 다음과 같이 reverse 함수에서 변환된 값을 저장하는 인덱스라고 생각하면 쉽다.

```sql
create index 주문_x01 on 주문 (reverse(주문일시))
```

순차적으로 입력되는 값을 거꾸로 변환해 저장하면 데이터가 고르게 분포한다. 따라서 리프블록 맨 우측에만 집중되는 트랜젹션을 리프 블록 전체에 고르게 분산시키는 효과를 얻을 수 있다.

하지만 리버스 키 인덱스는 데이터를 거꾸로 입력하기 때문에 = 조건으로만 검색할 수 있다. 즉 부등호나 Between, like 같은 범위검색 조건에서는 사용할 수 없다.

---

## 클러스터 인덱스

클러스터 테이블에는 인덱스 컬러스터와 해시 클러스터 두 가지가 있는데 클러스터 인덱스는 인덱스 클러스터와 관련이 있다. 인덱스 클러스터 테이블은 클러스터키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조를 사용한다. 한 블록에 클러스터키가 같은 레코드를 모두 담을 수 없을 때는 새로운 블록을 할당해 클러스터 체인으로 연결한다.

여러 테이블 레코드가 물리적으로 같은 블록에 저장되도록 클러스터를 할당할수도 있다. 여러 테이블을 서로 조인된 상태로 저장해 두는 것인데, 일반적으로는 하나의 데이터 블록이 여러 테이블에 의해 공유될 수 없다.

ORACLE에서 인덱스 클러스터를 만들고, 거기에 클러스터 인덱스를 정의하는 방법은 다음과 같다.

```sql
create cluster c_deptno# (deptno number(2)) index;
create index i_deptno# on cluster c_deptno#;

-- 생성한 클러스터에 다음과 같이 테이블을 담는다.
create table emp
cluster c_detpno# (deptno)
select * from emp;
```

클러스터 인덱스도 일반적인 B\*TRE 인덱스 구조를 사용하지만, 해당 키 값을 저장하는 첫 번째 데이터 블록만 가리킨다는 점에서 다르다.

클러스터 인덱스의 키 값은 항상 unique 하며 테이블 레코드와 1:M 관계를 갖는다. 일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 갖는다.

이런 구조적 특성 때문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩만 발생한다. 클러스터에 도달하는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 검색할 때 유리하다.

새로운 값이 자주 입력(새 클러스터 할당)되거나 수정이 자주 발생하는 칼럼(클러스터 이동)은 클러스터 키로 선정하지 않는 것이 좋다.

---

# 인덱스 튜닝 기초

BTREE 인덱스를 정상적으로 사용하려면 범위 스캔 시작지점을 찾기 위해 루트 블록부터 리프블록까지의 수직적 탐색 과정을 거쳐야 한다.

만약 인덱스 선두 칼럼이 조건절에 사용되지않으면 범위 스캔을 위한 시작점을 찾을 수 없어 인덱스 전체를 스캔하거나 테이블 전체를 스캔하는 방식을 선택한다.

인덱스 선두 칼럼이 조건절에 사용되더라도 범위 스캔이 불가능하거나 인덱스를 아예 사용 못하는 경우가 있다.

## 범위 스캔이 불가능하거나 인덱스 사용이 불가능한 경우

```sql
-- 다음과 같이 인덱스 선두 칼럼을 조건절에서 가공하면 정상적으로 인덱스를 사용할 수 없다.
SELECT *
FROM 업체
WHERE SUBSTR(업체명, 1, 2) = '대한'

-- 부정형 비교를 사용해도 마찬가지다.
SELECT *
FROM 고객
Where 직업 <> '학생'

-- is not null 조건도 부정형 비교에 해당하므로 정상적인 인덱스 사용은 어렵다
SELECT *
FROM  사원
WHERE  부서코드 is not null
```

위 세 경우 모두 정상적인 INDEX RANGE SCAN이 불가능할 뿐 인덱스 사용은 가능하다. INDEX FULL SCAN은 가능하다.

맨 마지막 SQL을 예를 들어, '부서코드' 단일 칼럼 인덱스가 존재한다면 그 인덱스 전체를 스캔하면서 얻은 레코드는 모두 '부서코드 is not null' 을 만족한다. ORACLE은 단일 칼럼인덱스에 Null 값은 저장하지 않기 때문이다.

결합 인덱스 일때는 인덱스 구성 칼럼 중 하나라도 값이 NULL이 아닌 레코드는 인덱스에 저장한다. 그래서 필터링을 통해 '부서코드 Is not null' 조건에 해당하는 레코드를 모두 찾을 수 있다.

인덱스 사용이 불가능한 경우도 있다. 'is null' 조건만으로 검색할 때가 그렇다. 인덱스도 구성 칼럼이 모두 NULL인 레코드는 인덱스를 만들지 않기 때문에 인덱스를 사용할 수 없다.

```sql

-- 다른 인덱스 칼럼에 is null 이 아닌 컬럼이 하나라도 있거나 not null 제약이 있으면, oracle에서도 is null에 대한 INDEX RANGE SCAN이 가능하다.

-- 물론 인덱스 선두 칼럼이 조건절에서 누락되지 않아야한다.

SELECT *
FROM 사원
WHERE 연락처 IS null

```

---

## 인덱스 칼럼의 가공

인덱스 칼럼을 가공하면 정상적인 INDEX RANGE SCAN 이 불가능해진다.

```sql

-- 인덱스 칼럼 가공사례 1

select *
from dep
where substr(DEPNAME, 1, 3) = 'KOR'

-- 튜닝방안 1
SELECT *
FROM DEP
WHERE DEPNAME LIKE 'KOR%'

-- 인덱스 칼럼 가공사례 2
SELECT *
FROM EMP
WHERE SALARY * 12 = 36000000

-- 튜닝방안 2

SELECT *
FROM EMP
WHERE SALARY  = 36000000 / 12

-- 인덱스 칼럼 가공사례 3
SELECT *
FROM ORDER
WHERE TO_CAHR(ORDER_DATE, 'YYYYMMDD') = : DT

-- 튜닝방안 3

SELECT *
FROM ORDER
WHERE ORDER_DATE >= TO_DATE(:DT, 'YYYYMMDD')
AND ORDER_DATE < TO_DATE(:DT, 'YYYYMMDD')+1;

-- 인덱스 칼럼 가공사례 4
SELECT *
FROM CUS
WHERE AGE || JOB = '30DEV'

-- 튜닝방안 4

SELECT *
FROM CUS
WHERE AGE = 30
AND  JOB = 'DEV'

-- 인덱스 칼럼 가공사례 5
SELECT *
FROM CLIENT
WHERE C_NUM || D_NO = :STR

-- 튜닝방안 5

SELECT *
FROM CLIENT
WHERE C_NUM = SUBSTR(:STR, 1, 2)
AND D_NO = SUBSTR(:STR 3,4)

```

## 묵시적 형변환

인덱스 칼럼을 사용자가 명시적으로 가공하지 않더라도 조건절에서 비교되는 두 값의 데이터 타입이 다르면 내부적으로 형변환이 일어난다.

```sql

-- 예를 들어 EMP 테이블 Deptno 칼럼은 number 형이다. 이 칼럼에 대한 검색조건으로는 숫자형이 옳지만 자칫 실수로 다음과 같이 문자형으로 코딩하는 경우가 생긴다.
SELECT * FROM EMP WHERE DEPTNO = '20'

-- 다행히 문자형과 숫자형이 만나면 입티마이저가 문자형을 숫자형으로 변환한다.
-- 덕분에 인덱스 또한 정상적으로 사용할수 있다.

|   0 | SELECT STATEMENT	    |		     |	   5 |	 190 |	   2   (
0)| 00:00:01 |

|   1 |  TABLE ACCESS BY INDEX ROWID| EMP	     |	   5 |	 190 |	   2   (
0)| 00:00:01 |

|*  2 |   INDEX RANGE SCAN	    | EMP_DEPTNO_IDX |	   5 |	     |	   1   (
0)| 00:00:01 |

--------------------------------------------------------------------------------
--------------

-- 이번에는 Cdeptno 라는 문자형 칼럼을 추가하고 인덱스까지 생성한다음 다음과 같이 테스트르 해보자

SELECT * FROM EMP WHERE CDEPTNO = 20

-- FIlter (TO_NUMBER("EMP"."CDEPTNO")=20)
--문자형 CDEPTNO 칼럼이 숫자형으로 변환된 것을 볼 수 있고, 이 때문에 emp 테이블을 TABLE FULL SCAN 하는 계획이 수립됐다.
-- 인덱스 컬럼을 가공했기 때문에 인덱스를 사용할 수 없게 됐다.
```

묵시적 형변환은 사용자가 코딩을 쉽게 하도록 도울 목적으로 제공하는 기능이지만, 위와 같은 부작용을 피하려면 가급적 명시적인 변환함수를 사용하는 것이 좋다.
성능을 위해서라면 인덱스 칼럼과 비교되는 반대쪽을 인덱스 칼럼 데이터 타입에 맞춰주면 되기 때문이다.

묵시적 형변환은 주로 성능 측면에서 언급되곤 하지만, 올바른 결과 집합을 얻기 위해서라도 변환함수를 명시하는 것이 바람직하다.
