DBMS를 사용하다 보면 NULL 값으로 인한 많은 특이사항을 접하게 된다. NULL 값이 가지는 특성을 이해하지못하면 데이터 오류를 경험할 수 있으므로 반드시 숙지해야한다.

![주문 모델](./%EC%A3%BC%EB%AC%B8%EB%AA%A8%EB%8D%B8.png)

주문금액과 주문취소금액의 NULL 을 허용한 경우 (바커 표기법 상 속성 앞에 동그라미) 몇 가지 특성이 존재한다.

# NULL 값의 연산은 언제나 NULL 이다.

NULL 값은 공백이나 숫자 0 과는 전혀 다른 의미이다. '아직 정의되지 않은 미지의 값' 또는 '현재 데이터를 입력하지 못하는 경우' 를 의미한다.
즉, 값이 존재 하지 않는 상황을 나타낸다.

![주문 데이터](./%EC%A3%BC%EB%AC%B8%20%EB%8D%B0%EC%9D%B4%ED%84%B0.png)

데이터를 바탕으로 다음 SQL의 결과를 예측해보자

```sql
SELECT 주문금액 - 주문취소금액 COL1
, NVL(주문금액 - 주문취소금액, 0) COL2
, NVL(주문금액,0) - NVL(주문취소금액,0) COL3
FROM 주문
```

COL1, COL2, COL3는 최종 주문금액을 구하는 산식이다. 최종 주문금액은 각 주문의 주문금액에서 취소된 주문금액을 제외한 결과이다.
이와 같은 요건에서는 주로 COL1, COL2, COL3의 방식으로 SQL을 작성한다. 동일한 목적으로 작성된 COL1, COL2, COL3의 결과는 모두 동일할까?

![SQL수행결과](./SQL%20%EC%88%98%ED%96%89%20%EA%B2%B0%EA%B3%BC.png)

결과를 보면 NULL 값이 포함되었을 경우 COL1, COL2, COL3 의 결과과 모두 다르게 출력되는 것을 알 수 있다. 이유는 NULL 값의 연산은 언제나 NULL이기 때문이다.
NULL은 아직 값이 존재하지 않는 상태로 연산이 불가능하다. 그렇기에 NULL 연산은 언제나 Null을 결과로 반환한다.
Null 값으로 가능한 연산은 'IS NULL, IS NOT NULL' 연산밖에 없다.
위의 SQL에 사용된 NVL 함수는 첫 번째 인자값의 결과가 NULL 일 경우 두 번째 인자 값을 반환하는 함수이다.

```sql
-- null 값을 전혀 고려하지 않고, 주문금액에서 주문취소금액을 제외한 방식이다. null 이 존재하는 두번째 행의 결과는 15,000 - Null = null 로 Null 값을 반환하게 된다.
주문금액 - 주문취소금액

-- 주문금액에서 주문취소금액을 제외한 결과에 대해 NVL 처리 한다. 두 번째 행의 결과는 NVL(Null,0) 을 0을 반한한다. 실제 원하는 값과 다르다.
NVL(주문금액-주문취소금액 , 0)

-- 속성별로 NVL 처리하고, 이후 주문금액에서 주문취소금액을 제외하였다. 두 번째 행의 계산결과는 NVL(15000, 0) - NVL(null, 0) 으로 예상한 결과 값을 얻을 수 있다.
NVL(주문금액,0) - NVL(주문취소금액,0)

```

# 집계함수는 null 값을 제외하고 처리한다.

![주문 데이터](./%EC%A3%BC%EB%AC%B8%20%EB%8D%B0%EC%9D%B4%ED%84%B02.png)

주문취소금액은 전부 Null 값으로 아직 취소된 주문이 없는 상태이다. 본 데이터르 바탕으로 다음 SQL 결과를 예측해보자.

```sql
SELECT SUM(주문금액) - SUM(주문취소금액) COL1
, NVL(SUM(주문금액 - 주문취소금액), 0) COL2
, NVL(SUM(주문금액),0) - NVL(SUM(주문취소금액), 0) COL3
FROM 주문
```

![sql 수행결과](./SQL%20%EC%88%98%ED%96%89%20%EA%B2%B0%EA%B3%BC%202.png)

COL1, COL2, COL3은 최종주문금액 총합을 구하는 산식이다. 최종주문금액 총합은 각 주문의 주문금액에서 취소된 주문금액을 제외하고 이를 합산한 결과이다.
위의 수행결과를 보면 COL1, COL2, COL3 는 모두 다른 결과를 출력한다. Null 값의 연산은 언제나 Null 이고 집계함수(SUM)은 Null의 경우를 제외하고 연산한다.

```sql
-- 속성별로 SUM 함수로 합산을 먼저 수행하고, 총주문금액에서 총주문취소금액을 제외한다. 주문취소금액을 합산한 결과는 Null 이기때문에 연산식은 300000 - null 로 null 이 된다.
SUM(주문금액) - SUM(주문취소금액)

-- 각 행의 주문금액에서 주문취소금액을 제외한 결과를 SUM 함수로 합산하고, 최종결과가 NULL일 경우 0을 반한하는 NVL 처리를 한다. 각 행의 연산결과가 null 이므로 이를 합산한 결과는 Null 이 된다.
-- NVL(null, 0) 의 결과는 0 이다.
NVL(SUM(주문금액 - 주문취소금액), 0)

-- 각 행의 속성을 합산하고 null 인경우 0을 반환한다. 그 결과 최종적으로 300000 - 0 이 되어 300000을 반환하게 된다.
NVL(SUM(주문금액),0) - NVL(SUM(주문취소금액), 0)
```

![주문 데이터](./%EC%A3%BC%EB%AC%B8%20%EB%8D%B0%EC%9D%B4%ED%84%B03.png)

주문취소금액의 평균을 구하는 sql 은 다음과 같다

```sql
SELECT SUM(주문취소금액) / COUNT(*) COL1
, AVG(주문취소금액) COL2
FROM 주문
```

![SQL 수행 결과](./SQL%EC%88%98%ED%96%89%EA%B2%B0%EA%B3%BC3.png)

왜 COL1과 COL2의 결과가 다른지 살펴보자.

```sql
-- 평균의 모수를 전체 주문으로 할 경우에 해당한다. COUNT는 속성이 NULL 인 행을 제외하지 않는다.
SUM(주문취소금액) / COUNT(*)

-- 평균의 모수를 주문취소금액이 존재하는 행으로 한정할때 해당한다. AVG는 값이 NULL 인 행을 제외한다.
AVG(주문취소금액)
```

속성에 NULL 값이 존재한다면 많은 사항을 고려해야 한다. 모델을 생성할 때, 업무를 정확히 파악하여 NULL 허용 여부를 판단해야한다.
