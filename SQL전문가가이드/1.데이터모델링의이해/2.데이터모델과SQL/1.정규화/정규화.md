데이터모델링에서 정규하는 가장 기초적이지만 필수적인 작업이다. 성능을 위해 반정규화를 하기도 한다.

# 제1정규형

## 모든 속성은 반드시 하나의 값을 가져야한다.

![연락처 정보를 포함하는 고객 모델](./%EC%97%B0%EB%9D%BD%EC%B2%98%EC%A0%95%EB%B3%B4%EB%A5%BC%ED%8F%AC%ED%95%A8%ED%95%98%EB%8A%94%EA%B3%A0%EA%B0%9D%EB%AA%A8%EB%8D%B8.png)

제 1정규형은 하나의 속성에는 하나의 값을 가져야 하는 것이다. 연락처 속성에 다중 값이 들어가는 경우를 생각해보자

![고객연락처데이터](./%EA%B3%A0%EA%B0%9D%EC%97%B0%EB%9D%BD%EC%B2%98%EB%8D%B0%EC%9D%B4%ED%84%B0.png)

위와 같은 데이터가 생성되면 다음과 같은 문제가 발생할 수 있다.

- A 고객은 집전화가 여러 대고, B 고객은 핸드폰이 여러 대라면 혼재된 속성에서 원하는 속성값을 추출하기 어렵다

- 명확하지 않은 속성은 이메일처럼 다른 유형의 데이터를 포함할 수도 있어 본연의 의미가 퇴색될 수 있다.

이와 같은 데이터 관리는 개발의 복잡성을 증가 시키고 연락처 속성의 의미를 퇴색시킨다.

![고객연락처엔터티를추가한고객모델](./%EA%B3%A0%EA%B0%9D%EC%97%B0%EB%9D%BD%EC%B2%98%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EA%B3%A0%EA%B0%9D%EB%AA%A8%EB%8D%B8.png)

위 모델을 보면 고객연락처라는 엔터티를 추가하여 다중 값에 대한 문제를 해결했다.
본 모델의 데이터를 표현하면 다음과 같다.

![고객과고객연락처데이터](./%EA%B3%A0%EA%B0%9D%EA%B3%BD%EA%B3%A0%EA%B0%9D%EC%97%B0%EB%9D%BD%EC%B2%98%EB%8D%B0%EC%9D%B4%ED%84%B0.png)

고객의 연락처가 많아져도 아무런 문제가 되지않는다. 집전화 번호 또는 핸드폰 번호를 구분하고 싶다면, 고객연락처 엔터티에 '연락처구분코드' 속성을 추가하면 된다. '연락처구분코드' 속성을 추가한다면, 이메일 등의 연락처 정보도 수용가능하다.

다중 값을 제거함으로서 속성을 더 명확하게 활용할 수 있다.

다중 값 말고도 다른 유형의 중복 데이터도 존재할 수 있다. 중복 데이터를 속성으로 분리한 경우이다.

![반복되는속성을가진모델](./%EB%B0%98%EB%B3%B5%EB%90%98%EB%8A%94%EC%86%8D%EC%84%B1%EC%9D%84%EA%B0%80%EC%A7%84%EB%AA%A8%EB%8D%B8.png)

위의 모델은 다음과 같은 문제점을 갖는다

- 상품을 3개 이상 주문할 수 없다.
- 상품1, 상품2를 모두 빠르게 조회하고 싶다면 속성마다 인덱스를 추가해야한다.

만일 3개 이상의 상품을 주문하고 싶다면 위의 모델에 '상품번호3, 상품명3, ... 상품번호N, 상품명N' 속성을 매번 추가해야한다. 속성을 추가한다는 것은 테이블의 칼럼을 추가하는 것으로 테이블 Lock을 발생시키고, 환경에 따라 사이트 중지가 필요한 작업이다.
또한 상품명1, 상품명2를 빠르게 조회하기 위해서는 상품번호 1, 상품번호2 속성 모두에 인덱스를 추가해야한다. 인덱스를 추가하는 것은 조회 속도는 빨라질 수 있으나, 입력, 수정, 삭제 속도는 느려진다.

![주문상세엔터티를추가한모델](./%EC%A3%BC%EB%AC%B8%EC%8C%8D%EC%84%B8%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EB%AA%A8%EB%8D%B8.png)

위 모델과 같이 주문상세 엔터티를 추가하면 된다. 상품을 몇개 주문하던 아무런 제약을 받지않게된다. 또한 추가적인 인덱스도 필요없다.

---

# 제2정규형

## 엔터티의 일반속성은 주식별자 전체에 종속적이어야한다.

![주문상세엔터티를추가한모델](./%EC%A3%BC%EB%AC%B8%EC%8C%8D%EC%84%B8%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EB%AA%A8%EB%8D%B8.png)

위 모델의 주문상세 엔터티의 상품명속성은 주식별자가아닌 오직 상품번호에 대해서만 반복되어 쌓이는 구조이다.

![주문상세데이터](./%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%EB%8D%B0%EC%9D%B4%ED%84%B0.png)

'SQL 전문가 가이드' 라는 데이터가 반복된다. 위의 표에서 중복되는 데이터는 상품명 이외에 상품번호도 존재한다. 하지만 상품번호는 고객이 상품을 주문함으로써 발생하는 매핑 정보로서 의미를 가지고 있다. 상품번호는 주문번호와 함께 주문상세 엔터티의 식별자 의미를 가지고 있기에 중복된 데이터라고 볼 수 없다. 하지만 상품명은 주문번호와 관계없이 오직 상품번호에 의해서만 결정된다. 즉 상품명은 상품번호에 종속적이다.

정리하면 상품명은 주문상세의 식별자인 '주문번호 + 상품번호' 가 아닌 오직 상품번호에만 종속적이다.

함수종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭한다. 기준값을 결정자라 하고, 종속되는 값을 종속자라고 한다. 상품명은 상품번호에 종속되어 있기에 종속자이며 상품번호는 상품명을 결정하기에 결정자이다.

주문상세 엔터티의 상품명은 식별자 전체가 아닌 일부에만 종속적이다. 이를 부분 종속이라 한다.
'엔터티의 일반속성은 주식별자 전체에 종속적이어야 한다' 는 제 2정규형을 위배한 것이다.

이러한 데이터는 다음과 같은 문제점을 갖는다.

- 상품명이 변경되고 업무적으로 반영해주어야 한다면, 주문상세의 중복된 상품명을 모두 변경해야 한다. 이때 많이 팔린 상품일수록 주문상세에서 변경해야할 상품명도 많다.

- 주문 상세의 상품명을 변경한다고 해도 특정 시점에서 아직 변경되지 않는 상품명이 존재하고, 이때 들어온 트랜잭션은 일관되지 않은 데이터를 조회한다.

결국 데이터 중복은 성능과 정합성에 문제를 발생시킨다.

![상품 엔터티를 추가한 모델](./%EC%83%81%ED%92%88%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EB%AA%A8%EB%8D%B8.png)

상품엔터티 추가를 통해 주문상세 엔터티의 부분 종속성을 제거할 수 있다. 상품명 속성을 상품 엔터티에서 관리하고 상품번호를 매핑키로 활용해 상품명을 확인하는 구조로 데이터를 일원화해 관리함으로써 위에 제시한 문제점을 해결할 수 있다.

이로써 '일반속성은 주식별자 전체에 종속해야 한다' 는 제2정규형을 만족하게 된다. 이를 데이터로 확인하면 다음과 같다.

![상품과주문상세데이터](./%EC%83%81%ED%92%88%EA%B3%BC%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%EB%8D%B0%EC%9D%B4%ED%84%B0.png)

---

# 제3정규형

## 엔터티의 일반속성 간에는 서로 종속적이지 않는다

![상품 엔터티를 추가한 모델](./%EC%83%81%ED%92%88%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EB%AA%A8%EB%8D%B8.png)

위 모델의 엔터티를 살펴보면 고객번호는 주문번호에 종속적이고, 고객명은 고객번호에 종속적이다.
이는 '고객명이 주문번호에 종속적'임을 의미한다. 이를 '이행적 종속' 이라하고 이행적 종속을 배제하는 것을 '제 3 정규형' 이라고 한다.

고객번호와 고객명 모두 주문번호에 종속하여 제 2정규형은 만족했지만, 고객명이 식별자가 아닌 일반속성에 종속적인 제3정규형 위배에 해당한다.

- 만일 고객이 이름을 바꿔 고객명이 변경되었으면 주문 엔터티의 고객명을 전부 갱신해야한다. 이는 주문과는 관련이 없는 트랜잭션이다.

- 데이터 중복으로 인해 발생하는 문제는 성능부하 및 정합성 오류이다.

고객명이 변경되어 발생하는 트랜젝션을 주문 엔터티가 받을 이유는 없다. 고객명이 자주 바뀌지 않는 경우라면 고객 별명은 똑같이 주문번호에 종속적이고 하루에 수십번씩 변경될 수 있다.

![고객 엔터티를 추가한 모델](./%EA%B3%A0%EA%B0%9D%EC%97%94%ED%84%B0%ED%8B%B0%EB%A5%BC%EC%B6%94%EA%B0%80%ED%95%9C%EB%AA%A8%EB%8D%B8.png)

위의 모델은 고객 엔터티를 분리하여 고객 속성 변경이 주문 엔터티에 영향을 주지 않는 구조다. 데이터 중복에 대한 문제도 개선되었다고 볼 수 있다.
주문엔터티에 고객 정보가 때때로 있는 이유는 비회원도 주문이 가능한 구조이기 때문이다.

엔터티를 분리해야하는 명확한 기준을 알고 있으면, 더 쉽게 데이터 모델링 할 수 있다. 개인의 경험에 기반한 직감적 모델링이 아닌, 근거가 명확한 기중네 의한 모델링은 더 나은 데이터 설계를 가능하게 해준다.

정규화는 필수적이지만 무조건적이지 않다. 상황에 따라 반정규화를 진행할 수도 있다. 중요한 것은 기본적으로 정규화를 진행하고 반정규화를 고려해야한다.

---

# 반정규화와 성능

반정규화는 정규화를 반대로 하는 것으로 역정규화라고도 한단. 정규화가 데이터의 중복을 최소화했다면, 반정규화는 성능을 위해 데이터의 중복을 허용하는 것 이다.

반정규화는 조회 성능을 향상시킬 수 있지만 그로인해 입력, 수정, 삭제 성능은 저하될 수 있다.

## 반정규화를 통해 성능이 향상될 수 있는 경우

주문 엔터티에서 주문상태 코드는 주문 상태에 대한 코드값으로 '주문, 취소, 반품, 교환' 등의 정보를 관리하고, 결제일시 속성은 실제 결제를 진행한 일시정보를 관리한다. 결제 엔터티에서 결제수단구분코드 속성은 '카드결제, 계좌이체, 핸드폰결제' 등을 관리하는 코드 값이다.
결제수단번호 속성은 결제수단구분코드에서 사용한 실제 '카드번호, 계좌번호, 핸드폰번호' 등을 관리하는 속성이다.

![정규화모델성능저하](./%EC%A0%95%EA%B7%9C%ED%99%94%EB%AA%A8%EB%8D%B8%EC%84%B1%EB%8A%A5%EC%A0%80%ED%95%98.png)

위의 모델에서 다음과 같은 요건을 생각해보자. 고객 편의를 위해 주문서 작성 시 최근 결제 정보를 미리 세팅하여보여주려 한단. 실제 쇼핑몰에 들어가 보면, 최근 사용한 결제 정보가 자동으로 세팅되는 곳이 많다. 이는 고객 경험을 위함이다. 최근 신용카드 정보를 미리 세팅하는 요건일 경우 다음과 같은 SQL을 작성하게 된다.

```sql
  SELECT A.결제수단번호
  FROM (
    SELECT B.결제수단번호
    FROM 주문 A, 결제 B
    WHERE A.주문번호 = B.주문번호
    AND A.고객번호 = '1234'
    AND B.결제수단구분코드 = '신용카드'
    ORDER BY B.결제일시 DESC
  ) A
  WHERE ROWNUM = 1;
```

고객번호가 1234인 고객의 주문정보를 결제 테이블과 조인해 가져온 후 , 신용카드 결제 정보를 결제일시로 내림차순 정렬해 최근 1건의 결제수단번호를 가져오는 SQL이다. 어떤 성능상의 문제가 있을까?

1234 고객의 주문 내역이 많을수록 성능이 나빠진다. 최종 결과는 1건을 가져오지만, 주문내역이 많을 수록 해당 주문과 결제 테이블 사이의 조인 건수가 증가한다.

결제 엔터티에 고객번호 속성을 반정규화함으로써 조인에 대한 성능 부하를 개선할 수 있다.

![반정규화모델성능개선](./%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94%EB%AA%A8%EB%8D%B8%EC%84%B1%EB%8A%A5%EA%B0%9C%EC%84%A0.png)

다음과 같이 SQL을 수정할 수 있다.

```sql
SELECT A.결제수단번호
FROM (
  SELECT A.결제수단번호
  FROM 결제 A
  WHERE A.고객번호 = 1234
  AND A.결제수단구분코드 = '신용카드'
  ORDER BY B.결제일시 DESC
) A
WHERE ROWNUM = 1;
```

결제 테이블에 '고객번호+결제수단구분코드+결제일시'로 인덱스를 생성하고 'Index Range Scan Descending' 으로 최종 1건의 데이터만 읽어 결제수단번호를 가져올 수 있다.

이처럼 정규화가 항상 정답인 것만은 아니다. 요건에 따라 반정규화를 진행할 수도 있다. 하지만 반정규화를 남용하면 더 큰 문제를 야기할 수 있다.

## 반정규화를 적용한 모델에서 성능이 저하되는 경우

조인을 하면 성능이 느려진다. 한 개의 테이블을 읽어서 데이터를 가져오는 것이 두 개의 테이블을 조인하여 데이터를 가져오는 것보다 조금 빠르므로 이런 관점에서는 일리가 있다.

![정규화한 주문과 배송 모델](./%EC%A0%95%EA%B7%9C%ED%99%94%ED%95%9C%EC%A3%BC%EB%AC%B8%EA%B3%BC%EB%B0%B0%EC%86%A1%EB%AA%A8%EB%8D%B8.png)

고객이 주문하면 판매자가 배송한다. 대부분의 쇼핑몰은 고객이 주문한 주문내역에 대해 배송정보를 조회할 수 있는 기능을 갖추고 있다. 즉 현재 내가 주문한 상품이 어디쯤 배송되었는지를 조회할 수 있는 화면이다.
이런 화면을 구현하기 위해선 고객이 주문한 주문정보가 필요하고, 주문한 상품의 송장번호가 필요하다. 송장번호는 판매자가 고객의 상품을 배송하기 위해 택배사로부터 전단받은 번호이다.
주문정보는 주문 엔터티에서 가져올 수 있고, 송장번호는 배송 엔터티에서 가져올 수 있다. 즉 주문과 배송 엔터티를 함께 조인해야한다. 하지만 성능을 위해 주문 엔터티에 송장번호를 반정규화했다.

![반정규화한 주문 모델](./%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94%ED%95%9C%EC%A3%BC%EB%AC%B8%EB%AA%A8%EB%8D%B8.png)

반정규화하면 배송 엔터티와 조인하지 않아도 된다. 조인을 제거했기 때문에 빠른 성능을 확보할 수 있다.

하지만 장점만 존재하는 것은 아니다. 고객이 주문하는 시점에 바로 송장번호가 생성되지않는다. 즉, 주문과 동시에 송장번호를 알 수 없다. 주문 시점에 주문 모델의 송장번호 속성에는 NULL이 들어가며 배송준비가 완료되어야 송장번호를 갱신할 수 있다.

반정규화 이전에 없었던 갱신(UPDATE) 프로세스가 추가 됐다. 그럼 이런 고민이 필요하다. 조회의 성능을 확보하기위해 불필요한 갱신 프로세스가 필요할까?

정규화 모델에 적절한 인덱스가 구성되었다고 하면 반정규화가 주는 이익은 미미하다. 이런 경우 추가 갱신로직이 더 큰 성능저하를 불러온다.

반정규화는 그럼에도 진행해야한다는 판단의 근거가 명확할때 비로소 진행한다.
