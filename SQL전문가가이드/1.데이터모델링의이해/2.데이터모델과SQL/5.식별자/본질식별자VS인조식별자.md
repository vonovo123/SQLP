개발 편의성을 위해 종종 발생하는 문제점 중 하나인 인조식별자의 남용에 대해 알아보자. 인조 식별자를 남용하면 개발 편의성은 증대되지만 이에 따른 부작용을 야기한다.

엔터티는 반드시 데이터를 식별할 수 있는 속성이 존재한다. 이를 식별자라고 한다. 식별자는 대체 여부에 따라 본질식별자와 인조식별자로 분류할 수 있다.

- 본질식별자 : 업무에 의해 만들어진 식별자
- 인조식별자 : 업무적으로 만들어지지는 않지만 본질식별자가 복잡한 구성을 갖고 있으므로 인위적으로 만든 식별자

![주문과 주문상품 모델 본질식별자](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%20%EC%A3%BC%EB%AC%B8%EC%83%81%ED%92%88%20%EB%AA%A8%EB%8D%B8%20%EB%B3%B8%EC%A7%88%EC%8B%9D%EB%B3%84%EC%9E%90.png)

주문상품 모델의 식별자가 본질식별자이다. 주문상품 모델은 주문 시 구매한 상품 정보를 관리한다.

![주문상품](./%EC%A3%BC%EB%AC%B8%EC%83%81%ED%92%88.png)

하나의 주문에 3개의 상품을 구매한 것을 데이터로 표현한 것이다. 이러한 데이터로 개발을 진행하여 주문상품 모델에 값을 INSERT 하는 경우를 생각해보자.

```sql
INSERT INTO 주문상품 VALUES(110001, 1234, 1);
INSERT INTO 주문상품 VALUES(110002, 1566, 5);
INSERT INTO 주문상품 VALUES(110003, 234, 2);
```

![주문과 주문상품 모델 인조식별자](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%20%EC%A3%BC%EB%AC%B8%EC%83%81%ED%92%88%20%EB%AA%A8%EB%8D%B8%20%EC%9D%B8%EC%A1%B0%EC%8B%9D%EB%B3%84%EC%9E%90.png)

위의 모델은 주문상품번호라는 새로운 식별자를 생성하였다. 이 식별자를 외부식별자라 한다. 이와 같은 모델의 Insert 문은 다음과 같다.

```sql
INSERT INTO 주문상품 VALUES(주문상품번호.SEQ.NETXVAL, 110001, 1234, 1);
INSERT INTO 주문상품 VALUES(주문상품번호.SEQ.NETXVAL, 110002, 1566, 5);
INSERT INTO 주문상품 VALUES(주문상품번호.SEQ.NETXVAL, 110003, 234, 2);
```

위 모델은 본질식별자를 사용한 모델에 비해 전혀 좋은점이 없다. 오히려 시퀀스를 생성할 뿐이다.

![주문과 주문상품 모델 본질식별자](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%EB%AA%A8%EB%8D%B8%EB%B3%B8%EC%A7%88%EC%8B%9D%EB%B3%84%EC%9E%902.png)

하나의 주문에 동일 상품믈 중복으로 구매하려는 경우 본질식별자를 사용한 주문상품 모델에서 불가능하다. 상품번호가 중복되기 때문이다. 위의 주문상세 모델은 상품번호를 식별자로 구성하지 않고 하나의 주문에 발생하는 상품의 Count를 주문순번이라는 속성으로 식별자를 구성한다.

![본질식별자 주문상세](./%EB%B3%B8%EC%A7%88%EC%8B%9D%EB%B3%84%EC%9E%90%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8.png)

동일상품을 하나의 주문에서 처리하고 있다. 즉 쇼핑몰에서 동일한 상품을 각가 자른 배송지에 보내고싶은 요건을 나타낸 것이다.

아래와 같은 SQL로 표현될 것이다.

```sql
INSERT INTO 주문상품 VALUES(110001, 1, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(110001, 2, 1234, '제주감귤1box', '부모님집')
INSERT INTO 주문상품 VALUES(110001, 3, 1234, '제주감귤1box', '친구집')
```

이전 모델과 다른 점은 주문 순번 값을 위해 하나의 주문에 구매하는 상품의 count를 계산해서 입력해야한다. 어려운 작업은 아니더라도 번거로운 작업임은 분명하다.

![주문과 주문상세 모델 인조식별자](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%EB%AA%A8%EB%8D%B8%EC%9D%B8%EC%A1%B0%EC%8B%9D%EB%B3%84%EC%9E%902.png)

식별자를 주문상세번호로 정의했다. 이전 모델과 차이점은 식별자를 하나의 속성으로 구성한 외부식별자로 생성했다. 주문순번 속성이 사라졌지만 대신 주문상세번호가 생상되어 큰 차이는 없어보이지만 실제 개발 시 편의성이 향상되는 방식이다.
어떤 부분에서 편의성이 향상되었는지 확인해보자.

해당값을 구하는 방식을 비교해보면 주문순번은 하나의 주문번호에 대해 구매가 일어나는 상품의 Count를 구하는 것이므로 시퀀스 객체를 활용할 수 없어 따로 작업을 해줘야 한다. 하지만 주문 상세번호는 단일식별자로 구성된 키 값이기 때문에 시퀀스 객체로 해결가능하다. 시퀀스 객체만 활용한다면 따로 작업해줄 필요가 없다.

```sql
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 1, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 2, 1234, '제주감귤1box', '부모님집')
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 3, 1234, '제주감귤1box', '친구집')
```

주문상세번호SEQ 라는 시퀀스 객체를 만들고 NEXTVAL을 활용하면 기본키에 대한 부분은 더이상 신경쓰지 않아도 된다. 만일 이러한 방식에 대한 문제점이 없다면 편하게 개발할 수 있는 방식으로 채택하는 것이 당연하다. 하지만 위 방식은 문제점이 있다. 외부식별자를 사용하는 방식에는 크게 두 가지 문제점이 있다.

- 중복 데이터로 인한 품질 저하
- 불필요한 인덱스 생성

# 중복 데이터로 인한 품질 문제

외부식별자를 사용하면 중복 데이터를 막을 수 없다. 기본키 제약활용한다면 중복 데이터를 원천 차단할 수 있지만, 기본키를 인위적으로 생성한 속성으로 정의하였기 때문에 불가하다.

```sql
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 1234, '제주감귤1box', '부모님집')
INSERT INTO 주문상품 VALUES(주문상세번호SEQ.NEXTVAL, 110001, 1234, '제주감귤1box', '친구집')
```

주문상세번호는 시퀀스 객체로인해 중복되지 않으므로 나머지 속성값이 모두 같더라도 중복 데이터로 인식되지 않는다. 실제 데이터는 다음과 같다.

![인조식별자주문상세](./%EC%9D%B8%EC%A1%B0%EC%8B%9D%EB%B3%84%EC%9E%90%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8.png)

중복으로 발생된 데이터임에도 저장된 것을 볼 수 있다. 왜냐면 주문상세번호에 기본키 제약이 적용되어 있고, 주문상세번호는 시퀀스를 사용하였기에 제약에 위배된 사항이 없다.
그렇다면 본질식별자를 사용한 경우는 어떨까?

```sql
INSERT INTO 주문상품 VALUES(110001, 1, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(110001, 1, 1234, '제주감귤1box', '우리집')
INSERT INTO 주문상품 VALUES(110001, 2, 1234, '제주감귤1box', '부모님집')
INSERT INTO 주문상품 VALUES(110001, 3, 1234, '제주감귤1box', '친구집')
```

두 번째 Insert 문을 보면 로직 오류에 의해 동일한 INSERT가 발생했다. 이때 '주문번호 + 주문순번' 즉 본질식별자를 사용한 경우 기본키 제약조건에 의해 에러가 발생한다.
그러므로 최대한 본질식별자의 사용을 지향해야한다. 외부식별자를 사용하였다면 DBMS에서는 해당 경우를 막아줄 수 없기 때문에 애플리케이션에서 이를 방어해줘야한다.

# 불필요한 인덱스 생성

본질식별자와 인조식별자를 사용했을 때 인덱스 구성에 대해 어떤 차이가 있는지 알아보자.

![주문과 주문상세 모델 인조식별자](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%20%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%20%EB%AA%A8%EB%8D%B8%20%EC%9D%B8%EC%A1%B0%EC%8B%9D%EB%B3%84%EC%9E%90.png)

주문상품 모델 데이터에 액세스한다고 가정해보자. 여러 가지 액세스 패턴이 있겠지만, 가장 기보적인 액세스 패턴은 다음과 같을 것이다.

```sql
SELECT *
FROM 주문상품
WHERE 주문번호 = :B1;

SELECT *
FROM 주문상품
WHERE 주문번호 = :B1
AND 상품번호 = :B2;
```

가장 기본적이면서 일반적인 엑세스 패턴이댜. 이러한 SQL에 대해 본질식별자로 구성하면 PK 인덱스를 활용할 수 있겠지만, 인조식별자로 구성한다면 IX1과 같은 인덱스를 추가로 생성해주어야한다.
즉, 인조식별자를 사용하면 불필요한 인덱스를 추가로 생성해야 하는 점을 기억해야한다. 추가인덱스는 용량과 DML 성능에 영향을 줄 수 있음을 염두해야한다.
식별자의 속성이 너무 많아지는 경우 본질식별자와 인조식별자의 장단점을 따져보고 사용해야한다. 인조식별자의 남용을 피하고 꼭 필요한 경우에만 사용하는 것이 바람직하다.
