트랜잭션의 데이터베이스의 논리적 연산단위이다.
계좌이체가 대표적인 예이다. 돈을 보내는 사람의 계좌에서 이체 금액을 차감하고, 돈을 받는 사람의 계좌 이체금액을 가산한다, 데이터 적합성을 위해 위 작업은 전부 실행되든지 아니면 전부 취소되든지 해야한다.
즉 하나의 업무 단위로 묶여 처리되어야하고 이런 업무 단위를 트랙잭션이라고 한다.

모델링 진행 시에도 트랜잭션을 표현할 수 있다.

![주문과 주문상세 모델 필수 관계](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%EB%AA%A8%EB%8D%B8%ED%95%84%EC%88%98%EA%B4%80%EA%B3%84.png)

고객이 상품을 구매하면 발생하는 것이 주문이다. 또한 하나으이 주문은 여러 개의 상품을 구매할 수 있다. 위 모델은 이에 대한 모델링이다. 주문과 주문 상세의 데이터는 함께 발생되는지, 아니면 독립적으로 발생되는지 생각해봐야한다. 위의 모델에 의하면 주문이 볼생하면 주문 상세 데이터도 함께 발생한다는 의미이다.

![주문과 주문상세 모델 선택 관계](./%EC%A3%BC%EB%AC%B8%EA%B3%BC%20%EC%A3%BC%EB%AC%B8%EC%83%81%EC%84%B8%20%EB%AA%A8%EB%8D%B8%20%EC%84%A0%ED%83%9D%EA%B4%80%EA%B3%84.png)

위의 모델은 주문과 주문상세 모델의 관계가 선택적임을 표현하고 있다.
이는 주문에 대한 주문상세 데이터가 없을 수도 있다는 것이다. 일반적으로 주문만하고 상품을 구매하지 않을 수 없다. 이처럼 관계선택사양은 매우 중요한 정보를 보여주고 있다.
일반적인 쇼핑몰 모델에서 주문과 주문상세는 주문과 주문상세 모델 필수 관계를 갖는다. 주문과 주문상세의 데이터가 태생적으로 동시에 발생된다면, 당연히 계좌이체의 경우처럼 하나의 트랜잭션으로 묶어서 처리해야 한다.

트랜잭션을 하나로 묶는다는 것은 All or Nothing 원자성이 보장되도록 개발을 해야 한다는 의미이다. 커밋(Commit)의 단위를 하나로 묶어야 함을 의미한다. 그래야 전체가 샐행되거나 전체가 취소될 수 있다.

```
// A -> B 계좌이체
계좌이체API {
  잔고수정(고객번호 => A, 수정값 => 현재잔고-이체금액),
  잔고수정(고객번호 => B, 수정값 => 현재잔고 + 이체금액);
  commit();
}
```

위 의사코드는 A 고객이 B 고객에게 계좌이체 하는 것을 표현한 것이다. 잔고를 차감하고 가산하는 단계가 모두 완료된 후에 커밋을 수행하는 것이다.
재사용성이라는 이유로 또는 API 개발 패턴으로 인해 모든 트랜잭션의 SQL을 낱개로 뜯어내선 안된다. 주문과 주문 상세 모델은 애초에 서로 독립적인 데이터가 발생할 수 없다.
그렇기에 주문 INSERT와 주문상세 INSERT는 따로 개발되어서는 안된다.

```
// 고객의 주문 발생
1. 주문API {
  주문입력(주문번호 => 110001, 고객명=>A, ...);
  commit();
}

2. 주문상세API {
  주문상세입력(주문번호 => 110001, 상품번호=>1234, ...);
  commit();
}
```

위의 수도코드를 진행하던중 예상치못한 장애의 발생으로 두 API가 수행되지못한경우 잘못된 데이터가 발생할 수 있다.
모델에서 표현하는 트랜잭션은 어차피 따로 수행될 일 자체가 없으므로 재사용성의 이점또한 없다. 반드시 하나의 트랜잭션으로 처리되어야한다.

```
// 고객의 주문 발생
1. 주문API {
  주문입력(주문번호 => 110001, 고객명=>A, ...);
  주문상세입력(주문번호 => 110001, 상품번호=>1234, ...);
  commit();
}
```

여기서 중요한 것은 업무적 트랜잭션보다 모델이 표현하는 트랜잭션의 태생 자체가 함께 발생하는 데이터이기 때문에 재사용의 이점도 없으므로 반드시 하나의 트랜잭션으로 처리해야한다.
잘못된 트랜잭션 처리는 데이터 정합성 문제를 야기하고 데이터 품질에도 큰 영향을 미친다.
