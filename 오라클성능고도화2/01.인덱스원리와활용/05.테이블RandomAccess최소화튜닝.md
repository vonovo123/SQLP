### 인덱스 컬럼 추가

인덱스 구성을 바꾸기 보다 기존 인덱스에 조건절 컬럼을 추가해주는 것만으로도 콘 효과가 있다.

인덱스 스캔량은 줄지 않지만 테이블 랜덤 엑세스 횟수가 줄어들기 때문이다.

테이블 엑세스 수에 비해 실제결과집합이 과도하게 적다면 조건절 컬럼을 기존 인덱스에 추가하는 방법을 고려해볼 수 있다.

### PK 인덱스에 컬럼 추가

단일 테이블을 PK로 액세스할 때는 단 한 건만 조회하는 것이므로 테이블 RANDOM ACCESS 부하는 없다.

NL 조인시, OUTER 테이블에서 Inner 테이블 쪽으로 조인 액세스가 많은 상황에서 Inner 쪽 필터 조건에 의해 버려지는 레코드가 많다면 비효율이 크다.

```sql
select /*+ordered use_nl(d)*/ *
from emp e, dept d
where d.deptno = e.deptno
and d.loc = 'NEW YORK'
-- 3 NESTED LOOPS
-- 14 TABLE ACCESS FULL EMP
-- 3  TABLE ACCESS BY INDEX ROWID DEPT
-- 14   INDEX UNIQUE SCAN DEPT_PK
```

emp를 기준으로 deptno에 nl 조인하고, 조인에 성공한 14건 중 loc = 'NEW YORK'인 레코드만 취하므로 최종 결과집합은 3건이다.

dept_pk 인덱스에 loc 컬럼을 추가하면 불필요한 11번의 RANDOM ACCESS를 줄일 수 있지만 PK 인덱스에는 컬럼을 추가할 수 없다.

그러다보니 PK 컬럼 + 필터조건 컬럼 형태의 새로운 Non-Unique 인덱스를 추가하는 경우가 있다. 그럴 때 Non-Unique 인덱스를 이용해 PK 재약을 설정하면 인덱스 개수를 줄일 수 있다.

PK 제약에는 중복 값 확인을 위한 인덱스가 반드시 필요하다. 인덱스가 없다면 값이 입력될 때마다 테이블 전체를 읽어 중복을 확인해야 하기 때문이다. 하지만 중복 체크를 위해 Non-unique 인덱스를 사용할 수 있다.

```sql
alter table dept drop primary key;

create index dept_x01 on dept(deptno, loc);

alter table dept add
constraint dept_pk primary key(deptno) using inex dept_x01
```

PK 제약을 위해 사용되는 인데스는 PK 제약 순서와 서로 일치하지 않아도 된다. 중복 값 유무를 체크하는 용도로 PK 제약 컬럼들이 선두에 있기만하면 된다.

PK 제약 컬럼이 고객번호, 상품번호, 거래일자 순이라면 고객번호 + 상품번호 + 거래구분 + 거래일자 순의 인덱스는 PK 제약을 위한 인덱스로 사용할 수 없다. 가운데 거래구분이 껴있기때문이다.

### 컬럼 추가에 따른 클러스터링 팩터 변화

인덱스에 컬럼을 추가하는 것은 클러스터링 팩터가 나빠지는 부작용을 초래할 수 있다.

클러스터링 팩터가 좋으면 읽어오는 레코드 수에 비해 블록 I/O가 적게 발생한다.

변별력이 좋지 않은 컬럼 뒤에 변별력이 좋은 다른 컬럼을 추가할때는 클러스터링 팩터 변화에 주의를 기울여야 한다.

### 인덱스만 읽고 처리

테이블을 액세스하고서 필터 조건에 의해 버려지는 레코드가 많으면 비효율적이다. 그런데 테이블 RANDOM 엑세스가 아무리 많더라도 핕터 조건에 의해 버려지는 레코드가 없으면 비효율은 없다.

이때는 아예 테이블 액세스가 발생하지 않도록 모든 필요한 컬럼을 인덱스에 포함시키는 방안을 고려해 볼 수 있다.

### 버퍼 Pinning 효과 활용

오라클의 경우, 한 번 입력된 테이블 레코드는 절대 rowid가 바뀌지 않는다. 따라서 해당 레코드가 지워지지 않는 이상 미리 알고 있던 테이블 rowid 값을 이용해 레코드를 조회하는 것이 가능하다.

미리 알고 있던 rowid 값이 아니더라도 인라인 뷰에서 읽은 rowid 값을 이용해 테이블을 액세스하는 것도 가능하다.

```sql
select /*+ordered use_nl(b) rowid(b)*/
*
from (
  select /*+index(emp emp_pk) no_merge*/
  rowid rid
  from emp
  order by rowid
) a, emp b
where b.rowid = a.rid
```

emp_pk 인덱스 전체를 스캔해 얻은 레코드를 rowid 순으로 정렬한 다음 한 건씩 순차적으로 emp 테이블 액세스 한다.

이때 중간집합의 CF는 가장 완벽하게 좋은 상태가 된다.

위와 같은 쿼리에 버퍼 Pinning이 발생한다면 한 번 액세스로 블록 안에 있는 모든 레코드를 다 읽어들이는 셈이 된다.

pinning 효과가 나타나기만 하면 아무리 많은 테이블 레코드를 액세스하더라도 Random Access에 의한 비효율은 존재하지 않는다.

### 수동으로 클러스터링 팩터 높이기

테이블에 데이터는 무작위로 입력되는 반면, 인덱스는 정해진 키 순서로 정렬되기 때문에 CF가 좋지 않다. CF가 나쁜 인덱스를 이용해 많은 양의 데이터를 읽을 때 튜닝이 가장 어렵다.

그럴 때, 해당 인덱스를 기준으로 테이블을 재생성함으로써 CF를 인위적으로 좋게 만들 수 있다.

주의할 것은, 테이블의 인덱스가 여러개라면 특정 인덱스를 기준으로 테이블을 재정렬 한 후 다른 인덱스의 CF가 낮아질 수 있다.

재졍렬 기준 인덱스와 다른 인덱스 간의 상관관계가 높다면 둘다 좋아질 수 있지만 낮으면 CF가 좋은 인덱스는 테이블당 하나 뿐이다.

따라서 인위적으로 CF를 높일 목적으로 테이블을 재구성할 때 가장 자주 사용되는 인덱스를 기준으로 삼고 영향도를 체크해야한다.
