Sequential Access는 레코드간 논리적 또는 물리적 순서를 차례로 읽어 나가는 방식을 말하고, Random Access는 액세스 레코드간 논리적, 물리적 순서를 따르지 않고 한 건을 읽기 위해 한 블록씩 접근하는 방식이다.

I/O 튜닝의 핵심 원리는 아래와 같다.

1. Sequential 엑세스의 선택도를 높인다.
2. Random Access 발생량을 줄인다.

Random Access를 줄이기 위해선 부하 원리와 해소 원리에 대해 알아야 한다.

테이블을 액세스하기 전, 인덱스를 Sequential 방식으로 스캔하는 단계에서 발생하는 비효율을 해소하면 Sequential Access의 선택도를 높일 수 있다.

#### Sequential Access 선택도

일반적인 의미에서의 선택도는 전체 레코드 중 조건절에 의해 선택되는 비율을 말한다.

전체 레코드 중 조건절에 의해 선택되는 비율이 높으면 일반적으로 Table Random Access 량이 많아진다.
Sequential Access 선택도는 인덱스를 스캔한 건수 중 결과로 선택되는 비율을 말하며, 그 비율이 높아야 효율적이라는 의미는 결과 건수를 내기 위해 적은 양을 읽어야 함을 말한다.

### 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드 군집성

테이블과 달리 인덱스 레코드는 동일 값의 레코드들은 항상 군집해 있다. 그런데 같은 값을 갖는다고 하면 = 비교가 전제되므로, 만약 비교 연산자가 = 조건이 아닌경우 인덱스 레코드도 서로 흩어질 수 있다.

선행컬럼이 모두 = 조건인 상태에서 첫 번째 나타나는 범위 검색 조건까지만 만족하는 인덱스 레코드는 모두 연속하지만, 그 이하 조건까지 만족하는 레코드는 연산자의 종류에 상관없이 흩어진다.

맨 선두 컬럼이 범위검색 조건이면 그 조건을 만족하는 레코드만 모여있고 나머지는 모두 흩어진다.

### 인덱스 선행 컬럼이 등치 조건이 아닐 때 발생하는 비효율

SEQUENTIAL ACCESS 효율은 선택도에 의해 결정된다. 같은 결과 건수를 내는데 얼마나 적은 레코드를 읽느냐로 효율성을 판단할 수 있다.

인덱스 Sequentail 엑세스에 따른 선택도는 인덱스 컬럼이 모두 등치 조건일때 가장 높다. 리프 블록을 스캔하면서 읽은 레코드는 하나도 필터링 되지 않고 모두 테이블 엑세스로 이어지기 때문이다.

따라서 인덱스 스캔 단계의 비효율은 없다.

인덱스 컬럼 중 일부가 조건절에서 생략되거나 = 조건이 아니더라도, 그것이 뒤쪽 컬럼일 경우 비효율이 없다.

반면, 인덱스 선행 컬럼의 조건절이 누락되거나 범위조건인 경우 인덱스 스캔 단계에서 비효율이 발생한다.

인덱스 선행 컬럼이 모두 = 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 이유는, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.

### BETWEEN 조건을 IN-List로 바꾸었을 때 인덱스 스캔 효율

RBO 모드에서는 인덱스 컬럼에 In-List 조건절을 사용하면 Concatenation 방식의 실행계획이 나타난다.

이는 쿼리가 내부적으로 union all 방식으로 실행됨을 의미한다.

```sql
-- SELECT STATEMENT
--  CONCATENATION
--    TABLE ACCESS BY INDEX ROWID
--      INDEX UNIQU SCAN
--    TABLE ACCESS BY INDEX ROWID
--       INDEX UNIQUE SCAN
```

IN-LIST 개수만큼 union all 브랜치가 생성되고, 각 브랜치마다 모든 컬럼을 = 조건으로 검색하기 때문에 앞서 선두 컬럼을 between 조건으로 비교할때의 비효율이 사라진다.

INDEX SKIP SCAN 방식으로 유도하는 것과 비슷한 효율을 얻을 수 있다.

IN-LIST 항목 개수가 늘거나 줄수 있다면 NL 방식의 조인문이나 서브쿼리로 구현할 수 있다. 물론 IN-LIST 값들을 코드 테이블로 관리하고 있어야한다.

```sql
  select
  from 통합코드 a, 매물아파트매매 b
  where a.코드구분 = ''
  and a.코드 between '1' and '2'
  and b.인터넷매물 = a.코드
  and b.아파트시세코드  = ''
  and b.평형 = ''
  and b.평형타입 = 'A'
  order by b.입력일 desc
```

#### between 조건을 IN-LIST 조건으로 바꿀때의 주의사항

인덱스 선두 컬럼의 between 조건을 IN-LIST 조건으로 바꿀 때 주의점은, IN-List 개수가 많지 않아야 한다는 것이다.

인덱스 수직 탐색이 여러 번 발생하기 때문이다. IN-LIST 개수가 많을 때는 between 조건 때문에 리프블록을 추가로 스캔하는 비율보다 IN-LIst 조건 때문에 브랜치 블록을

반복 탐색하는 비효율이 더 클 수 있다. 인덱스 높이가 높을 때 특히 그렇다.

인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.

Between 조건인 선행 컬럼 때문에 많은 인덱스 리프 블록을 스캔하지만 거기서 선택되는 레코드는 소랴잉어야 변환효과가 있다.

블록 I/O가 소량이라면 Between 조건이 낫다.

### INDEX SKIP SCAN을 이용한 비효율 해소

인덱스 선두 컬럼이 누락됐을 때뿐만 아니라 범위 조건일 때도 유용하게 사용할 수 있다.

```sql
-- 월별고객별판매집계_IDX2(판매월 + 판매구분)
select /*+INDEX_SS(t 월별고객별판매집계_IDX2)*/
from 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '200801' and '200812'
```

인덱스 선두 컬럼이 between 조건임에도 큰 비효율 없이 스캔을 마친다.

선두 컬럼이 between이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨여져 있을 때가 가장 효과가 좋다.

### 범위검색 조건을 남용할때 비효율

특정 필드를 사용하는 조건의 입력값이 필수가 아닐때 like 연사자를 많이 이용한다.

```sql
SELECT
FROM 가입상품
WHERE 회사 = :com
AND 지역 Like :reg || '%'
AND 상품명 LIKE :prod || '%'
```

like 조건으로 사용하는 필드에 인자값을 입력한 경우 해당 필드를 필수 조건으로 검색할 때보다 스캔범위가 더 늘어난다.

코딩편의를 위해 인덱스 컬럼에 범위 검색조건을 남용하면 첫 번째 범위검색 조건에 의해 스캔 범위가 대부분 결정되며, 그 다음ㅇ르 따르는 조건부터는 스캔 범위를 줄이는 데에 크게 기여하지 못하므로 성능이 불리해진다.

따라서 인덱스 컬럼에 대해 비교연산자를 신중하게 선택해야한다.

### 같은 컬럼에 두 개의 범위검색 조건 사용시 주의사항

```sql
select *
from (
  select rownum rnum, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from (
    select 도서번호, 도서명, 가격, 저자, 출판사, isbn
    from 도서
    where 도서명 like :book_nm || '%'
    order by 도서명
  )
  where rownum <= 100
)
where rnum >= 91 -- 10페이지만 출력
```

도서명 컬럼에 인덱스가 있다면 첫 번째 rownum 조건에 해당하는 레코드만 탐색하고 멈출 수 있다. count(stopkey) 오퍼레이션이 작용하기 때문이다.

뒤쪽 어느 페티지로 이동하더라도 빠르게 구현해야 한다면 암쪽 레코드를 스캔하지 않고 해당 페이지 레코드로 바로 찾아가도록 해야한다.

```sql
select *
from (
  --  이전 페이지에서 출력된 마지막 레코드와 이름이 같은 도서가 있을 수 있다.
  -- 그럴 때 현재 페이지에는 이전 페이지 마지막 레코드와 이름이 같으면서 rowid가 큰 도서부터 출력한다.
  -- 인덱스 키 값이 같을 때 row순으로 정렬되기 때문이다.
  select  /*+index(도서 도서명_idx)*/
  rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where 도서명 like :book_nm || '%'
  and 도서명 = :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
  and rowid > :last_rid -- 이전 페이지에서 출력된 마지막 도서의 rowid
  union all
  -- 이전 페티지 마지막 레코드와 이름이 같은 도서가 출력되고 나면
  -- 다른 이름의 도서를 출력한다. 사용자가 입력한 도서명 키워드는 like 조건절로 계속 포함시켜야한다.
  select  /*+index(도서 도서명_idx)*/
  rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where 도서명 like :book_nm || '%'
  and 도서명 >  :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
)
rownum <= 10
```

union all 아래 쿼리의 경우 도서명에 대한 범위검색 조건이 두 개 인데 그중 Like 조건을 인덱스 액세스 조건으로 사용했기 때문에 다수의 블록을 읽게 된다.

사용자가 입력한 도서를 처음부터 스켄하다가 :last_book_nm 보다 큰 9개 레코드를 찾고서야 멈추었고, 사용자가 뒤쪽 페이지로 많이 이동할 수록 비효율은 점점 커진다.

부등호 조건이 인덱스 엑세스 조건으로 사용되도록하면 이 문제는 해결된다. like 조건을 좌변 컬럼을 가공한다.

```sql
select  /*+index(도서 도서명_idx)*/
  rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where rtrim(도서명) like :book_nm || '%'
  and 도서명 >  :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
```

부등호 조건을 만족하는 첫 번째 레코드부터 스캔을 시작했으므로 인덱스에서 스캔한 블록 수가 단 2개로 줄었다.

#### OR-Expansion 을 이용하는 방법과 주의사항

use_concat을 사용하면 union all에 비해 코딩량을 줄일 수 있다.

or 조건에 대한 expansion이 일어나면 뒤쪽 조건절이 먼저 실행되는 특징을 이용한 것이다.

```sql
select /*+index(도서 도서명_idx) use_concat ordered_predicates*/
from 도서
where 도서명 like :book_nm || '%'
and ((도서명 > :last_book_nm) or (도서명 = :last_book_nm and rowid > :last_rid))
and rownum <= 10
```

주의할 점은 버전에 따라 실행순서가 달라진다는 점이다. 10g CPU 비용 모델에서는 계산된 카디널리티가 낮은 쪽을 먼저 실행ㅎ나다.
버전에 상관없이 뒤쪽에 있는 조건식이 먼저 처리되도록하려면 Ordered_predicates 힌트를 명시해야 ㅎ나다.

#### rowid를 concatenation 하면 결과에 오류 발생

```sql
select
from 도서
where 도서명 like :book_nm || '%'
and 도서명 >= :last_book_nm
and lpad(도서명, 50) || rowid > lpad(:last_book_nm, 50) || :last_rid
and rownum <= 10
```

도서명 >= :last_book_nm 조건에 의해 선택된 레코드 중 도서명이 같으면 rowid 값 비교에 의해 한 번 더 필터링이 이루어지게한다. 내부적으로 아래와 같이 동작ㅎ나다.

```sql
lpad(도서명, 50) || rowidtochar(rowid) > lpad(:last_book_rm, 50) || :last_rid
```

문자형으로 변환된 rowid는 rowid 값 그대로 비교할 때와 정렬순서가 다르다.

#### 인덱스를 스캔하면서 rowid를 필터링할 때 발생하는 비효율

```sql
  --  이전 페이지에서 출력된 마지막 레코드와 이름이 같은 도서가 있을 수 있다.
  -- 그럴 때 현재 페이지에는 이전 페이지 마지막 레코드와 이름이 같으면서 rowid가 큰 도서부터 출력한다.
  -- 인덱스 키 값이 같을 때 row순으로 정렬되기 때문이다.
  select  /*+index(도서 도서명_idx)*/
  rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where 도서명 like :book_nm || '%'
  and 도서명 = :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
  and rowid > :last_rid -- 이전 페이지에서 출력된 마지막 도서의 rowid
```

인덱스를 스캔하면서 rowid를 필터링할 때는 속도가 늦다.

rowid는 리프 블록에만 있기 때문에 이를 필터링하려면 일단 다른 액세스 조건만으로 리프 블록을 찾아가야한다. 거기서 스캔을 시작해 rowid를 필터링해야하므로

도서 테이블에 같은 도서명을 가진 레코드가 아주 많으면 뒤 페이지로 이동할 수록 비효율도 커진다.

비효율 없는 가장 완벽한 구현을 위해서라면 도서명\_idx 인덱스 뒤쪽에 도서번호를 붙이고 쿼리를 아래와 가이 바꾼다.

```sql
  --  이전 페이지에서 출력된 마지막 레코드와 이름이 같은 도서가 있을 수 있다.
  -- 그럴 때 현재 페이지에는 이전 페이지 마지막 레코드와 이름이 같으면서 rowid가 큰 도서부터 출력한다.
  -- 인덱스 키 값이 같을 때 row순으로 정렬되기 때문이다.
  select  /*+index(도서 도서명_idx)*/
  rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where 도서명 like :book_nm || '%'
  and 도서명 = :last_book_nm -- 이전 페이지에서 출력된 마지막 도서명
  and rowid > :last_book_no -- 이전 페이지에서 출력된 마지막 도서번호
```

하지만 인덱스 뒤에 PK 컬럼을 붙여가며 개발하기가 쉽지않다. 따라서 중복 값이 아주 많은 경우가 아니라면 rowidfmf 이용하는 방안이 효과적이다.

### BETWEEN과 LIKE 스캔범위 비교

like로 코딩하는 것이 더 단순하고 슆다.

like와 Between은 둘 다 범위검색 조건으로 비효율 원리도 똑같이 적용된다. 하지만 검색을 위해 입력한 값과 테이블의 실제 데이터 상황에 따라 둘 간의 인덱스 스캔량이 다를 수 있다.

#### 범위검색 조건의 스캔 시작점 결정 원리

범위검색 조건 뒤를 따르는 조건절은 스캔 범위를 줄이는데 영향을 줄 수도 있고 안 줄수도 있다.

사용자가 조건 비교를 위해 입력한 값이나 테이블의 실제 데이터 상황에 따라 달라지며, 적어도 between이 like 보다 더 넓은 범위를 스캔하는 경우는 없으므로 between을 사용하는 것이 좋다.

일반적으로 인덱스 컬럼 조건에 대해 범위검색 조건이 나타나면 이후 조건은 인덱스 스캔 범위를 줄여주지 못한다. 하지만 범위검색 조건 뒤에 사용한 조건들도 제한적이나마 스캔 범위를 줄이는 데에

기여할 수 있다.

```sql
select count(*)
from 월별고객별판매집계 t
where 판매월 between '200901' and '200902'
and 판매구분 = 'B';

select count(*)
from 월별고객별판매집계 t
where 판매월 like '2009%'
and 판매구분 = 'B';

select count(*)
from 월별고객별판매집계 t
where 판매월 between '200900' and '200902'
and 판매구분 = 'B';
```

위 새 쿼리의 스캔 지점에 차이가 생기는 이유를 이해하는 것은 쉽지 않다.

두 번째 쿼리처럼 Like 조건으로 검색할 때는 판매월이 2009이고 판매구분이 B인 레코드를 목표로 수직탐색이 이루어진다.

브랜치 블록에서는 뒤쪽 엔트리부터 스캔을 시작해 비교 값보다 작은 값을 만나는 순간 거기서 가리키는 하위 노드로 이동한다.

이 과정을 거치면 판매월 | 판매구분이 '200812' || 'B' 인 레코드가 담긴 가장 마지막 리프 블록에 도달한다.

이 리프 블록에는 '200901||A' 인 첫 번째 레코드가 포함돼있을 가능성이 높다.

만약 그 값이 포함되지 않는다면 다음 리프블록의 처음 레코드 키 값이 '200901' || 'A' 인 경우다

수직 탐색 과정에서 사용한 비교 조건이 '200812' || 'B' 와 '200901' || 'A' 사이 값이므로 이 블록브터 스캔하면 원하는 모든 값을 찾을 수 있다.

이때문에 불필요하게 '200901' || 'A' 구간을 읽게 된다. 결론적으로 판매구분 = 'B' 조건이 스캔 범위를 줄이는데 기여하지 못했다.

첫 번째 쿼리처럼 between일 때는 판매월이 200901이고 판매구분 = B인 레코드를 목표로 수직적 탐색이 이루어진다.

브랜치 ㅂ르록에서 뒤쪽 엔트리 부터 스캔하다가 위 조건보다 작은 값을 만나는 순간 거기서 가리키는 하위 노드로 이동한다.

200901||'A' 인 레코드가 담긴 가장 마지막 리프 블록에 도달하게 된다. 따라서 판매구문 = B 조건이 스캔 범위를 줄이는데 큰 기여를 한다.

중요한 것은 실제 테이블에 존재하는 값을 수직적 탐색 조건으로 사용했다는 점이다.

만약 동일한 betwenn이더라도 세번째 쿼리오 ㅏ같이 실제 테이블에 없는 값을 입력하고 조회한 경우 '200812' || 'B' 인 레코드가 담긴 가장 마지막 리프 블록부터 스캔하므로 불필요한 '200901' || 'A' 구간까지 읽는다.

```sql
select count(*)
from 월별고객별판매집계 t
where 판매월 like '200901%'
and 판매구분 = 'B';
```

위 쿼리의 경우 like 조건이라도 실제 테이블에 있는 데이터 값을 입력하는 경우 판매구분 = 'B' 조건이 스캔 범위를 줄이는데 큰 역할을 한다.

### 선분이력의 인덱스 스캔 효율

항상 두 개의 부등호 조건을 함께 사용하는 선분 이력에선 데이터 특성상 두 번째 부등호 조건이 스캔 범위를 줄이는데 도움을 주지 못한다.

선분이력조회의 특성을 제대로 이해하지 못해 인덱스 구성을 잘못하면 성능이 크게 낮아질 수 있다. 어느 시점을 주로 조회하느냐에 따라 인덱스 스캔 효율이 많이 달라지므로 인덱스 설계 및 쿼리 작성에 주의가 필요하다.

#### 선분이력이란?

변경이력을 관리할 때 시작시점과 종료시점을 함께 관리하는 것을 선분이력 모델이라고 한다.

선분이력으로 관리한느 테이블의 인덱스 또한 시작일자와 종료일자를 포함한다. 그리고 마지막 이력의 종료일자는 9991231235959 같은 식으로 입력돼있어야한다.

선분이력의 가장 큰 장점은 쿼리가 간단해진다는 것이다.

```sql
select ...
from cust a, 연체금액 B
where a.고객번호 = '123'
and b.고객번호 = a.고객번호
and ? between b.시작일 and b.종료일
```

점이력 모델에서는 동일한 레코드를 조회할때 서브쿼리를 활용해야 한다.

```sql
select ...
from cust a, 연체금액 B
where a.고객번호 = '123'
and b.고객번호 = a.고객번호
and b.연체변경일자 = (
  select
  from 연체금액
  where 고객번호 = a.고객번호
  and 변경일자 <= '20090505'
)
```

쿼리가 간단하면 성능상 유리할때가 많지만 이력이 추가될때마다 최종레코드를 같이 변경해야하는 불편함이 있다. 이 때문이 DML 성능이 나빠질뿐만아니라 이력 데이터 관리도 힘들어진다.

중요한 또 한 가지 단점은, 개체 무결성을 사용자가 직접관리해야한다는 것이다. 선분이력의 개체 무결성을 확보하려면 선분의 중복이 없어야 한다.

점이력의 경우 PK 제약 설정을 통해 개체 무결성이 보장되지만, 선분이력일 때는 선분이 겹치거나 끊기지 않도록 직접 관리해야한다.

#### 선분이력 기본 조회 패턴

```sql
select ...
from 고객별연체금액
where a.고객번호 = '123'
and :dt between 시작일 and 종료일
```

현재시점을 조회하 때는 상수조건을 이용해 = 조건으로 이용해야한다.

```sql
select ...
from 고객별연체금액
where a.고객번호 = '123'
and  종료일 = '9991231'
```

선분이력 테이블에 정보를 미리 입력해 두는 경우 현재 시점을 명확하게 조회해애한다.

```sql
select ...
from 고객별연체금액
where a.고객번호 = '123'
and  to_char(sysdate, 'yyyymmd') between 시작일 and 종료일
```

#### [시작일 + 종료일] 구성일 때 최근 시점 조회

인덱스가 [고객번호 + 시작일 + 종료일 ] 순으로 구성된 상태에서 특정 고객에 대한 연체시점을 조회하는 Between 쿼리를 부등호로 풀면 다음과 같다.

```sql
where 고객번호 = '123'
and 시작일 <= '20100101'
and 종료일 >= '20100101'
```

종료일 조건을 위해 스캔해야할 범위가 시작일보다 훨씬 적은 범위지만 선두 컬럼인 시작일 조건이 부등호이기 때문에 스캔 범위를 줄이는 데 기여하지 못한다.

종료일이 인덱스 컬럼에 포함돼 있기 때문에 테이블 Random Access 없이 인덱스 내에서 필터링 할 수 있다.

문제는 종료일 까지 필터링한 최종 레코드는 언제나 한건뿐인데 이력레코드가 많이 쌓인 고객일 수록 한 건을 찾기 위해 많은 인덱스 레코드를 스캔해야한다는 데있다.

index_desc 힌트를 주고 rownum <= 1 조건을 추가해 준다면, 인덱스를 거꾸로 한 건만 스캔하고 원하는 이력레코드를 차증ㄹ 수 있다.

```sql
-- index [고객번호 + 시작일 + 종료일]
select /*+index_desc(a idx_x01)*/...
from 고객별연체금액 a
where a.고객번호 = '123'
and  '20050131' between 시작일 and 종료일
and rownum <= 1

where 고객번호 = '123'
and 시작일 <= '20050131'
and 종료일 >= '20050131'
```

#### [시작일 + 종료일] 구성일 때 과거 시점 조회

아주 오래된 과거의 연체정보를 조회하는 경우

```sql
-- index [고객번호 + 시작일 + 종료일]
select *
from 고객별연체금액
where 고객번호 = '123'
and '20010101' between 시작일 and 종료일


where 고객번호 = '123'
and 시작일 <= '20020930'
and 종료일 >= '20020930'
```

= 조건인 고객번호 다음 인덱스 컬럼이 '<=' 조건이지만 과거 시점이라 해당하는 레코드가 많지 않다.

스캔량이 얼마 되진 않지만 index_desc 힌트를 주고 rownum <= 1 조건을 주면 스캔 범위를 단 한 건으로 줄일 수 있다.

```sql
select /*+index_desc(a idx_x01*/ *
from 고객별연체금액
where 고객번호 = '123'
and '20010101' between 시작일 and 종료일
and rownum <= 1
```

#### [종료일 + 시작일] 구성일 때 최근 시점 조회

인덱스 구성이 [고객번호 + 종료일 + 시작일] 인 상태에서 고객의 최근 시점 연체정보를 조회하는 경우

```sql
-- index [고객번호 + 종료일 + 시작일]
select /*+index(a idx_x01)*/...
from 고객별연체금액 a
where a.고객번호 = '123'
and  '20050131' between 시작일 and 종료일
and rownum <= 1

where 고객번호 = '123'
and 시작일 <= '20050131'
and 종료일 >= '20050131'
```

등치조건 다음 인덱스 컬럼인 종료일이 >= 조건이므로 20250131 이후의 레코드를 모두 스캔해야히지만 최근 시점이라 이 범위에 속한 레코드가 얼마 되지 않는다.

스캔량이 얼마 되진 않지만 rownum <= 1 조건을 추가하면 스캔범위를 단 한 건으로 줄일 수 있다.

#### [종료일 + 시작일] 구성일 때 과거 시점 조회

인덱스 구성이 [고객번호 + 종료일 + 시작일] 인 상태에서 고객의 과거 시점 연체정보를 조회하는 경우

```sql
-- index [고객번호 + 종료일 + 시작일]
select /*+index(a idx_x01)*/...
from 고객별연체금액 a
where a.고객번호 = '123'
and  '20020930' between 시작일 and 종료일
and rownum <= 1

where 고객번호 = '123'
and 시작일 <= '20020930'
and 종료일 >= '20020930'
```

종료일 조건 때문에 스캔해야할 범위가 넓지만 rownum <= 1 조건을 주면 단 한 건만 스캔하고도 원하는 이력 레코드를 착을 수 있다.

#### 중간시점조회

최초 이력이나 최근 이력을 조회하는 것이 아니라 중간시점 이력을 조회할 때는 인덱스 구성과 무관하게 어느정도 비효율을 감수해야한다.

하지만 중간지점을 조회할 때도 rownum 을 활용하면 단 한 건만 스캔하고도 원한느 이력 레코드를 빠르게 찾을 수 있다.

```sql
-- 인덱스 구성이 [고객번호 + 시작일 + 종료일] 일때

select /*+index_desc(a idx_x01)*/...
from 고객별연체금액 a
where a.고객번호 = '123'
and  '20031010' between 시작일 and 종료일
and rownum <= 1
```

#### 선분이력 스캔 효율을 높이는 방법

선분이력처럼 between 검색 조건이 사용될 때는 어느 시점을 주로 조회햐느냐에 따라 인덱스 구성전략을 달리 해야한다.

최근 데이터를 주로 조회한다면 [종료일 + 시작일] 순으로 구성하는 것이 효과적이며, 오래된 가거 데이터를 주로 조회한다면 [시작일 + 종료일] 순이 효과적이다.

rownum 과 index_desc 힌틀르 적절히 사용하면 인덱스 구성에 관계없이 1건만 스캔할 수 있다.

싲작일 + 종료일은 index_desc 힌트와 rownum <= 1 조건을 추가하고 종료일 + 시작일 의 경우 rownum <= 1 조건만 추가하면 된다.

중간시점을 조회할 때도 마찬가지이다.

미래 시점 데이터를 미리 입력하는 경우가 없다면, 현재 시점 데이터를 조회할 때는 between 보다 상수조건을 사용하는것이 좋다.

### ACCESS PREDICATE 와 FILTER PREDICATE

인덱스를 경유해 테이블을 애겟스할 때는 최대 3가지의 Predicate 정보가 나타날 수 있다.

1. 인덱스 단계에서의 Access Predicate
2. 인덱스 단계에서의 Filter Predicate
3. 테이블 단계에서의 Filter Predicate

인덱스를 경유하지 않고 테이블 전체를 스캔할 때는 항상 테이블 단계에서의 Filter Predicate만 나타난다.

인덱스 단계에서의 Access Predicate 는 인덱스 스캔 범위를 결정하는 데에 영향을 미치는 조건절을 의미한다.

인덱스 컬럼에 대한 조건절은 범위검색 조건을 뒤따르는 조건이거나 선행 컬럼이 조건절에서 누락될지라도 액세스 범위를 결정하는데에 기여하므로

대부분 Access Predicate 에 포함된다.

인덱스 스캔 범위를 결정하는 데에 전향을 미치지 않아 Access Predicate에서 제외되는 경우는 다음과 같다.

- 좌변 컬럼을 가공한 조건절
- 왼쪽 또는 양쪽에 % 기호를 사용한 Like 조건절
- 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절

위 경우를 제외하면, 수직적 탐색 과정에서 모든 인덱스 컬럼을 비교 조건으로 사용한다. 수평적 탐색의 종료 지점을 결정짓는 비교조건으로도 사용한다.

인덱스 단계에서의 'Filter Pridecate' 는 테이블로의 액세스 여부를 결정짓는 조건절을 의미한다.

첫 번째 나타나는 범위검색 조건부터 이후 모든 조건절 컬럼들이 여기에 포한되며 조건절에서 누락된 컬럼 뒤쪽에 놓인 인덱스 컬럼들도 포함한다.

테이블 액세스 단계에서의 Filter Predicate 는 테이블을 액세스하고 나서 최종 결과집합으로의 포함여부를 결정짓는 조건절을 의미한다.

### INDEX FRAGMENT

오라클 인덱스에 불균현은 생길 수 없지만 Index Fragment에 의한 Index Skew 또는 Sparse 현상이 생기는 경우가 종종 있다. 이는 인덱스 스캔 효율에 나쁜 영향을 미칠 수 있다.

#### INDEX SkEW

인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 말한다.

```sql
create table t as select rownum no from dual connect by level <= 100000;

create index t_idx on t (no) pctfree 0;

delete from t where no <= 500000;

-- 이 시전에 freelist로 반환되지만 인덱스 구조는 그대로 남는다.
commit;
```

텅 빈 인덱스 블록은 커밋하는 순간 freelist로 반환되지만 인덱스 구조 상에는 그대로 남는다.

상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 그대로 남아 있어 인덱스 정렬 순서상 그곳에 입력될 새로운 값이 들어오면 언제든 재사용이 가능하다.

재사용되더라도 이 경우에는 곧바로 freelist에서 제거되지 않으며 나중에 빈 블록을 찾기 위해 Freelist를 스캔하는 프로세스에 의해 정리된다.

새로운 값이 하나라도 입력되기 전 다른 노드에 인덱스 분할이 발생하면 그것을 위해서도 이들 블록이 재사용된다.

이때는 상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 제거돼 다른 쪽 브랜치의 자식 노드로 이동하고, Freelist에서도 제거된다.

이처럼 레코드가 모두 삭제된 블록은 언제든 재사용이 가능하지만, 다시 채워질 때까지 인덱스 스캔효율이 낮다.

위와 같은 Index Skew 현상으로 인해 성능이 나빠지는 경우는 대개 Index Full Scan 할 때다.

대량의 데이터를 매일 지웠다가 새로 입력하는 통계성 테이블일 때는 Index Skew 가 발생하지 않도록 트랜잭션 패턴에 신경써야한다.

한 트랜잭션에서 동일 테이블에 대한 delete와 insert 가 순차적으로 발생하는 경우

PK 인덱스 왼쪽에 놓인 상당수의 리프 블록들이 Delete 문을 통해 모든 레코드가 지워지더라도 커밋하기 전까지는 Freelist로 반환될 수 없다.

따라서 곧 이은 Insert 과정에서 빈 블록이 많이 필요함에도 새로운 블록을 사용할 수 없어 새로운 공간을 할당받게 된다.

빈 블록들은 그 다음 날 insert 과정에서 재사용되겠지만 delete 문에 의해 지워지는ㄴ 블록들이 새로 생긴다.

결국 인덱스 왼쪽의 많은 블록들이 항상 빈 상태로 남아 인덱스 스캔 효율을 떨어뜨리게 된다.

동일 트랜잭션이 아닌 Delete 문 직후 커밋을 수행하면 지워진 블록들이 곧바로 insert 과정에 재사용된다.

index skew 방지를 위해 트랜잭션을 짧게 정의하는 것이 바람직하진 않지만 배치 거래인경우 무방하다.

#### Index Spare

인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말한다.

지워진 자리에 인덱스 정렬 순서에 따라 새로운 값이 입력되면 그 공산은 재사용되지만 대량의 delete 작업이 있고 난 후 한동안 인덱스 스캔 효율이 낮아진다.

INDEX SKEW 의 경우 블록이 아예 텅 비면 곧바로 Freelist로 반환돼 재사용되지만, Index Spare는 지워진 자리에 새로운 값이 입력되지 않으면 영영 잿용이 불가능ㅎ다ㅏ.

#### INDEX REBUILD

FRAGMENT 로 인해 인덱스 크기가 계속 증가하고 스캔 효율이 나쁘면 coalesce 명령어를 수행한다.

명령어를 수행하면 인덱스 분할과 반대의 작업이 일어난다. 여러 인덱스 블록을 하나로 병합하고, 그 결과로서 생긴 빈 블록들을 freelist에 반환한다.

coalesce 명령을 수행히도 인덱스 세그먼트에 할당된 미사용 공간이 반횐되진 안흔ㄴ다.

INDEX FRAGMENTATION을 해소하면서 공간까지 반환하려면 shrink 명령어를 수행하면 된다.

```sql
alter index t_idx shrink space;
```

compact 옵션을 지정하면 공간을 반환하지 않으므로 coalesce 명령어와 같게 동작한다.

```sql
alter index t_idx shrink space compact;
```

작업량이 많을 때는 rebuild 명령어를 사용하는 편이 낫다.

```sql
alter index t_idx rebuild;

alter index t_idx rebuild online;
```

위와 같은 방식으로 인덱스 구조를 슬림화하면 저장 효율이나 스캔 효율은 좋아지지만 일반적으로 인덱스 블록에는 어느정도 공간을 남겨두는 것이 좋다.

인덱스 블록에 공간이 전혀 없으면 인덱스 분할이 자주 발생해 DML 성능이 감소하기 때문이다.

인덱스 분할에 의한 경합을 줄이려면 pctfree를 높이고나서 인덱스 rebuild를 해야한다.

아래와 같이 예상효과가 확실할 때만 인덱스 rebuild를 고려하는 것이 바람직하다.

- 인덱스 분할에 의한 경합이 현저히 높을때
- 자주 사용되는 인덱스 스캔 효율을 높이고자 할때, 특히 NL조인에서 반복엑세스되는 인덱스 높이가 증가했을떄
- 대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될때
- 총 레코드 수가 일정함에도 인덱스가 계속 커질때

---

### INDEX Freelist

테이블에서의 pctfree와 pctused는 각각 freelist에서 제외되는 시점과 다시 등록되는 시점을 지정하는 파라미터이다.

테이블은 Heap 방식으로 데이터를 입력하므로 매번 Freelist를 참조해 데이터 삽입이 가능한 블록을 찾아야 한다.

반면, 인덱스는 정렬된 구조로 자료를 삽입하므로 값이 입력될 때마다 freelist를 참조하지 않아도된다.

인덱스 구조를 탐색해 정렬 순서에 따라 정해진 곳에 레코드를 삽입하기 때문이며, 인덱스 freelist는 인덱스 분할로 빈 블록이 필요할 때만 참조한다.

이처럼 테이블과 인덱스 간에 pctfree의 의미와 작동방식이 서로 다르며, 인덱스에 pctused 파라미터가 없는 것도 특징적이다.

#### pctfree

테이블에서 pctfree는 블록에 더 이상 insert 가 발생하지 못하도록 Freelist로 부터 제외되는 시점을 지정하는 것이다. 남겨진 빈 공간은 나중에 update를 위해 사용된다.

인덱스에서의 pctfree는 용도가 다르다. 인덱스가 생성되는 시점에 공간을 꽉 채워두면 나중에 인덱스 분할이 빈번하게 발생하므로 이를 방지하기 위해 필요하다 .

이 옵션은 인덱스 최초 생성 또는 재생성 시점에만 적용되며, 지정한 비율만큼 공간을 남겨 두었다가 나중에 Insert를 위해 사용된다.

#### PCTUSED

Freelist에서 제거된 테이블 블록에 빈 공간이 일정 수준 이상 확보됐을 때만 다시 freelist에 등록되도록 하기 위해 pctused 파라미터가 필요하다.

insert, delete가 자주 발생하는 테이블에 pctfree와 Pctused 합이 100에 가까우면 freelist 변경이 자주 발생한다.

예를 들어 pctfree가 10이고 pctused가 80이면 freelist에서 제거된 블록에 10%정도 delete가 발생하는 순간 해당 블록을 다시 Freelist에 등록해야한다.

반대로 delete가 적개 발생한다면 pctfree와 pctused 를 100에 가깝도록 설정해야 테이블 블록 저장효율을 높일 수 있다.

인덱스에는 pctused 파라미터가 없다. 이유는 인덱스에서 빈 공간은 항상 재사용이 가능하기 때문이다.

테이블에서 freelist는 insert 가 가능한 블록을 관리한다. 100-pctfree 만큼의 공간이 차면 freelist에서 제거되고, pctused만큼만 남기고 레코드가 모두 지워질때 다시 freelist에 등록된다.

인덱스에서의 freelist는 인덱스 분할에 사용 가능한 빈 블록을 관리한다.

기억할 것은, delete에 의해 비워진 인덱스 블록은 커밋 시점에 Freelist에 반환되지만 insert 시전에 다시 입력되더라도 곧바로 freelist에서 제거되지 않는다.

인덱스 분할 때문에 freelist를 스캔하는 프로세스에 의해 정리된다.

즉, Freelist에서 얻은 블록이 비어있지 않으면 다른 블록을 재용청하기전에 일단 해당블록을 Freelist에서 제거하는 방식이며, 이는 커밋 시점의 일량을 최소화하기 위함이다.

값을 입력하고 커밋할 때마다 freelist를 관리해줘야 한다면 fast commit 매커니즘에 문제가 생길 수 있다.
