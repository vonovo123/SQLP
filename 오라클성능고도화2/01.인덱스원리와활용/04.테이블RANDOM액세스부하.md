인덱스를 효과적으로 활용하면 쿼리의 성능이 비약적으로 향상된다. 하지만 대량의 데이터를 인덱스를 통해 액세스하는 경우 성능이 크게 저하된다.

대량의 데이터를 처리할때 성능이 크게 저하되는 이유는 테이블 RANDOM 액세스 때문이다.

### INDEX ROWID에 의한 테이블 액세스

쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 RANDOM ACCESS가 일어난다.

실행계획에서 TABLE ACCESS BY INDEX ROWID라고 표시된다.

인덱스에 저장된 rowid는 오브젝트 번호, 데이터파일 번호, 블록 번호 같은 물리적 요소로 구성된 주소정보다. rowid는 물리적 위치 정보로 구성되지만

인덱스에서 테이블 레코드로 직접연결되는 구조가 아니기 때문에 논리적 주소정보 역할을 하기도 한다.

오라클은 테이블 블록이 수시로 버퍼 케시에서 밀려났다가 다시 캐싱된다. 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 버퍼블록과와 연결할 수 없다.

대신 디스크 상의 블록 위치 정보인 DBA를 해시 키 값으로 삼아 해싱 알고리즘을 통해 DBA와 매칭되는 버퍼 블록을 찾는다. 매번 저장되는 버퍼블록의 주소는 달라지더라도 캐싱되는 해시 버킷만큼은 고정적이다.

해싱과정얼 거치기때문에 rowid에 의한 테이블 액세스는 생각만큼 빠르지 않다.

오라클은 반복적으로 읽힐 가능성이 큰 블록에 대해서만 일부 포인터로 빠르게 액세스하는 버퍼 Pinning 기법을 사용한다.

일반적인 인덱스 rowid에 의한 테이블 액세스는 다음과 같은 과정을 거친다.

- 인덱스에서 하나의 rowid를 읽고 DBA를 해싱하여 해시 값을 확인한다.

- 해시 체인은 래치에의해 보호되므로 해시 값이 가리키는 해시 체인에 대한 래치를 획득해야한다. 하나의 래치가 여러 체인을 동시에 관리하므로 경합이 발생할 수 있다.

- 다른 프로세스가 래치를 잡고 있으면 래치가 풀렸는지 확인하는 작업을 일정 횟수 반복한다.

- 실패하면 CPU를 OS에 반환하고 대기한다.

- 일정 시간 후 다시 래치를 확인하고 획득해 해시 체인으로 진입한다.

- 데이터 블록이 찾아지면 래치를 해제하고 바로 읽는다. 만약 다른 프로세스에 의해 해당블록에 버퍼 Lock이 걸려있으면 대기한다.

- 블록 읽기를 마치고 버퍼 lock을 해제하기 위해 다시 해시 체인 래치를 얻는다.

해시 체인 스캔후 데이터 블록을 찾지 못하면 다음과 같은 과정을 거친다.

- 디스크로부터 블록을 퍼 올리려면 Free 버퍼를 할당 받아야 하므로 LRU 리스트를 스캔한다.

- Free 버퍼를 찾지 못하면 DBWR에 Dirty 버퍼를 디스크에 기록해 Free 버퍼를 확보한다.

- I/O 서브시스템에 I/O 요청을 하고 다시 대기 한다.

- 읽은 블록을 LRU 리스트 상에서 위치를 옮긴다.

인덱스 rowid는 테이블 레코드와 물리적으로 연결돼 있지 않기에 고비용 구조다.

모든 데이터가 메모리에 캐싱돼있더라도 테이블 레코드를 찾기위해서는 매번 DBA를 해싱하고 래치를 획득하는 과정을 반복해야한다.

### 인덱스 클러스터링 팩터

클러스터링 팩터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 말한다. 팩터가 높은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다.

조건에 해당하는 데이터가 물리적으로 근접해 있기 때문이다.

인덱스의 클러스터링 팩터가 가장 좋은 상태는 인덱스 레코드의 정렬 순서와 테이블 레코드의 정렬 순서가 100% 일치할 때이다.

반면 인덱스 레코드의 정렬 순서와 테이블 레코드의 정렬 순서가 전혀 일치하지 않으면 클러스터링 팩터는 0이다.

오라클은 인덱스 통계를 수집할 때 clustering_factor 계산을 위해 다음과 같은 로직을 사용한다.

1. counter 변수를 하나 선언한다.
2. 인덱스 리프 블록을 청므부터 끝까지 스캔하면서 인덱스 Rowid로 부터 블록 번호를 취한다.
3. 현재 읽고있는 인덱스 레코드의 블록 번호가 직전 인덱스 레코드에 저장된 블록번호와 다르면 counter 변수를 1 증가시킨다.
4. 스캔을 완료하고서, 최종 Counter 변수값을 clustering_factor로 사용한다.

측정된 cf 값은 옵티마이저가 인덱스 Range Scan을 사용할지에 대한 기준으로 사용된다.

비용 = 인덱스 수직적 탐색 비용 + (리프 블록 수 _ 유효 인덱스 선택도) + (클러스터링 팩터 _ 유효 테이블 선택도)

인덱스의 클러스터링 팩터가 좋다고 하면 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷하다는 의미다.

인덱스 레코드는 항상 정렬된 상태를 유지하는데 테이블 레코드도 이와 비슷한 순서를 갖는다면 같은 레코드가 군집해있음을 의미한다.

이는 궁극적으로 디스크 I/O 횟수를 감소시키는 효과를 준다.

오라클에서 I/O는 블록 단위로 이루어지므로 인덱스를 통해 하나의 레코드를 읽으면 같은 블록에 속한 다른 레코드들도 함께 캐싱된다.

CF가 좋은 인덱스라면 그 레코드들도 가까운 시점에 읽게될 가능성이 높다.

따라서 인덱스를 스캔하면서 읽는 테이블 블록의 캐시 히트율이 높아지므로 물리적인 디스크 I/O 횟수가 감소한다.

인덱스 CF는 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수다.

CF가 가장 좋을 때는 인덱스 통계에 나타나는 clustering_factor가 전체 태이블 블록 개수와 일치하고, 가장 안 좋을 때는 총 레코드 개수와 일치한다.

모든 블록에 레코드가 하나씩만 저장돼 있다면 clustering_factor는 항상 총 레코드 개수와 일치할 것이다.

오라클은 인덱스가 가리키는 데이터의 흩어짐 정도를 인덱스 비용 계산식에 표현하기 위해 CF를 고안했다.

옵티마이저가 사용하는 비용 계산식은 기본적으로 물리적인 I/O 만을 고려하므로 CF도 궁극적으로 물리적 I/O 비용을 평가하기 위한 수단이다.

하지만 논리적 I/O가 100% 물리적 I/O를 수반하지 않는다. 앞서 읽었던 테이블 블록을 읽을 때 실제로는 캐싱된 블록을 읽을 가능성이 높기 때문이다.

한번 읽은 테이블 블록이 버퍼 캐시에서 밀려나지 않도록 충분히 버퍼 캐시를 확보한 상태에서 인덱스를 통해 전체 테이블 레코드를 읽는경우

캐싱 효과를 예측하기가 매우 어렵다.

옵티마이저는 CF를 통해 계산된 논리적 I/O 횟수를 그대로 물리적 I/O 횟수로 인정하고 인덱스 비용을 평가한다.

결론적으로 인덱스 통계에서 볼 수 있는 clustering_factor는 인덱스를 통해 테이블을 액세스할 때 예상되는 논리적 I/O의 수를 더 정확하게 표현하고 있다.

#### 버퍼 Pinning에 의한 논리적 I/O 감소 원리

똑같은 개수의 레코드를 읽는데 CF에 따라 논리적 블록 I/O 개수가 차이나는 이유는 인덱스를 통해 액세스 되는 하나의 테이블 버퍼 블록을 Pinning하기 때문이다.

버퍼 Pinning은 방금 엑세스한 버퍼에 대한 Pin을 즉각 해제하지 않고 데이터베이스 Call 내에서 계속 유지하는 기능이다.

연속된 인덱스 레코드가 같은 블록을 가리키면, 래치 획득 과정을 생략하고 버퍼를 Pin 한 상태에서 읽기 때문에 논리적 블록 읽기 횟수가 증가하지 않는다.

### 인덱스 손익분기점

인덱스 rowid에 의한 테이블 액세스는 고비용 구조이기 때문에 일정량을 넘는 순간 테이블 전체를 스캔할 때보다 오히려 더 느려진다.

이 지점을 손익 분기점으로 부른다.

손익 분기점이 발생하는 두 가지 요인은 다음과 같다.

- 인덱스 rowid에 의한 테이블 액세스는 Random 액세스인 반면, Full Table Scan은 Sequential 액세스 방식으로 이루어진다.

- 디스크 I/O시, 인덱스 rowid 에 의한 테이블 액세스는 Single Block Read를 사용하는 반면, Full Table Scan은 Multiblock Read 방식을 사용한다.

인덱스의 CF가 낮으면 같은 테이블 블록을 여러 번 반복 액세스하면서 논리적 I/O의 수가 증가하고 물리적 I/O 발생량도 증가한다.

손익분기점 원리에 따르면 선택도가 높은 인덱스는 효용가치가 낮지만 대용량 테이블을 Full Scan 하는 것역시 비효율이 크다.

오라클이 제공하는 기능을 잘 활용하면 손익분기점의 한계를 극복할 수 있다.

IOT는 테이블을 인덱스 구조로 생성하는 것을 말한다. 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다.

인덱스 리프 블록이 곧 데이터 블록이므로 추가적인 Random 액세스가 불필요하다.

클러스터 테이블은 키 값이 같은 레코드는 같은 블록에 모이도록 저장하기 때문에 클러스터 인덱스를 이용할 때는 테이블 Random 엑세스가

키 값별로 한 번씩만 발생한다.

클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다.
