인덱스 선두컬럼이 조건절에 사용되지 않으면 범위 스캔을 위한 시작점을 찾을 수 없어 옵티마이저는 인덱스 전체를 스캔하거나 테이블ㅇ르 스캔하는 방식을 선택한다.

인덱스 선두 컬럼이 조건절에 사용되더라도 인덱스를 사용못하거나 범위 스캔이 불가능 한 경우도 있다.

### 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우

인덱스 컬럼을 조건절에서 가공하면 정상적으로 인덱스를 사용할 수 없다.

인덱스 범위 스캔이 불가능 한것이지 인덱스 사용 자체는 가능하다. 인덱스 컬럼을 조건절에서 가공하면 옵티마이저는 Index Full Scan을 한다.

부정형 비교시에 인덱스 범위 스캔이 불가능한데 is not null 조건도 부정형 비교에 해당하므로 불가능하다.

```sql
select *
from emp
where cd is not null
```

cd에 단일 컬럼 인덱스가 존재하면 그 인덱스 전체를 스캔하면서 얻은 레코드는 모두 위 조건을 만족한다. 오라클은 단일 컬럼 인덱스에 null 값은 저장하지 않기 때문이다.

결합 인덱스일 때는 인덱스 구성 컬럼 중 하나라도 null이 아닌 레코드는 인덱스에 포함되지만 필터링을 통해 is not null 조건에 해당하는 레코드를 찾을 수 있다.

아예 인덱스 사용이 불가능한 경우도 있는데, is null 조건으로만 검색할 때가 그렇다.

구성컬럼이 모두 Null 인 테이블 레코드가 있다면 인덱스에서 찾을 수 없기 때문이다.

is null 조건을 사용하더라도 다른 인덱스 구성 컬럼에 is null 이외의 조건식이 하나라도 있으면 Index Range Scan이 가능하다.

인덱스 구성 컬럼 중 하나라도 null이 아닌 값이 아닌 레코드는 인덱스에 저장되기 때문이다.

물론 인덱스 선두 컬럼이 조건절에서 누락되지 않아야 한다.

만약 다른 인덱스 쿠성 컬럼 중 어느 하나라도 not null 제약이 설정돼 있다면 그 컬럼에 대한 조건절 유무에 관련없이 항상 Index Range Scan이 가능하다.

### 인덱스 컬럼의 가공

```sql
select *
from 주문
where nvl(주문수량, 0) >= 100
```

쿼리의 기대결과가 주문 수량이 100보다 큰 레코드인데 주문수량이 null인 경우는 원래 포함되지 않는다. 그럼으로 주문수량이 null일 때 0으로 치환할 필요가 없다.

```sql
select *
from 주문
where nvl(주문수량, 0) < 100
```

위의 경우는 NUll을 0으로 치환해서 100보다 작거나 null인 주문을 찾고자하는 SQL이다.

이런 쿼리는 튜닝 시 not null 컬럼은 아닌지 확인해봐야한다. 만약 not null 컬럼이라면 nvl을 제거하도 되지만,

아닐 때는 Table Full Scan이 불가피하다.

위 조건에 해당하는 건수가 아주 많다면 Table Full Scan이 유리하지만 얼마 되지 않는다면 함수기반 인덱스의 생성을 고려해볼 수 있다.

```sql
  create index 주문_X01 on 주문(nvl(주문수량, 0 ))
```

In-List 를 튜블형태로 기술하면 인덱스컬럼 가공을 방지할 수 있다.

```sql
and (divCode, code) in (('1', '001'), ('2', '003'))
```

Decode 문을 분석해 논리적으로 동일한 결과를 리턴하도록 조건절을 수정하면 정상적인 인덱스 스캔이 가능해진다.

```sql
where decode(정정대상접수본호, lpad('', 14), 금감원접수번호, 정정대상접수번호) = :접수번호

where 정정대상접수번호 in (:접수번호, lpad('',14))
,and 금감원접수번호 = decode(정정대상접수번호, lpad('',14), :접수번호, 금감운접수번호)
```

문자형 컬럼에 연산함수를 사용하면 숫자형으로 묵시적 형변환이 일어난다. 그리고 숫자형과 문자형을 비교하면 문자형이 숫자형으로 묵시적 형변환이 일어난다.

```sql
and y.대상연월(+) = substr(x.파트너지원요청일자, 1, 6) - 1
```

이 공식에 따르면 위 쿼리는 다음과 같다.

```sql
and to_number(y.대상연월(+)) = to_number(substr(x.파트너지원요청일자, 1, 6)) - 1
```

대상연월의 묵시적 형변환을 막기위해서는 다음과 같이 조치해야한다.

```sql
and to_number(y.대상연월(+)) = to_char(add_month(to_date(x.파트너지원요청일자,'yyyymmdd'), -1), 'yyyymm')
```

#### 묵시적 형변환 사용시 주의사항

묵시적 형변환은 인덱스 사용불가문제 뿐아니라 틀린 결과를 불러올 수 도 있따.

문자형 컬럼에 숫자로 변환할 수 없는 문자열이 들어있으면 형변환 중 에러가 발생한다.

참고로, like로 비교할 때는 숫자형이 문자형으로 변환된다.

```sql
max(decode(job, 'President', null, sal))
```

위 쿼리의 의도는 당연히 급여가 가장 높을 것으로 예상되는 대상에 레코드는 제외하고 나머지 중 최대급여를 찾는 것이다.

오라클 decode(a,b,c,d) 함수의 결과갑의 타입은 c인자가 결정한다. C가 숫자형이고 d가 문자형이면 d는 숫자형으로 변환된다/

만약 c인자가 null이면 varchar2 타입으로 인식하므로 sal은 문자형이된다.

sal울 문자형으로 변환했을때 가장 큰값이 max함수의 결과나와 틀린결과가 도출된다.

이때는 데이터 타입을 명시적으로 일치시켜야한다.

```sql
max(decode(job, 'President', to_number(null), sal))
```
