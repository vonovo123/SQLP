### 범위 스캔

인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트다.

인덱스는 키 컬럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.

이를 범위 스캔이라고 한다.

INDEX-ORGANIZED TABLE의 경우 특젇 컬럼 순으로 정렬 상태를 유지하며 값을 입력하므로 범위 스캔이 가능하다.

이를 제외한 일반적인 힙 구조 테이블에서 범위 스캔은 불가능하다.

### 인덱스 기본 구조

일반적인 인덱스는 B\*tree 구조이다.

루트를 포함한 브랜치 블록에 저장된 엔트리에는 하위 노드 블록을 찾아가기 위한 DBA 정보를 가 있다. 최말단 리프 블록에는

인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아기기 위한 주소정보가 있다.

리프 블록은 항상 키 컬럼 순으로 정렬돼 있기 때문에 범위 스캔이 가능하다. 만약 키 값이 같다면 rowid 순으로 정렬된다.

---

#### LeftMost Child

브랜치 노드의 각 엔트리는 쾨 + 하위노드블록 주소로 구성된다. 브랜치 노드의 첫 번째 엔트리는 키 값을 같지않는 특별한 엔트리를 인데 이를 lmc라고 부른다.

다른 엔트리는 자신의 키 값과 같거나 큰 값을 담고 있는 자식 노드 블록을 가리키는 반면, lmc는 키 값ㅇ르 가진 첫 번째 엔트리보다 작은 값의 의미를 갖는다.

따라서 그 브랜치 브록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

---

오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 인덱스 생성시 저장하지 않는다. 인덱스와 테이블 레코드는 서로 1:1 대응관계를 갖는다.

브랜치에 저장된 레코드 개수는 바로 하위 레벨 블록 개수와 일치한다.

인덱스 리프 노드상의 레코드와 테이블 레코드는 1:1 관계이기 때문에, 테이블 레코드에서 값이 갱신되면 리프 노드 인덱스 키 값도 같이 갱신된다.

반면 리프 노드상의 키 값이 갱신되더라도 브랜치 노드까지 값이 바뀌지 않는다. 브랜츠 블록에 놓인 엔트리는 자신의 키 값과 같거나 큰 값을 담는 하위 노드 블록을 포인팅하는 것으로

그 키 값은 자식 노드가 갖는 값의 범위를 나타내기 때문이다.

따라서 키 값이 하위 노드의 첫 번째 레코드와 정확하게 일치하지 않는다.

브랜치 노드는 인덱스 분할에 의해 새로운 블록이 추가되거나 삭제 될 때만 갱신된다.

인덱스의 구조에 대한 정보를 요약하면 다음과 같다.

- 리프 노드상의 인덱스 레코드와 테이블 레코드는 1:1 관계
- 리프 노드상의 키 값과 테이블 레코드의 키 값은 서로 일치
- 브랜치 노드의 엔트리 수는 하위 레벨 블록 개수와 일치
- 브랜치 노드의 엔트리 키값은 하위 노드가 갖는 값의 범위를 의미

### 인덱스 탐색

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색 두 가지가 있다.

수평적 탐색은 Range Scan을 의미한다, 리프 블록을 인덱스 레코드 간 논리적 순서에 따라 수평으로 스캔하기에 수평적 탐색이라고 표현한다.

수직적 탐색은 수평적 탐새의 시작점을 찾는 과정이다. 루트에서 리프노드로 진행되기 때문에 수직적이다.

인덱스 탐색과정은 다음과 같다.

1. 먼저 로트 블록을 스캔하면서 어느 브랜치 블록으로 갈지 정한다. lmc는 키값보다 작은 모든 값을 의미하고, 엔트리의 키 값은 하위 블록이 키 값보다 크거나 같은 키를 가진 엔트리로 구성돼있음을 의미한다. 즉 찾고자하는 값이 lmc 다음 엔트리의 키값보다 작으면 lmc 에 연결된 하위 브랜치블록으로, 크면 다음 엔트리에 연결된 블록으로 이동한다.

2. 찾아간 브랜치 블록을 스캔하면서 그 당므 찾아갈 인덱스 블록을 탐색한다. 찾고자 하는 값보다 큰 키값을 만나면 직전엔트리가 가리키는 블록으로 이동한다.

3. 도착한 곳이 리프블록일때 찾으려고 한 값을 찾으면 동일단 값이 다른 블록에도 있는지 찾기위해 수평적 탐색과정으로 넘어간다. 못 찾으면 인덱스 탐색을 마친다

4. 인덱스 리프 블록을 스캔하면서 값이 일치하는 엔트리가 있는지 확인한다.

5. 일치하는 엔트리의 rowid를 이용해 해당 테이블 레코드를 찾아 필요한 다른 컬럼값을 읽는다. 쿼리에서 인덱스에 포함된 컬럼만 필요로 하면 이 과정은 생략된다.

6. 4~5번 과정을 반복하다가 검색조건을 만족하지 못하는 레코드를 만나면 탐색을 멈춘다.

#### 브랜치 블록 스캔

인댁스 탐색 중 1번과 2번에서 브랜치 블록을 스캔할 때는 뒤에서 부터 탐색하는 방식이 유리하다.

뒤에서부터 스캔할 때는 찾는 값보다 작은 첫 번째 레코드를 만나는 순간 바로 하위블록으로 내려가면 되지만, 앞에서부터 스캔하면 찾고자하는 값보다 크거나 같은 첫 번째 레코드를 만나는 순간

멈춰서 한칸 뒤로 다시 이동해야하기 때문이다.

오라클이 실제로 값을 뒤에서부터 읽는지 값을 거꾸로 뒤집어서 앞에서 부터 읽는지는 알 수 없다.

브랜치 블록을 따라 수직적 탐색을 진행할때는 찾고자 하는 값보다 키 값이 작은 엔트리를 따라 내력나다.

같은 값이 있다고 해서 그 블록을 따라가면 이전 블록에 있는 동일 값을 놓치게 된다.

도착한 이전 브랜치에서 맨 뒤쪽 부터 거꾸로 스캔하다가 더 작은 값을 만나는 순간 리프블록에서 내려간다.

거기서 찾고자하는 값고 동일한 레코드를 찾아 오른쪽으로 스캔해나간다.

#### 결합인덱스 구조와 탐색

수직적 탐색과정에서 모든 인덱스 구성 컬럼에 대한 필터링이 발생한다.

### ROWID 포맷

rowid에는 데이터파일 번호, 블록 번호, 로우 번호 같은 테이블 레코드의 물리적 위치정보를 포함한다.

테이블 레코드를 찾아가는 데 필요한 주소 정보이므로 테이블 자체에 저장되는 것이 아니라 인덱스에 저장된다.

인덱스를 거치지 않는 쿼리에서 rowid를 요구할 때는 데이터 블록 헤더에 저장된 오브젝트 및 데이터팡리 번호, 파일 내에서의 상대적인 블록 번호를 이용해 추론한다.

인덱스에 저장되는 rowid는 6바이트 크기를 차지하며 파일번호, 블록번호, 로우 번호로 구성된다.

오라클 8 부터는 rowid 크기를 10 바이트로 증가시켰다. 데이터베이스의 저장량이 증가함에 따라 더 많은 데이터 파일을 관리할 필요가 생겼고, 파티션 같은 기능을 지원하기 위해 오브젝트 번호까지 저장해야하기 때문이다.

rowid 를 10바이트로 늘림으로써 peta-byte 단위의 데이터를 저장할 수 있게 됐다.

아래의 경우는 rowid가 기존처럼 6 바이트 공간을 차지한다.

- 파티션되지 않은 일반 테이블에 생성한 인ㄷ게스
- 파티션된 테이블에 생성한 로컬 파티션 인덱스

아래의 경우는 10바이트를 차지한다.

- 파티션 테이블에 생성한 글로벌 파티션 인덱스
- 파티션 테이블에 생성한 비파티션 인덱스

6바이트 짜리 제한 rowid 포맷은 3개의 구성요소로 이루어진다.

- 데이터파일 번호(4) + 블록 번호 (8) + 로우번호(4)

데이터파일 번호는 로우가 속한 데이터파일의 번호로, 데이터베이스 내에서 유일한 값이다.

블록 번호는 해당 로우가 저장된 데이터 블록 번호이며, 데이터파일 내의 상대적 번호이다.

10바이트짜리 확장 rowid 포맷은 데이터 오브젝트 번호가 더해진다.

데이터 오브젝트 번호(6) + 데이터파일 번호(3) + 블록번호(6) + 로우번호(3)

애플리케이션에 출력할 때는 별도의 구분자 없이 연속된 18자리 문자열 포맷을 사용한다.
