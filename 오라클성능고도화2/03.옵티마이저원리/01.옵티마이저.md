옵티마이저는 사용자가 요청한 SQL을 가장 효율적이고 빠르게 수행할 수 있는 최적의 처리경로를 선택해주는 DBMS의 핵심엔진이다.

구조화된 질의언어로 사용자가 원하는 결과집합을 정의하면 이를 얻는데 필요한 처리절차(프로시저)는 DBMS에 내장된 옵티마이저가 자동으로 생성해준다.

옵티마이저는 크게 두 가지가 있다.

\- 규칙기반 옵티마이저 (RBO)
\- 비용기반 옵티마이저 (CBO)

### 규칙기반 옵티마이저

휴리스틱 옵티마이저라고도 불리며, 미리 정해진 우선순위에 따라 액세스 경로를 평가하고 실행계획을 선택한다.

데이터량, 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 같은 데이터 특성을 고려하지 않기 때문에 RBO는 대량 데이터를 처리하는데 비합리적일때가 많다.

인덱스 사용 효율이나 부분범위처리가능여부등을 고려하지 않은 실행계획을 세운다.

### 비용기반 옵티마이저

여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻한다. I/O 요청횟수와 CPU 연산비용을 포함한다. 그리고 수행일량을 상대적 시간 개념으로 환산해 비용을 평가한다.

비용은 예상치로 미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상비용을 산정하고,

이를 합산한 총 비용이 가장 낮은 실행게획을 선택한다.

비용 산정에 포함되는 오브젝트 통계 항목에는 레코드 개수, 불록 개수, 평균 행 길이, 컬럼 값의 수, 컬럼 값의 분포, 인덱스 높이, 클러스터링 팩터 등이 있다.

최근에는 하드웨어적 특성을 반영한 시스템 통계정보까지 지용한다.

옵티마이저의 최적화 수행단계는 다음과 같다.

1. 사용자가 던진 쿼리수행을 위해, 후보군이 될만한 실행계획을 찾는다.
2. 데이터 딕셔너리에 미리 수집해 놓은 오브젝트 통계 및 시스템 통계정보를 이용해 실행계획의 예비비용을 산정한다.
3. 각 실행계획의 비용을 비교해서 최저비용을 갖는 하나를 선택한다.

---

#### 동적 셈플링

쿼리를 최적화할 때 미리 구해놓은 통계정보를 이용하는데, 만약 테이블과 인덱스에 대한 통계정보가 너무 오래됏거나 없으면 옵티마이저는 동적으로 샘플링을 수행한다.

opitmizer_dynamic_sampling 파라미터로 동적 샘플링 레벨을 조정하며, 기본 레벨은 2이다.

쿼리 최적화 시 통계정보 없는 테이블을 발견하면 무조건 동적 샘플링을 수행한다.

레밸 0으로 설정해 동적 샘플링이 일어나지 않게 할 수 있으며, 9i 기본 값이 1로 설정되면 아래 조건을 만족할 때 동적 샘플링이 일어난다.

1. 통계정보가 수집되지 않은 테이블이 적어도 하나 이상 있고,
2. 그 테이블이 다른 테이블과 조인되거나 서브쿼리 또는 Non-mergeable View에 포함되고
3. 그 테이블에 인덱스가 없고
4. 그 테이블에 할당된 블록수가 32개보다 많을때

레벨설정은 최대 10까지 가능하다

레벨이 높ㅇ르 수록 옵티아미저는 더 적극적으로 동적 샘플링을 수행하며 샘플링에 사용되는 표본 블록의 개수도 증가한다.

동적 샘플링으로 얻은 통계정보는 데이터 딕셔너리에 영구적으로 저장되지 않는다.

통계정보가 올바르지 않는 테이블을 참조하는 쿼리는 하드 파싱할 때마다 동적 샘플링을 위한 REcursive SQL이 추가적으로 수행되므로 성능에 나쁘다.

따라서 통계저옵를 관리해야한다.

참고로 동적 샘플링이 일어날 때면 SQL 트레이스에서 아래와 같은 수직을 포함한 Recursive SQL을 발견할 수 있다.

```SQL
SELECT /_+OPT_DYN_SAMP_/ ... FROM..
```

옵티마이저를 구성하는 세 서브 엔진의 역할은 다음과 같다.

\- Query Transformer

사용자가 던진 SQL을 그대로 최적화하는 것이 아니라 우선 최적화하기 쉬운 형태로 변환을 시도한다.

변환 전후 결과가 동일함이 보장될때만 변환한다.

\- Estimator

쿼리 오퍼레이션 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로 실행계획 전체에 대한 총 비용을 계삲다.

각 단계를 수행하는데 필요한 I/O, CPU, MEMORY 사용량을 예측하기 위해 데이터베이스 오브젝트 통계정보와 하드웨어 시스템 성능 통계정보를 이용ㅎ나다.

\- Plan Generator

하나의 쿼리를 수행하는 데 필요한 실행계획 후보군을 생성하는 역할을 한다.

### 옵티마이저모드

옵티마이저모드로 선택할 수 있는 값은 아래 5가지가 있다.

\- rule
\- all_rows
\- first_rows
\- first_rows_n
\- choose

```sql
alter system set optimizer_mode = all_rows; -- 시스템 레벨 변경
alter session set optimizer_mode = all_rows; -- 세션 레벨 변경
select /*+all_rows*/ * from t where ... ; --쿼리 레벨 변경
```

#### Rule

RBO 모드를 선택할때 사용한다

#### ALL_ROWS

쿼리의 최정결과집합을 끝까지 Fetch 하는 것을 전제로, 시스템 리소스를 적게 사용하는 실행계획을 선택한다.

DML 문장은 일부만 가공하고 멈출 수 없으므로 옵티ㅁ이저모드에 상관없이 all_rows 모드로 작동한다.

select 문장도 union, minus 같은 집합 연산자나 for update 를 사용하면 all_rows 모드로 작동한다.

pl/sql 내에서 수행되는 sql 힌트도 사용자 모드가 rule 인 경우를 제외하면 항상 all_rows 모드로 작동한다.

### First_ROWS

전체 결과집합 중 일부 로우만 Fetch 하다가 멈추는 것을 전제로, 가장 빠른 응답속돌르 낼 수 있는 실행계획을 선택한다.

RBO와 CBO를 혼합한 형태의 옵티마이저 모드이다. 얼마만큼을 Fetch할지 지정하지 않았으므로 정확한 비용을 예측할 수 ㅇ벗고,

옵티마이저는 내부적으로 정해진 규치긍ㄹ 사용한다.

예를 들어 order by 컬럼에 인덱스가 있으면 Table Full Scan 비용과 비교하지 않고 무조건 그 인덱스를 이용해 sort order by 연산을 대체한다.

RBO가 가진 규칙이다.

규칙을 사용하긴 하지만 통계정보를 이용하므로 비용기반 옵티마이저에는 틀림없다.

```sql
create table t_emp
as
select * from scott.emp, (select rownum no from dual connect by level <= 1000)
order by dbms_random.value;

alter table t_emp add constraint t_emp_pk primary key(empno, no);

begin
  dbms_stats.gather_table_stats(
    ownname => user
    ,tabname => 't_emp'
    ,method_opt => 'for colums sal'
  )
end;
/

set autustats traceonly exp
select /*+all_rows*/*
from t_emp
where sal >= 5000
order by empno, no;
```

위 쿼리에서는 all_rows 모드이므로 table full scan을 하고 나서 소트 연산을 수행하는 실행계획이 수립됐다.

```sql
set autustats traceonly exp
select /*+first_rows*/*
from t_emp
where sal >= 5000
order by empno, no;
```

first_rows로 실행하면 소트 연산을 하지 않고 order by 순으로 정렬된 pk 인덱스를 사용하는 실행계획이 수립된다.

Table Full scan의 비용은 26이고 Index Full Scan의 비용은 13,900 이지만 비용보다 규칙이 우선됨을 알 수 있다.

사용자가 Fetch 도중 멈출 것이라는 가정이 이런 실행계획을 수립한 것이다.

sal> 5000을 만족하는 레코드의 비율은 전체의 7%이다.

따라서 첫 번째 Fetch 분량을 얻기까지 많은 인덱스 스캔과 테이블 엑세스를 수반하므로 first_rows가 지향한느 최초 응답속도도 생각보다 좋지 않을 수 있다.

sal 조건을 만족하는 레코드가 앞쪽에 몰려있거나, ArraySize 가 아주 작을때만 이점이 있다.

first_rows도 CBO모드 이기때문에 통계정보를 활용한다.

통계정보를 활용하여 인덱스 사용이 필요하지 않다고 판단하면 Table Full Scan으로 실행한다.

#### FIRST_ROWS_N

사용자가 청므 n개 로우만 Fetch 하는 것을 전재로, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택한다.

n으로 지정할 수 있는 값은 1,10,100,1000 네 가지며, 사용자가 지정한 N개 로우 이상을 Fetch한다면 오히려 더 많은 리소스를 사용하고 전체 수행 속도도 느려진다.

```sql
alter session set optimizer_mode = fisrt_rows_100;
select /*+first_rows(100)*/ * from t where ...;
```

힌트를 사용할 때는 괄호 안에 0 보다 큰 어떤 정수 값이라도 입력 가능하므로 파라미터를 이용할 때보다 더 정밀하게 제어할 수 있다.

first_row와 달리 first_rows_n은 완전한 CBO 모드로 작동한다.

N개의 로우를 가장 빨리 리턴할 수 있는 최저비용의 실행계획을 선택하며, Table Full Scan 비용이 오히려 낮다면 그것을 선택한다.

위 테이블에서 sal이 2000보다 큰 사원이 6천명으로 전체의 43명을 차지한다.

이때 일정량 이상을 Fetch 하는 순간 Index Range Scan이 Table Full Scan 보다 커진다.

이런 상황에서 first_rows(10) 일 때는 Index Full Scan gkekrk first_rows(100) 일때 Table Full Scan으로 바뀐다.

비용을 고려해 실행계획을 선택했음을 알 수 있다.

#### Choose

액세스되는 테이블 중 적어도 하나에 통계정보가 있다면 CBO, 그중에서도 all_rows 모드를 선택한다.

어느 테이블에도 통계정보가 없으면 RBO를 선택한다.

### 옵티마이저 모드 선택

애플리케이션에서 수행되는 쿼리 자체가 전체범위처리를 요구하기 때문에 all_rows 모드가 적합하다.

all_rows 모드는 sql 결과 집합을 모두 Fetch 하기에 가장 효율적인 실행계획을 옵티마이저에게 요구한다.

first_rows 모드가 효과적인 애플리케이션 아키택처는 주로 2-Tier 환경의 클라이언트/서버 구조다.

OLTP성 애플리케이션이더라도 3-Tier 구조는 클라이언트와 서버 간 연결성을 지속하지 않는 환경이므로 커서를 계속 유지할 수 없어

전체를 읽고 페이징 처리한다.

페이징을위해 rownum을 통해 결과집합을 10건 내지 20 건으로 제한하는 쿼리를 주로 활용한다

대량 데이터에서 일부만 Fetch 하다 멈추는게 아니라 조회하는 집합 자체를 소량으로 정의하는 것이다.
