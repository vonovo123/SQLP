### 히스토그램의 유형

히스토그램이 있으면 더 정확한 카디널리티를 구할 수 있다. 특히 분포가 균일하지 않은 칼럼으로 조회할때 효과를 발휘한다.

오라클이 사용하는 히스토그램의 유형은 두 가지 유형이 있다.

\- 높이균형 히스토그램
\- 도수분포 히스토그램

히스토그램을 생성하려면 컬럼 통계 수집 시 버킷 수를 2 이상으로 지정하면 된다.

히스토그램 정보는 dba_histograms 또는 dba_tab_histogram 뷰를 통해 확인할 수 있다.

특히 10ㅎ에서는 dba_tab_columns 뷰에 histogram 칼럼이 추가되면서 히스토그램 유형을 쉽게 파악할 수 있게 됐다.

\- FREQUENCY : 값별로 빈도수를 저장하는 도수분포 히스토그램
\- HEIGHT BALANCED : 각 버킷의 높이가 동일한 높이균형 히스토그램
\- NONE

### 도수분포히스토그램

값 별로 빈도수를 저장하는 히스토그램을 말한다.

도수분포 히스토그램은 컬럼 값마다 하나의 버킷을 할당한다.

사용자가 요청한 버킷 개수가 컬럼이 가진 값의 수보다 많거나 같을 때 사용되며 최대 254개의 버킷만 허용하므로

254개를 넘는 컬럼에는 이 히스토그램을 사용할 수 없다.

```sql
select count(*), count(distinct age) from member
```

age 컬럼이 갖는 값의 수는 89개로 254개에 못 미치므로 도수분포히스토그램을 생성할 수 있다.

```sql
begin
  dbms_stats.gather_table_stats(user, 'member', method_opt=>'for all columns size 100');
end;

select num_distinct, num_buckets, histogram
from user_tab_col_statistics
where table_name = 'MEMBER'
and column_name = 'AGE'
```

쿼리 결과에서 보듯, 도수분포히스토그램에서는 컬럼 값의 수와 버킷 개수가 항상 일치한다.

컬럼 값마다 단일 버킷을 할당하기 때문이다.

100개(size 100)의 버킷을 요청했는데 89개만 생성된 것은 실제 값의 종류가 89개뿐이기 때문이다.

254개를 요청하더라도 값의 수 만큼만 버킷을 할당하므로 정확한 히스토그램을 위해서라면 항상 254개를 요청하는 것이 좋다.

히스토그램 정보를 조회할 수 있는 dba/all/user_histograms 뷰에는 아래 두 컬럼이 있다.

\- endpoint_value : 버킷에 할당된 컬럼 값
\- endpoint_number : endpoint_value로 정렬했을때, 최소 값부터 현재값까지의 누적수량

endpoint_number가 누적 수량을 의미하므로 바로 앞 endpoint_value 까지의 누적 수량을 차감함으로써 해당 버킷의 값 빈도수를 알 수 있다.

도수분포 히스토그램은 값별로 빈도수를 미리 계산해두는 방식으로 조건절을 만족하는 카디널리티를 쉽고 정확하게 구할 수 있다.

하지만 시스템 자원의 한계로 값의 수가 많을 때는 높이균형 히스토그램을 사용한다.

### 높이균형 히스토그램

컬럼이 가진 값의 수보다 적은 버킷을 요청할때 만들어진다.

하나의 버킷이 여러 개 값을 담당한다.

요청할 수 잇는 버킷의 최대 수가 254개 이므로 값의 종류가 254개를 넘으면 무조건 이 히스토그램이 만들어진다.

높이균형 히스토그램에서는 각 버킷의 높이가 같다. 각 버킷은 1/(버킷 개수)의 데이터 분포를 갖는다.

따라서 각 버킷이 갖는 빈도수는 총례코드 수 / 버킷 개수 이다.

총 2천건이고 버킷이 20개라면 각 버킷마다 100개 레코드에 해당하는 높이를 갖는다. 분포는 각 5%씩이다.

\- endpoint_number : 버킷번호
\- endpoint_value : 버킷이 담당하는 가장 큰 값

100개의 값에 대해 20개의 버킷을 요청햇을때 20개보다 적은 수의 버킷이 히스토그램에서 조회된다.

이는 오라클이 popular value를 압축해서 저장하기 때문이다.

endpoint_number가 1인 버킷은 1~21 연령대 구간을, endpoint_number=20 버킷은 56~99 연련대 구간을 대표한다.

endpoint_numbersms 버킷 번호이므로 1씩 증가하지만 특정구간에서 더 큰 수만큼 건너 뛰는 경우가 있다.

ㅇ처럼 2칸이상 건너 뛰는 버킷은 popular value를 포함함을 의미하여 10칸을 건너뛰었다면 해당 연령대가 10개 버킷만큼의 비중을 차지함을 압축해서 표현한 것이다.

#### popilar value에 대한 선택도/카디널리티 계산

조건절 값이 두 개 이상 버킷을 가진 popular value이면 아래 공식을 따른다.

선택도 = (조건절 값의 버킷 개수) / (총 버킷 개수)

#### non-popular value에 대한 선택도 / 카디널리티 계산

미리 구해놓은 density 값을 사용한다.

카디널리티 = 총 로우 수 _ 선택도 = 총 로우수 _ density

dentisy는 해당컬럼을 = 조건으로 검색할 때의 선택도를 미리 구해놓은 값이다.

균일한 분포를 갖는다면 Density는 항상 1/num_distinct와 일치하지만 그렇지 않은 상황에서는 다른 값을 같는다.

### 바인드 변수 사용 시 카디널리티 계산해두는

바인드 변수를 사용하면, 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고 실행시점에는 그것을 그대로 가져와 값만 다르게 바인딩해 재사용한다.

변수를 바인딩하는 시점이 최적화 시점보다 나중인 실행시점이라는 사실이 중요하다.

즉, SQL을 최적화하는 시점에 조건절 컬럼의 데이터 분포를 활용하지 못한다.

바인드 변수를 사용할 때 옵티마이저는 평균 분포를 가정한 실행계획을 생성한다. 컬럼분포가 균일하지 못하면 실행 시점에 바인딩되는 값에 따라서

최적이 아닌 실행계획일 수 있다.

#### 동치조건일때

바인드 변수로 = 검색할 때 선택도는 아래와 같이 구해진다.

\- 히스토그램이 없을 때 : 1/num_distinct 사용
\- 도수분포 히스토그램일 때 : 1/num_distinct 사용
\- 높이균형 히스토그램일 때 : density 사용

#### 범위검색 조건일 때

범위검색 조건이 사용되면 옵티마이저는 고정된 규칙으로 선택도를 추정한다.

바인드 변수를 사용하면 정확한 컬럼 히스토그램에 근거하지 않고 카디널리티를 구한다.

상수조건 식을 사용한다면 거의 정확한 카더닐리티를 계산해낸다.

좋은 실행계획을 위해서라면 dw, olap, 배치 프로그램에서 수행되는 쿼리는 바인드 변수보다 상수를 사용하는 것이 좋고,

날짜 컬럼처럼 부등호, between 같은 범위 조건으로 자주 검색되는 컬럼일 때 특히 그렇다.

OLTP 성 쿼리이더라도 값의 종류가 적고 분포가 균일하지 않을 때는 상수조건을 쓰는 것이 유용하다

파티션 테이블을 쿼리할 때 파티션 레벨 통계정보를 이용하지 못하는 것도 바인드변수의 부작용이다.

### 결합 선택도

히스토그램을 많이 만들어 두어도 두 개 이상 컬럼에 대한 결합 선택도를 구할 때는 정확성이 떨어진다.

특히 조건절 컬럼간에 상관관계가 있을때 그렇다.

#### 동적 샘플링

오라클은 9i부터 동적 샘플링을 통해 문제 해결을 시도한다.

소량의 데이터 샘플링을 통해 where 조건절에 사용된 두 개 이상 컬럼의 결하 분포를 구하는 기능으로, 동적 샘풀링 레밸을 4 이상 설정할 때만 작동한다.

급여에 일괄적으로 0.1을 곱해 상여를 구했으므로 두 컬럼 간 상관관계가 매우 높지만 옵티마이저는 알지 못한다.

동적 샘플링 레벨을 4로 설정하면 옵티마이저가 카디널리티를 정확하게 계산한다.

```sql
  select /*+dynamic_sampling(4)*/ *
  from endpoint_number
  where sal >= 2000
  and bonus >= 200;
```

#### 다중 컬럼 통계

11g 부터는 확장형 통계라고 불리는 기능을 통해 다중 컬럼에 대한 히스토그램을 생성할 수 있다.

```sql
var ret varchar2(30);
exec :ret := dbms_stats.create_extened_stats(user, '사원', '(급여, 상여)');
print ret;
```

컬럼 그룹을 지우는 방법은 다음과 같다.

```sql
exec dbms_stats.drop_extended_stats(user, '사원', '(급여, 상여)');
```

dbms_stats 패키지의 gather_table_stats 프로시저 method_opt 인자를 통해서도 확장형 통계를 수집할 수 있다.

```sql
begin
  dbms_stats.gather_table_stats(user,'사원', method_opt=>'for all columns size skewonly for columns(sal,bonus) size 254')
end;
/
```
