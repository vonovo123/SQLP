옵티마이저는 완벽하지 않다. OLTP 환경에서 파싱에 허용되는 시간이 극히 짧아 적용하지 못하는 최적화 기법들도 있다.

---

#### 자동튜닝옵티마이저

오프라인 옵티마이저라고도하며 통계를 분석하고, SQL 프로파일링을 실시하며, 액세스 경로 및 SQL 구조 분석을 통해 SQL 튜닝을 실시한다.

튜닝 모드에서 작동하는 옵티마이저에게는 한 문장을 튜닝하는 데 런타입 옵티마이저보다 긴 시간이 주어진다.

넉넉한 시간동아 풍부한 정보를 수집하여 데이터 액세스 비용과 카디널리티를 보다 정확하게 계산할 수 있다.

동적 샘플링을 통해 부가적인 정보를 수집하고, 부분적인 실행을 통해 예측치를 검증함으로써 잘못된 정보를 조정하는 테크닉을 사용한다.

각 SQL 단위로 수집된 프로파일을 데이터 딕셔너리에 영구 저장해 런타입 옵티마이저가 참조할 수 있도록 하는 기능도 제공된다.

자동 튜닝 옵티마이저 기능을 활용하려면 SQL TUNING Advisor 이라 불리는 서버 유틸리티를 이용하면 된다.

내부적으로 자동 튜닝 옵티마이저를 호출해 SQL 분석을 실시한다.

분석이 완료되면 SQL 성능을 높이기 위해 사용자가 취해야 할 조치사항들을 보고서 형태로 출려해준다.

---

### 부족한 옵티마이징 팩터

적절한 인덱스가 제공되어야 옵티마이저가 고성능 실행 계획을 수립할 수 있다.

### 부정확한 통계

샘플링 방식으로 통계정보를 수집하다보니 실제 데이터와의 불일치가 발생한다.

분포가 균등하지 않은 컬럼이라면 수집할 때마다 통계치가 바뀔 수 있어 실행계획을 불안정하게 만든다.

통계 수집 주기도 매우 중요하다. 갑자기 데이터가 아주 많이 변경되거나 새로입력됐을때 재수집하지 않으면 잘못된 선택을 하게 된다.

### 히스토그램의 한계

히스토그램의 버킷 개수는 254개 까지 허용된다.

컬럼의 Distinct 수가 그 이상인 경우 높이균형 히스토그램을 사용하게 되므로 발생 빈도가 낮은 값들에 대한 정확한 분포를 반영할 수 없다.

버킷 개수를 무한정 가져갈 수 있으면 정확도가 올라가겠찌만 시간과 저장공간의 한계가 생기는 것은 어쩔 수 없다.

### 바인드 변수 사용시 균등분포 가정

옵티마이저는 조건절에 대한 선택도를 구할때 컬럼 히스토그램을 참조한다.

아무리 정확한 컬럼 히스토그램을 부유하더라도 바인드 변수를 사용한 SQL에는 무용지물이다.

옵티마이저는 바인드 변수를 사용한 SQL에 대해서는 균등분포를 가정하고 비용을 계산한다.

### 결합 선택도 산정의 어려움

조건절 컬럼이 서로 상관관계에 있으면 정확한 데이터 분포와 카디널리티를 산정하기 어렵다.

```sql
select * from emp
where rank = 'G4'
and salary >= 5000;
```

직급은 4개로 각각 25%의 비중을 갖는다. 전체 직원은 1천명이고 히스토그램상 연봉 조건에 부합하는 사원 비중이 10%이면

옵티마이저는 위 쿼리 조건에 해당하는 사원의 수를 25명으로 추정한다.

하지만 현실에서 직급과 연봉의 상관관계는 매우 높다.

히스토그램이 현실을 반영하지 못하면 다른 집홥과 여러 번 조인을 거치는 동안 카디널리티는 점점 부정확해지고 궁극적으로 옵티마이저가 잘못된

실행결과를 수립하는 결과를 낳는다.

데이터 컬럼이 많ㅇ르 수록 컬럼간의 조합이 기하급수적으로 증가하기 때문이다.

동적샘플링은 소량의 데이털르 샘플링을 통해 where 조건절에 사용된 두 개 이상 컬럼의 결합 분포를 구하는 기능으로 동적 샘플링 레밸을 4 이상으로 설정할 때만 작동한다.

### 비현실적인 가정

CBO는 쿼리 수행비용을 평가할 때 여러 가정을 사용하는데, 그 중 일부는 매우 비현실적이다.

대표적인 예로, Single block I/O와 Multiblock I/O 비용을 같게 평가한다거나 캐싱 효과를 고려하지 않는다는 점을 들 수 있다.

I/O 비용 모델 하에서 비용은 단순히 I/O Call 횟수를 의미한다.

옵티마이저가 예상할 때 I/O Call 횟수가 가장 적은 실행계획을 선택한다. 그런데 I/O 비용 모델이 사용하는 기본 가정에서 Single block REad와

Multiblock Read의 비용은 같다.

또한 옵티마이저는 다른 세션이나 다른 쿼리무에 의해 데이터 블록들이 이미 버퍼 캐시에 캐싱돼 있을 가능성을 배제한다.

비용을 평가할 때 디스크 I.O Call 횟수만을 더하는 것을 통해 이 사실을 알 수 있다.

즉, 옵티마이저는 메모리 자원에 대해 최악의 상황을 가정하고 비용을 산정하는 것이다.

### 규칙에 의존하는 CBO

비용기반 옵티마이저라고 하더라도 부분적으로 규칙에 의존한다.

원격 테이블이나 External 테이블에 대해서는 카디널리티, 평균 행 길이, 블록 수, 각종 인덱스 관련 통계항목들에 대해 고정 상수 값을 사용한다.

옵티마이저 모드를 first_rows로 설정했을 때 order by 소트를 대체할 인덱스가 있으면 무조건 인덱스를 사용하는 것도 그 예이다.

9i까지 뷰 또는 서브쿼리를 만나면 무조권 쿼리 블록을 풀어 메인 쿼리와 Merging 하려고 시도하는 것도 예이다.

#### 알파벳순 인덱스 선택 규칙

두 대안 인덱스의 예상비용이 같다면 알파벳 순에서 앞선 것을 선ㅌ낵한다. 물리 데이터베이스 설계단계에서 인덱스 명명 규칙이 매우 중요하다.

적어도 unique 한 조건으로 pk 인덱스를 액세스해야하는 상황이라면 명명규칙은 PK, X01, X02 같은 식으로 정하는 것이 좋다.

### 하드웨어 성능 특성

옵티마이저는 개발시 사용한 하드웨어 사양에 맞춰져 있다. 따라서 실제 운영 시스템의 하드웨어 사양에 따라 잘못된 실행계획을 수립할 가능성이 높아진다.

또한 애플리케이션 특성에 의해서도 하드웨어 성능은 달라진다.

시스템 통계를 통해 이 문제를 해결할 수 있다.

---

#### 동적 실시간 최적화

모든 데이터베이스의 작업 부하는 가변적이다.

따라서 하드웨어 성능 특성을 반영한 실행계획을 수립하더라도 퀴리 수행 당시 시스템 부하 정도에 따라 최적이 아닐 수 있다.

정적인 통계정보와 옵티마이저 모델로는 이런 한계점을 극복하기 어려우므로 시스템 부하에 따라 실행전략을 동적으로 조정하는 기법이 도입되고 잇따.

쿼리가 수횅되는 시점의 시스템 상태에 따라 하드웨어 리소스를 적절히 분배해준다.

대표적으로, 시스템 부하 정도에 따라 병렬 쿼리의 프로세스 개수를 오라클이 동적으로 조절해주는 기능이 있다.

PGA 메모리 크기를 자동으로 조절해주기 시작했고, 10g 부터는 SGA를 구성하는 서브 메모리 영역을 자동으로 조절해 주는 기능도 있다.

이런 기능을 통해 전체 SQL의 처리량을 극대화 할 수 있다.

쿼리 최적화가 단일 SQL 문 성능을 최적화 하는데 초점을 맞춘 반면, 동적 실시간 최적화는 수 많은 SQL이 동시에 수행되는 환경에서 시스템 전체 최적화를 목표로한다.

---
