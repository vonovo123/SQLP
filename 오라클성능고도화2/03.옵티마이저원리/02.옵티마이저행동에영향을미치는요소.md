옵티마이저행동의 차이는 실행계획의 차이를 의미한다.

실행계획에 영향을주는 요소는 다음과 같은 것들이 있다.

1. sql과 연산자 형태
2. 인덱스, IOT,클러스터링, 파티셔닝, MV 등 옵티마이징 팩터
3. 제약설정 : pk, fk, not null, check
4. 옵티마이저 힌트
5. 통계정보 : 오브젝트 통계, 시스템 통계
6. 옵티마이저관련파라미터
7. DBMS 버전과 종류

### SQL 연산자 형태

쿼리결과가 같더라도 sql을 어떤 형태로 작성했는지 또는 어떤 연산자를 사용했는지에 따라 다른 선택을 할 수 있다.

궁극적으로 쿼리 성능에 영향을 미친다.

### 옵티마이징 팩터

옵티마이징 팩터 구성 여부에 따라 실행계획가 성능이 크게 달라진다.

### 제약설정

- 개체 무결성
- 참조 무결성
- 도메인 무결성
- 사용자 정의 무결성

제약설정은 데이터 무결성 보장 뿐아니라 옵티마이저가 쿼리 성능을 최적화하는 데에 중ㅛ한 정보를 제공한다.

#### PK 제약과 옵티마이저

```sql
-- 가입 후 1년이 넘지 않은 고객의 지난 한 달간 주문실적 조회
select sum(주문수량), sum(주문금액), count(*) count(distinct 고객번호)
from 주문
where 고객번호 in (
  select 고객번호
  from 고객
  where 가입일자 >= trunc(add_months(sysdate, -12))
)
and 주문일자 >= trunc(add_months(sysdate, -1))
```

서브쿼리를 Unnesting 하고서 고객 테이블을 기준으로 NL 조인하려 할 때, 만약 고객 테이블에 PK 제약이 없다면

고객번호 중복을 제거하는 sort unique 오퍼레이션을 먼저 수행해야 한다.

실제 고객번호에 중복 값이 없더라도 옵티마이저에게 그런 사실을 알려주지 않으면 소용이 없다.

또 다른 예로 수정 가능한 조인 뷰가 있는데, 이 기능이 작동하려면 조인되는 1쪽테이블에 PK 제약이 있어야 한다.

#### FK 제약과 옵티마이저

FK 제약이 있을 때만 작동하는 기능들이 여럿 있는데 Reference 파티셔닝 기능이 대표적이다.

#### Not Null 제약과 옵티마이저

```sql
select deptno, count(*) from emp group by deptno;
```

옵티마이저가 이 쿼리를 최적화 할 때 deptno 컬럼에 인덱스가 있으면 index full scan 또는

index fast full scan으로 빠르게 처리할 수 있다.

하지만 deptno 컬럼에 not null 제약이 있어야 가능한 일이다.

제약이 설정되지 않으면 옵티마이저s는 Null이 입력될 가능성을 염두에 두고 실행계획을 수립해야하므로 테이블 전체를 스캔해야 한다.

실제 null이 없더라도 제약을 통해 알려주지 않으면 소용이 없다.

#### Check 제약과 옵티마이저

emp 테이블 sal 칼럼에 도메인 제약을 설정할 수 있다.

```sql
alter table emp modify sal check (sal <= 5000);
```

그러먼 옵티마이저도 쿼리를 최적화 할 때 이 저보를 화용한다.

도메인 제약에 맞지 않는 조건으로 조회하면 filter 조건을 추가해 불필요한 I.O가 수행되지 않도록 한다.

### 옵티마이저 힌트

옵티마이저는 아래의 경우가 아니면 사용자가 지정한 힌트를 가장 우선적으로 따른다.

1. 문법적으로 맞지 않게 힌트 기술
2. 잘못된 참조 사용
3. 의미적으로 맞지 않게 힌트 기술
4. 논리적으로 불가능한 액세스 경로
5. 버그

위 경우에 해당하지 않는 한 옵티마이저는 기본적으로 힌트의 내용을 먼저 따르고 남은 부분만을 자신의 판단에 따라 최적화한다.

즉, 옵티마이저는 힌트를 선택 가능한 옵션 정도로 여기는 것이아니라 명령어로 인식한다.

예를 들어 ordered 힌트를 사용하면 옵티마이저는 모든 순서를 고려하지 않고 사용자가 지정한 순서로만 실행계획 후보군을 선정하고 비용을 계산한다.

옵티마이저 힌트에 관한 일반적인 사용 원칙은 다음과 같다.

1. 가급적 힌트 사용을 자제하고, 옵티마이저가 최적의 선택을 하도록 돕는다.
2. 옵티마이저가 잘못된 선택을 할 때만 힌트를 사용한다.

힌트를 사용하지 않으면 데이터 특성 변화에 따라 실행계획이 유연하게 바뀔 수 있는 장점이 잇지만 그런 유연성은 오히려 비효율을 불러올 수 있다.

### 통계정보

CBO의 판단 기준은 통계정보이다.

통계정보가 없으면 작동하지 않는 기능들이 많다.

### 옵티마이저 관련 파라미터

오라클 버전에 따라 파라미터가 추가되거나 설정값이 바뀌면 다르게 작동하는 경우가 있다.

옵티마이저의 행동 변화는 대개 긍적적인 방향으로 작용하지만 그렇지 못한 기능들로 인해 hidden 파라미터가 필요하다.

만약 옵티마이저의 갑작스러운 변화를 원치 않는다면 optimizer_features_enable 파라미터를 이전 버전으로 설정하면 된다.

```sql
alter system set optimizer_features_enable = '9.2.0.4'
```

### DBMS 버전과 종류

파라미터와 상관없이 버전에 따라 다른 실행계획을 수립하는 경우도 있다.

적용했을때 좋은 성능을 보장하면 굳이 그 기능을 off 시킬 필요가 없다.

예를들어 컬럼의 max값을 구하기위해선 사용하면 오라클 구버전에서는 index_desc 힌트와 rownum 조건을 사용해야 했다.

```sql
select /*+ index_desc(emp emp_pk)*/ empno from emp where rownum = 1;
```

오라클 8 버전 이상부터는 Max 함수를 사용하면 옵티마이저가 알아서 위와 같은 처리를 한다.

다만 해당 오브젝트에 대한 통계정보가 수집돼 있어야 한다.

통계정보가 없다면 옵티마이저는 Index Full Scan 한다.

M쪽 집합을 기준으로 1쪽 집합과 outer 조인하면 결과건수는 M쪽 집합으로 고정된다.

따라서 조인 조건 외에 어디에도 1쪽 집합을 참조하지 않는다면 조인 엑세스를 하지 않아도 된다.

물론 1쪽 테이블 조인 컬럼에 pk가 설정돼 있어야 가능ㅎ다ㅏ.

하지만 오라클 10g 옵티마이저는 Pk를 통해 두 집합간 카디널리티 정보를 얻을 수 있더라도 무조건 1쪽 집합과 조인 액세스를 수행한다.

```sql
select e.empno, e.ename, e.sal, e.hiredate
from emp e, dept d
where d.deptno(+) = e.deptno

--- NESTED LOOPS OUTER
--    TABLE ACCESS FULL EMP
--    TABLE ACCESS SCAN DEPT_PK
```

오라클 11에서는 아래와 같이 개선됐다.

```sql
select e.empno, e.ename, e.sal, e.hiredate
from emp e, dept d
where d.deptno(+) = e.deptno

--- NESTED LOOPS OUTER
--    TABLE ACCESS FULL EMP₩
```
