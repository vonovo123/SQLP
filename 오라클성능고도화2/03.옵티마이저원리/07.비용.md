옵티마이저가 사용하는 비용 모델에는 I/O 비용 모델과 CPU 비용 모델 두 가지가 있다.

I/O 비용 모델은 예상 I/O 요청 횟수만을 쿼리 수행 비용으로 간주해 실행계획을 평가하는 반면 CPU 비용 모델은 시간 개념을 더해 비용을 산정한다.

비용 모델을 선택할 때 사용하는 파라미터는 \_optimizer_cost_model이고, 아래 세 가지 옵션이 제공된다.

\- IO : I/O 비용 모델
\- CPU : CPU 비용 모델
\- CHOOSE : 시스템 통계가 있으면 CPU 비용 모델, 없으면 I/O 비용 모델

기본 값은 Choose이고 ,9i에서는 기본적으로 시스템 통계를 갖지 않으므로 관리자가 시스템 통계를 생성해 줄 때만 CPU 비용 모델 방식으로 작동한다.

10g에서는 관리자가 workload 시스템 통계를 생성하지 않더라도 CPU 비용 모델이 선택되도록 하려고 noWorkLoad 시스템 통계를 추가로 도입했다.

아래 두 힌트를 이용하면 쿼리 레벨로도 비용 모델을 선택할 수 있다.

\- cpu_costing
\- no_cpu_costing

### I/O 비용 모델

비용은 dist I/O Call 횟수이다.

논리적/물리적으로 읽은 블록 개수가 아닌 I/O Call 횟수를 의미한다.

#### 인덱스를 경유한 테이블 액세스 비용

인덱스를 경유한 테이블 액세스 시에는 single block i/o 방식이 사용된다. 디스크에서 한 블록을 읽을 때마다 한 번의 i/o call을 일으키는 방식이므로

읽게될 물리적 블록 개수가 액세스 비용과 일치한다.

```sql
create table t as select * from all_objects;

create index t_owner_idx on t(owner);

begin
  dbms_stats.gather_table_stats(user, 'T', method_opt => 'for all columns size 1');
end;
/

alter session set "\_optimizer_cost_model" = 10;

set autotrace traceonly exp;
select /*+index(t)*/
*
from t where owner = 'SYS'

```

옵티마이저가 산정한 쿼리 수행 비용은 인덱스 스캔 단계에서 6, 테이블 엑세스 단계까지 포함해 70이다.

인덱스 스캔 단계에서 6번, 테이블 액세스 단계에서 64 번의 single block i/o 가 발생할 것으로 옵티마이저가 예상했다는 뜻이다.

인덱스 단계에서 카디널리티 즉, rows가 2,385 이므로 그만큼 테이블 Random Access가 발생해야하는데 I/O Call이 64번 뿐인 이유는

클러스터링 팩터가 비용 계산식에 고려돼있기 때문이다.

비용 = blevel +
(리프 블록 수 \* 유효 인덱스 선택도) +
(클러스터링 팩터 \* 유효 테이블 선택도)

\- blevel은 브랜치 래벨을 의미하며, 리프 블록에 도달하기 전에 읽게 될 브랜치 블록의 수.

\- 유효 인덱스 선택도 : 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율,
리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧 방문할 리프블록비율이다.

\- 유효 테이블 선택도 : 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율.
클러스터링 팩터는 인덱스를 경유해 전체 로우를 액세스할 때 읽힐 것으로 예상되는 테이블 블록의 개수이므로 여기에 유효 테이블 선택도를 곱합으로써
조건절에 대해 읽힐 것으로 예상되는 테이블 블록 수를 구할 수 있음.

유효 인덱스 선택도는 인덱스 Accesss Predicate에 의해 결정된다.

유효 테이블 선택도는 인덱스 Access Predicate와 Filter Predicate에 의해 결정된다.

테이블 액세스 후 최종 선택도는 테이블 filter Predicate 까지 포함한 모든 조건절에 의해 결정된다.

최종 테이블 선택도 : 테이블 Filter Predicate까지 포함한 모든 조건절에의해 결정

조건절이 아래와 가틍ㄴ 형태가 아니라면 인덱스 컬럼에 대한 조건절은 모두 인덱스 Access Predicte 에 포함된다.

아래 경우에만 인덱스 Access Predicate와 인덱스 Filter Precidate가 다르다.

\- 좌변 컬럼을 가공한 조건절
\- 왼쪽 % 또는 양쪽 % 기호를 사용한 Like 조건절
\- 같으 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 다른 조건절

결합선택도는 각 조건절 컬럼의 선택도를 곱해서 구함로 결론적으로, SQL이 위 조건절을 포함하는 경우를 제외하면 유효 인덱스 선택도와 유효 테이블 선택도는 항상 같다.

선택도는 Num_distinct 컬럼 통계를 이용해 구한다. 브랜치 레벨과 리프 블록 수, 클러스터링 팩터는 모두 인덱스 통계를 통해 얻을 수 있다.

#### FULL SCAN에 의한 테이블 액세스 비용

테이블을 FULL SCAN 할 때는 HWM 아래쪽 블록을 순차적으로 읽어들이는 과정에서 발생하는 I/O call 횟수를 비용으로 계산한다.

FULL SCAN할 때는 한 번의 I/O 로서 여러 블록을 읽어들이는 Multiblock I/O 방식을 사용하므로 이론적으로는 총 블록 수를

db_file_multiblick_read_count 파라미터로 나눈 만큼 I/O 가 발생해야한다. 하지만 내부적을 ㅗ저장된 값으로 비용을 계산하기 때문에

실제 테스트를 해보면 예상치와 정확히 일치하지 않는다.

그렇더라도 multiblock I/O 단위를 증가시킬수록 I/O call 획수가 줄고 예상비용도 준다.

#### I/O 비용 모델의 비현실적인 가정

디스크 I/O call 횟수로써 테이블 액세스 비용을 평가하는데는 두 가지 중요한 의미가 내포돼 있다.

\- Single block I/O와 Multiblock I/O 비용이 같다.
\- 캐싱효과를 전혀 고려하지 않는다.

이를 보정하기 위한 두 파라미터가 오라클 8버전부터 제공된다.

#### optimizer_index_cost_adj

인덱스 탐색 비용을 조정하고자 할 때 사용하며, 설정할 수 있는 값의 범위는 1~10000 이다.

기본 값인 100은 한 번의 I/o Call을 통해 Single block Read 한 블록을 읽는 비용과 Multiblock Read 방식으로 여러 블록을 읽는 비용을 같게 평가하라는 뜻이다.

만약 이 값을 25로 변경하면 Single Block Read 방식의 비용을 Multiblock Read 방식의 25%로 간주한다.

일반적으로 SBR는 인덱스를 경유한 테이블 액세스 시에 사용되고, MBR은 Full Table Scan시 사용한다.

따라서 이 파라미터는 인덱스를 경유할 때의 물리적 I/O 비용을 Full Table Scan할 때의 물리적 I/O비용과 대비한, 상대적비용을 표현한 것이다.

이 값을 낮게 설정할수록 옵티마이저는 테이블 스캔보다 인덱스를 이용한 엑세스를 더 선호한다.

#### optimizer_index_caching

옵티마이저는 NL 조인 시 Inner 테이블 쪽 인덱스 블록을 매번 디스크에서 읽는다고 가정한다.

이는 비현실적인 가정으로 특히 작은 테이블일때 배부분 캐싱된 블록을 읽는다.

optimizer_index_caching은 nl 조인에서 inner 쪽 인덱스 블록이 캐싱돼 있을 가능성을 알려주는 파라미터이며,

In-List Iterator 방식으로 인덱스를 탐색할때 읽게되는 인덱스 블록 액세스 비용에도 영향을 미친다.

값을 높게 설정(최대 100) 할 수록 옵티마이저는 인덱스를 이용한 Nl 조인을 선호한다.

### CPU 비요 모델

아래는 블록 I/O가 소량임에도 쿼리 수행 시간이 상당히 오래 걸리는 경우이다.

\- 해시 조인할 때, 해시 체인에 달린 레코드가 많아서 해시 체인을 스캔한느 부하가 심할때
\- 캐싱된 블록을 반복적으로 읽는데, 한 블록 내에서 매번 비효율적으로 많은 레코드를 스캔할때
(예를 들어 nl 조인 inner 쪽 인덱스 선두 컬럼이 between 조건일때)

\- 버퍼를 Pin한 상태에서 같은 블록을 반복 액세스할 때
\- 다량의 레코드를 읽으면서 건건이 여러 개의 사용자 정의함수를 반복 호출할 때
\- 메모리 소트를 반복할 때
\- 조건절 개수가 아주 많을때
\- 조건절이나 select-list에 연산 집약적인 작업을 많이 포함할 때

이에 오라클은 쿼리 수행에 필요한 I/O 뿐아니라 예상되는 CPU 리소스 사용량까지 비용산식에 포함해 새로운 비용 모델, 이른바 CPU 비용모델을 계산한다.

CPU 비용 모델에서 비용계산식은 다음과 같다.

(
Single block I/O 요청횟수 _ Single block I/O 에 소요되는 시간 +
multi block I/O 요청횟수 _ multi block I/O 에 소요되는 시간 +
쿼리 수행에 필요한 CPU 사이클 수 / 초당 cpu 사이클 수
) / Single block I/O 에 소요되는 시간

#### I/O 비용

Single block I/O 요청횟수와 Multi block I/O 요청횟수에 평균 소요시간을 곱합으로서 일량을 시간으로 표현한다.

이를 통해 인덱스 스캔에 의한 테이블 액세스 비용과 테이블 스캔 비용간의 상대적인 시간차이를 계산식에 포함한다.

#### CPU 비용

CPU 비용은 예산 CPU 사이클 수를 초당 처리할 수 있는 사이클 수로 나눈 값이다.

쿼리 수행에 필요한 예상 CPU 사이클 수에는 순수한 CPU 연산 비용과 버퍼 캐시에서 데이터를 읽는 cpu 비용까지 포함한다.

아이오 시간과 씨피유 연산 시간을 더한 시간 개념을 빌어 쿼리 수행 비용을 평가하는 것이 핵심이다.

이를 싱글블록 아이오 평균 소요 시간으로 나눔으로써 싱글블록 아이오 에 소요되는 시간과의 상대적인 시간 비용으로 표현한다.

총 예상 수행 시간을 싱글블록아이오 시간단위로 표현한것이다.
