조인 순서에 따라 쿼리 수행 성능이 달라질 수 있다.

총 레코드 수가 10만건인 테이블과 3건인 테이블을 nl 조인하려한다. 양쪽 모두 조인 컬럼에 대한 인덱스를 갖고 있다.

#### 필터 조건이 없을 때

10만건인 테이블을 드라이빙하는 경우 3건인 테이블의 인덱스로 조인 엑세스할 때 10만번의 Random Access가 발생한다.

3건인 테이블로 엑세스할 때 다시 10만 번의 Random Access가 발생한다.

총 20만 번의 Random Access가 발생한다.

반대의 경우 작은 테이블에서 큰 테이블의 액세스로 조인을 시도할때 3번의 Random Access 가 발생한다.

고객 테이블을 액세스할 때는 10만 번의 Random Access가 발생 해, 총 10만 3번의 Random Accessrk 발생한다.

즉, 다른 필터 조건이 없는 상황에서는 작은 쪽 집합을 드라이빙하는 것이 유리하다.

#### 필터조건이 있을 때

큰 테이블에 인덱스 필터조건이 있고 조건에 해당하는 레코드가 1만건인 경우로 가정한다.

큰 테이블을 먼저 드라이빙 하는 경우, 큰 테이블의 인덱스에서 테이블로 엑세스할때 1만번,

작은 테이블의 인덱스로 1만번, 작은 테이블의 인덱스에서 1만번 총 3만번의 Random Access가 발생한다.

반대의 경우, 작은 테이블에서 큰 테이블의 인덱스로 3번, 큰 테이블의 인덱스에서 테이블로 1만번 총 1만 3번의 RandomAccess가 발생한다.

이처럼 조인 조건 외에 필터 조건이 있을 때는 인덱스 구성에 따라 유/불리가 결정되며, 비효율이 없게 인덱스를 잘구성해주면 작은 쪽을 먼저 드라이빙하는 것이 유리하다.

nl 조인에서는 Random Access 발생량 외에도 Inner쪽 인덱스 구성 및 조건절 연산자 형태에 따라 성능이 크게 좌우된다.

#### 소트머지 조인과 해시조인의 경우

소트머지조인은 PGA 상 정렬된 집합을 통해 조인 액세스가 일어나기 때문에 Random Access 발생량보다는 소트 부하에 의해 성능이 결정된다.

디스크 소트가 발생할 정도의 큰 테이블을 포함할 때는 큰 테이블을 드라이빙하는것이 빠르지만 매모리 소트 방식이라면 작은쪽 테이블을 드라이빙하는 것이 좀 더빠르다.

해시조인은 Hash Area에 Build Input을 모두 채워야 하므로 작은 쪽을 드라이빙하는 것이 유리하다.

#### 세 개 이상 테이블에 대한 조인문 기술시 주의사항

조인 컬럼에 대한 상수나 변수 조건은 조인문을 타고 다른테이블 조건으로도 전이된다.

하지만 조인문 자체는 그런 작용이 일어나지 않으므로 세 개 이상 테이블에 대한 조인문을 기술할 때는 세심한 주의가 필요하다.

A,B간의 조인 조건, B,C간의 조인조건을 이용해 A,C 간의 조인 조건이 내부적으로 생성됐다면, 조인 순서가 어떻게 결정되더라도 효과적으로 수행할 수 있다.

하지만 조인 조건은 전이가 이루어지지 않으므로 최적의 조인순서를 결정하고 그 순서에 따라 조인문을 기술해주는 것이 중요하다.
