병렬 처리란, SQL문이 수행해야 할 작업의 범위를 여러 개의 작은 단위로 나누어 여러 프로세스 또는 스레드가 동시에 처리하는 것을 말한다.

여러 프로세스가 동시에 대용량 데이터를 처리하므로 수행 속도가 극적으로 향상된다.

### Query Coorinator와 병렬 서버 프로세스

Query Coorinator(이하 QC)는 병렬 SQL문을 발행한 세션을 말하고, 병렬 서버 프로세스는 실제 작업을 수행하는 개별 세션을 말한다.

QC의 역할은 다음과 같다.

병렬 SQL이 시작되면 QC는 사용자 지정 병렬도와 따라 오퍼레이션 종류에 따라 하나 또는 두 개의 병렬 서버 집합을 할당한다.

서버풀로부터 필요한 만큼 서버 프로세스를 확보하고, 부족분은 새로 생성한다.

QC는 각 병렬 서버에 작업을 할당한다.

QC는 각 병렬 서버로부터의 산출물을 통합하는 작업을 수행한다.

병렬로 처리하도록 사용자가 지시하지 않은 테이블은 QC가 직접 처리한다.

예를 들어 테이블을 직렬로 읽어 병렬 서버에 전송하는 오퍼레이션을 QC가 수행하는 식이다.

QC는 각 병렬 서버로부터 산출물을 톱합한다. 각 병렬 서버는 자신의 처리 범위 내에서 집계한 값을 QC에 전송하면 최종 집계 작업을 수행한다.

QC는 쿼리의 초종 결과집합을 사용자에게 전송한다. DML 일 때는 갱신 건수를 집ㅎ계하여 전송한다.

쿼리 결과를 전송하는 단계에서 수행되는 스칼라 서브쿼리도 QC가 수행한다.

```sql
select /*+ordered use_hash(d) full(d) full(e) noparalle(d) parallel(e 4)*/
count(*), min(sal), max(sal), avg(sal), sum(sal)
from dept d, emp e
where d.loc = 'CHICAGO'
and e.deptno = d.deptno

-- SELECT STATEMENT
--  SORT AGGREGATE
--    PX COODINATOR
--      PX SEND QC (RAMDOM)
--        SORT AGGREGATE
--          HASH JOIN
--            BUFFER SORT
--              PX RECEIVE
--                PX SEND HASH
--                  TABLE ACCESS FULL DEPT
--            PX RECEIVE
--              PX SEND HASH
--                PX BLOCK ITERATOR
--                  TABLE ACCESS FULL EMP
```

### INTRA-OPERATION PARALLELISM 과 INTER_OPERATION PARALLELISM

```sql
select /*+full(고객) parallel(고객 4)*/
*
from  고객
order by  고객명
```

order by를 포함하는 병렬 쿼리를 8개의 병렬 프로세스로 수행하는 과정은 크게 두 가지로 나눠볼 수 있다.

- 8개의 병럴서버가 각자의 것을 정리하고 나중에 하나의 처리프로세스에 전송해 최종적으로 머지하는 것.

- 4개 씩 두개 조로 나누고 한 조는 분배, 한 조는 정렬을 하는 것.

두 번째 방법에서 정렬팀은 알파벳 순으로 각자 처리할 연속된 범위를 지정받는다.

분배팀은 QC로 부터 할당받은 레코드를 값에 따라 정해진 정렬 담당서버에 건낸다.

정렬 서버는 4개의 분배서버로 부터 건네받은 레코드만 정렬하면 된다.

정렬된 각 묶음을 QC가 받아 버지하면 모든 레코드가 정렬된다.

첫 번째 방법은 작업서버가 많을 수록 머지단계에 부하가 크다. 그렇기에 오라클은 Order by를 병렬로 처리할 때 두 번째 방식을 사용한다.

이때 서로 배타적인 범위를 독립적으로 동시에 처리하는 것을 Intra-Operation Parallelism 이라고 한다.

4개의 서버가 할당받은 레코드를 하나씩 정렬조로 분배하는 작업과, 전달받은 명함을 정렬하는 작업이 모두 여기에 해당한다.

같은 업부의 서버 집합끼리는 데이터를 주고받을 일이 없다.

반면, 레코드를읽어 상대 조에 분배하거나 정렬된 결과를 QC에 전송하는 작업을 병렬로 동시에 진행하는 것을 Inter-Operation Parallemlism 이라고 한다.

### 테이블 큐

Intra-Operation Parallelism은 하나의 병렬버서 집합에 속한 여러 프로세스가 처리 범위를 달리하면서 병렬로 작업을 진행하는 것으로 프로세스 간 통신이 발생하지 않는다.

반면, Inter-Operation Parallism은 프로세스 간 통신이 발생하기 때문에 통신 체널이 필요하다.

쿼리 서버 집합 또는 QC와 쿼리 서버 집합 간 데이터 전송을 위해 연결된 통신을 위한 파이프 라인을 테이블 큐라고 한다.

테이블 큐에 부여된 이름을 테이블 큐 식별자라고 한다.

```sql
select /*+ordered use_hash(e) full(d) noparallel(d) full(e) parallel(e 2)*/
*
from dept d, emp e
where d.deptno = e.deptno
order by e.ename
```

쿼리 서버 집합 간 (P-P) Inter-Operation Parallelism이 발생할 때는 사용자가 지정한 병렬도의 배수만큼의 서버 프로세스가 필요하다.

테이블 큐에는 병렬도의 제곱 만큼의 파이프 라인이 필요하다. 병렬도가 4라면 8개의 서버 프로세스르 위해 16개의 파이프 라인이 필요하다.

#### 생산자/소비자 모델

테이블 큐에는 생산자와 소비자가 존재한다. 처음 Dept 테이블을 읽어 분배하는 테이블 큐(:TQ10001)에서는 서버 집합 1이 QC가 생산자, 서버 집합 1이 소비자이다.

테이블 큐(:TQ10001) 에서는 서버 집합 1이 생산자가 되고 서버집합 2가 소비자가 된다.

마지막으로, 정렬된 최종 결과집합을 전송하는 :TQ100002에서는 서버 집합 2가 생산자가 되고 QC는 소비자가 된다.

select 문에서 최종 소비자는 항상 QC이다.

Inter-Operation PArallelism이 나타나면, 소비자 서버 집합은 from 절에 테이블 큐를 참조하는 sub SQL을 가지고 작업을 수행한다.

#### 병렬 실행계획에서 생산자와 소비자 식별

실행계획 상 생산자에 PX SEND, 소비자에 PX RECEIVE가 표시되므로 테이블 큐를 통한 데이터 분배 과정을 쉽게 확인할 수 있다.

1. QC가 dept 테이블을 읽어 첫 번째 서버 집합(Q1,01)에 전송한다.
2. 첫 번째 서버집합은 emp 테이블을 병렬로 읽으면서 QC에게서 받아 둔 dept 테이블과 조인한다. 조인에 성공한 레코드는 바로바로 두 번째 서버 집합 Q1,02로 전송한다.
3. 두 번째 서버 집합은 전송받은 레코드를 정렬하고 QC로 전송한다.

생산자로부터 소비자로 데이터 재분배가 일어날 때마다 Name 컬럼에 테이블 큐가 표시된다.

### IN-OUT 오퍼레이션

실행계획의 뒤에서 두 번째 테이블 큐를 통해 in-out 오퍼레이션을 확인 할 수 있다.

#### S->P : PARALLEL_FROM_SERIAL

QC가 읽은 데이터를 테이블 큐를 통해 병렬 서버프로세스에게 전송하는 것이다.

#### P->S : PARALLEL_TO_SERIAL

각 병렬 서버 프로세스가 처리한 데이터를 QC에게 전송하는 것을 의미한다.

병렬 프로세스로부터 QC로 통신이 발생하므로 Inter-Operation Parallelism에 속한다.

반대로 S-P로 발생하는 통신은 QC로 부터 병렬프로세스로 발생하는 통신으로 병렬 오퍼레이션이 아니므로 Inter-Operation PArallelism에 속하지 않는다.

PQ Distrib 컬럼에 QC(ORDERED)라고 표현되는데 이는 QC에게 결과 데이터를 전송할 때 첫 번째 병렬 프로세스로부터 마지막 병렬 프로세스까지 순서대로 진행함을 의미한다.

SQL이 Order by 절을 포함할 때 나타난다. 없으면 QC(RANDOM) 이라고 표시되며 병렬 프로세스들이 무순위로 QC에게 데이터를 전송한다.

#### P->P : PARALLEL_TO_PARAKLLEL

데이터를 재분배하는 오퍼레이션으로 해당 오프레이션을 두 개의 서버 집합이 처리한다.

따라서 사용자가 지정한 병렬도의 2배수만큼의 병렬 프로세스가 필요하다.

데이터를 정렬 또는 그룹핑 하거나 조인을 위해 동적으로 파티셔닝할 때 사용되며, 첫 번째 병렬 서버집합이 읽거나 가공한 데이터를 두 번째 병렬 서버 집합에 전송하는 과정에서

병렬 프로세스간 통신이 발생하므로 Inter-Operation Parallelism에 속한다.

#### PCWP : PARALLEL_COMBINED_WITH_PARENT

한 서버 집합이 현재 스텝과 그 부모스텝을 모두 처리함을 의미한다.

예를 들어 인덱스를 스캔하면서 테이블을 액세스하는 일련의 오퍼레이션을 한 서버 집합이 처리한다.

PCWP도 병렬오퍼레이션이지만 한 서버 집합 내에서는 프로세스 간 통신이 발생하지 않으므로 INtra-Opertaion Parallelism에 속한다.

한 서버 집합에 속한 서버 프로세스들이 각자 맡은 범위 내에서 두 스텝 이상의 오퍼레이션을 처리한다.

자식 스템의 처리 결과를 부모 스텝에서 사용할 뿐 프로세스 간 통신은 발생하지 않는다.

#### PCWC : PARALLEL_COMBINED_WITH_CHILD

한 서버 집합이 현재 스텝과 그 자식 스텝을 모두 처리한다. 프로세스 간 통신이 발생하지 않으므로 Intra-Operation Parallelism이 다.

자식 스탭의 처리 결과를 받아 현재 스텝의 입력값으로 사용한다.

- S-P, P-S, P-P는 프로세스 간 통신이 발생한다.
- PCWP와 PCWC는 프로세스 간 통신이 발생하지 않으며, 병렬 서버가 독립적으로 여러 스텝을 처리할 때 나타난다. 하위 스텝의 출력 값이 상위 스텝의 입력값으로 사용된다.
- P-P, P-S, PCWP, PCWC는 병렬 오퍼레이션인 반면 S-P는 직렬오퍼레이션이다.

병렬 쿼리 실행계획에 S-P가 나타나면 해당 오퍼레이션이 병목 지점인지 의심해볼 필요가 있다.

### 데이터 재분배

데이터 재분배 방식에는 5가지가 있다.

#### RANGE

order by 또는 sort group by 를 병렬로 처리할 때 사용한다.

정렬 작업을 맡은 두 번째 서버 집합이 첫 번째 서버 집합의 정해진 프로세스에게 정렬 키 값에 따라 분배하는 방식이다.

QC는 각 서버 프로세스에게 작업 범위를 할당하고 정렬 작업에는 직접 참여하지 않으며, 정렬이 완료되고 나면 순서대로 결과를 받아 사용자에게 전송하는 역할만 한다.

#### HASH

조인이나 hash group by를 병렬로 처리할 때 사용된다.

조인 키나 group by 값을 해시 함수에 적용하고 리턴된 값에 따라 데이터에 분배하는 방식이며, P-P 뿐 아니라 S-P 방식으로 이루어질 수 있다.

#### BROADCAST

QC 또는 첫 번째 서버 집합에 속한 프로세스들이 각각 읽은 데이터를 두 번째 서버 집합에 속한 모든 병렬 프로세스에게 전송하는 방식이다.

병렬 조인에서 크기가 매우 작은 테이블이 있을 때 사용되며, P-P 뿐 아니라 S-P 방식으로도 이루어진다.

#### KEY

특정 컬럼을 기준으로 테이블 또는 인덱스를 파티셔닝할 때 사용하는 분배 방식으로 실행계획에는 PARTITON KEY로 표시된다.

#### ROUND-ROBIN

파티션 키, 정렬 키, 해시 함수 등에 의존하지 않고 반대편 병렬 서버에 무작위로 데이터를 분배할 때 사용된다.

무작위라고는 하지만 골고루 분배되도록 한다.

### Granuel

데이터를 병렬로 처리할 때 일의 최소 단위를 Granule이라고 한다.

병렬 서버는 한 번에 하나의 Granule만 처리한다. 개수와 크기는 병렬도와 관련이 있고 이는 병렬 서버 사이에 일을 고르게 분배하는데에 큰 영향을 미친다.

크게 블록 기반 Granuel과 파티션 기반 Granuel이 있는데, 이는 오라클 데이터베이스의 내부적인 결정사항으로 사용자는 지정할 수 없다.

#### 블록기반 Granuel

블록기반 GranueL은, 파티션 테이블인지 여부와 상관없이 대부분의 병렬 오퍼레이션에 적용되는 기본 작업 단위이다.

이 방식으로 데이터를 읽을 때는 실행계획상에 PX BLOCK ITERATOR이라고 표시된다.

QC는 테이블로부터 읽어야 할 일정 범위의 블록을 Granuel로서 각 병렬 서버에 할당한다.

그리고 ITERATOR가 의미하는 바와 같이 병렬 서버가 한 Granuel에 대한 일을 마치면 이어서 다른 Granuel을 할당한다.

Granule 크기와 총 개수는 실행 시점에 오브젝트 사이즈와 병렬도에 따라 QC가 동적으로 결정한다.

목표는 모든 병렬 서버에게 일을 골고루 분배하는 것으로, 아주 작은 테이블이 아니라면 Granuel 개수는 사용자가 지정한 병렬도 보다 많다.

#### 파티션 기반 Granuel

파티션 기반 Granuel이 사용될 때, 각 병렬 서버 프로세스는 할당받은 테이블 파티션 전체를 처리할 책임을 진다.

한 파티션을 두 개 프로세스가 함께 처리할 수 없으므로 병렬도는 파티션 개수 이하로만 지정할 수 있다.

이 방식을 사용하면 실행계획에 PX PARTITON RANGE ALL 또는 PX PARTITON RANGE ITERATOR 로 표시된다.

파티션 기반일 때는 Granule의 개수가 테이블과 인덱스의 파티션 구조에 의해 정적으로 결정되므로 블록 기반 Granuel처럼 유연하지 못하다.

파티션간 데이터량에 편차가 심할 때 부하를 효과적으로 분산시키는 데에 불리하고 리소스를 낭비하게된다.

따라서 파티션 기반은 병렬도보다 파티션 개수가 상당히 많아야 유리하다.

시스템 리소스를 최대한 사용하여 병렬 효과를 극대화하려 할때, 파티션 개수보다 많은 병렬도를 지정할 수 없다는 것도 단점이다.

파티션 기ㄴ Granule은 아래와 같은 작업을 수행할 때 사용된다.

\- partition-wise 조인 시스템
\- 파티션 인덱스를 병렬로 스캔할 때
\- 파티션 인덱스를 병렬로 갱신할 때
\- 9iR1 이전에서의 병렬 DML
\- 파티션 테이블 또는 파티션 인덱스를 병렬로 생성할 때

### 병렬 처리 과정에서 발생하는 대기 이벤트

병렬처리를 위한 데이터 재분배 과정에서 프로세스 간 통신이 발생한다.

QC와 병렬 서버 간, 병렬서버 간 테이블 큐를 통해 메시지를 주고받기 위해 내부적으로 메시지 버퍼를 사용한다.

생산자 프로세스가 버퍼에 데이터를 넣으면 소비자 프로세스가 그것을 꺼내 간다.

오라클은 credit 비트를 사용한다.

데이터를 전송하려면 먼저 상대편 서버 프로세스로부터 credit 비트를 받는다.

따라서 병렬 서버든 QC든 오직 한 프로세스만이 특정 서버 프로세스에게 데이터를 전송할 수 있다.

병렬 처리 과정에서 발생하는 대기 이벤트는 다음과 같다.

- PX Deq: Execute Reply : QC가 각 병렬 서버에게 작업을 배분하고 작업이 완료되기를 기다리는 상태
- PX Deq: Execution Msg : 병렬 서버가 자신의 임무를 완수하고서 다른 병렬 서버가 일을 마치기를 기다리는 상태, QC 또는 소비자 병렬 서버에게 데이터 전송을 완료했을 때 나타남
- PX Deq: Table Q Normal : 메시지 수신 대기, 메시지 큐에 데이터가 쌓이기를 기다리는 상태
- PX Deq Credit: send blkd : 메시지 송신 대기, QC 또는 소비자 병렬 서버에게 전송할 데이터가 있는데 블로킹 된 상태
- Px Deq: need buffer : 데이터를 전송하기 전에 상대편 병렬 서버 또는 QC로부터 credit 비트를 얻으려고 대기하는 상태

#### 대기 이벤트 모니터링

```sql
select /*+parallel(고객 2)*/ * from 고객 order by 고객명
```

위 쿼리에 대한 작업을 처음 시작하면 QC에는 PX Depq : Execute Reply 이벤트가 한동안 나타난다.

그러다 가장 먼저 작업을 끝낸 병렬 서버로부터 데이터를 받아 클라이언트에 전송하기 시작하면 SQL\*Net message from clinet로 바뀐다.

이는 클라이언트로부터 추가 Fetch Call이 오기를 기다리고 있다는 의미이다.

PX Deq:Execution Msg 가 발생한 세션은 생산자 서버로 부터 받은 데이터를 모두 정렬하고서 그 결과를 QC에게 전송까지 완료했지만 같은 서버 집합에 속한 세션의 작업이 끝나지 않아

대기하고 있는 상태를 말한다.

PX Dep Credit : send blkd msg 가 발생한 세션은 생산자 서버로부터 받은 데이터를 모두 정렬하고서 그 겨로가를 QC에 전송하려 하지만 QC가 ㄷ이터를 받아주지 않아 블로킹 된 상태를 의미한다.

이때 Qc는 자신이 받은 데이터를 클라이언트에게 다 전송하지 못해 대기하고 있는 상황이다.

PX Deq: Execution Msg 가 발생한 세션은 테이블 블록 범위를 모두 스캔하고서 소비자 서버에게 전송까지 완료한 상태로 다른서버들이 작업 완료하기를 기다리고 있는 것이다.

#### 대기 이벤트 해소

v$event_name 뷰를 조회해보면 병렬처리와 관련된 대기 이벤트가 대부분 Idle로 분류돼 있다.

이유는, 이벤트를 회피하기 위해 사용자가 할 수 있는 일들이 거의 없기 때문이다.

큰 테이블ㅇ르 S-P 방식으로 분배하던 것을 P-P 방식으로 바꿔주고나 P-P 분배 과정에서 프로세스 간 데이터 전송량이 많ㅇ느 SQL을 튜닝해서 그 양을 줄일 수 있다.

그런 조치가 가능하지 않은 상황에서 병렬 쿼리 관련 Idle 대기 이벤트가 많이 발생하는 것은 자연스러운 현상이다.

Idle 이벤트가 아닌 경우 종종 튜닝이 가능할 수 있다.

```sql
insert /*+append*/ into t1
select /*+full(t2) parallel(t2 t)*/ * from t2
```

t2 테이블은 병렬로 읽지만 t1은 insert는 직렬로 수행된다.

이럴 때 t2를 읽어 QC에 전송하는 4개의 병렬 서버는 Px Deq Credit: send blkd 이벤트에서 자주 대기한다.

insert 과정에서 병목이 생기므로 select 문을 병렬로 수행하는 것은 불필요하다. select 문을 직렬로 처리하면 이벤트는 해소된다.

병목을 해소하려면 t1으로의 insert도 병렬로 수행하게 하면 된다.

```sql
alter session enable parallel dml;
insert /*+append parallel(t1 4) */ into t1
select /*+full(t2) parallel(t2 t)*/ * from t2
```

insert를 담당한 1번 병렬 서버 집합은 Direct Path Write를 수행하거나 2번 서버 집합으로부터 메시지를 수신하기 위해 대기 한다.

select를 담당한 2번병렬ㅅ버 집합은 Direct Path Read를 수행하거나 1번 서버 집합으로 메시지를 송신하기 위해 대기한다.
